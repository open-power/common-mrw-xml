<attributes>
  <attribute>
    <description>ADC Channel function id. 16 channels.</description>
    <id>ADC_CHANNEL_FUNC_IDS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>16</array>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>ADC channel gain * 1000. 16 channels.</description>
    <id>ADC_CHANNEL_GAINS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>16</array>
      <uint32_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>ADC Channel ground. 16 channels.</description>
    <id>ADC_CHANNEL_GNDS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>16</array>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>ADC channel offset * 1000. 16 channels</description>
    <id>ADC_CHANNEL_OFFSETS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>16</array>
      <uint32_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>ADC Channel IPMI sensor numbers. 16 channels.</description>
    <id>ADC_CHANNEL_SENSOR_NUMBERS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>16</array>
      <uint32_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>Hierarchical path to the target with respect to logical affinity</description>
    <id>AFFINITY_PATH</id>
    <mrwRequired/>
    <nativeType>
      <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>System attribute. If all MCS chiplets are in an interleaving group (1=true, 0=false). - If true the SMP fabric is setup in normal mode and multiple MCSs are grouped (disallowing systems with memory only under 1 MCS (i.e. systems with a single C-DIMM)) - If false the SMP fabric is setup in checkerboard mode. Provided by the Machine Readable Workbook. This attribute is based on Machine-Type-Model (MTM) and is setup by the service processor.</description>
    <id>ALL_MCS_IN_INTERLEAVING_GROUP</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>APSS GPIO PORT MODES</description>
    <id>APSS_GPIO_PORT_MODES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>2</array>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>APSS GPIO PORT PINS Port0 pin 0-7 Port1 pin 8-15</description>
    <id>APSS_GPIO_PORT_PINS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>16</array>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>LX keyword VPD data for HDAT module</description>
    <id>ASCII_VPD_LX_KEYWORD</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>The asynchronous nest frequency</description>
    <id>ASYNC_NEST_FREQ_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>2000</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Time between invocations of auxiliary function on GPE1. The time (in is as 2^ATTR_AUX_FUNC_INVOCATION_TIME_MS with 0 indicating the is OFF. Consumer: p10_hcode_image_build.c -&gt; XGPE Header field Provided by the Machine Readable Workbook to tune the collection. Platform default:1</description>
    <id>AUX_FUNC_INVOCATION_TIME_MS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_AUX_FUNC_INVOCATION_TIME_MS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Memory AVDD voltage domain ID. All memory buffers in the same AVDD voltage domain will share the same ID. IDs are arbitrarily assigned, used for correlation between HB + HWSV, and are generated by MRW processing scripts.</description>
    <id>AVDD_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Defines the AVSBus (0, 1 or 2) which has the indicated rail VRM [index] -&gt;0: VDD; 1: VCS; 2: VDN; 3: VIO Producer:Machine Readable Workbook Consumers: p10_set_evid; p10_set_voltage (tool) -&gt; Global Pstate Parameter Block (GPPB) for PGPE; OCC Pstate Parameter Block OCC *MOST* systems use Bus 0 for VDD, Bus 1 for VCS, Bus 2 for VIO and VDN. If is not the case, the value must be appropriately set by the platform (eg MRW or equivalent)</description>
    <id>AVSBUS_BUSNUM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_AVSBUS_BUSNUM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>AVSBus Clock Frequency (binary in KHz) Consumer: p10_ocb_init.C Overridden by the Machine Readable Workbook. If default of 0 is read, HWP will set AVSBus frequency to 1MHz.</description>
    <id>AVSBUS_FREQUENCY</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_AVSBUS_FREQUENCY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Defines the AVSBus rail selector number (0 - 15) for the VRM on the bus by ATTR_AVSBUS_BUSNUM[x]. [index] -&gt;0: VDD; 1: VCS; 2: VDN; 3: VIO Producer:Machine Readable Workbook Consumers: p10_set_evid; p10_set_voltage (tool) -&gt; Global Pstate Parameter Block (GPPB) for PGPE OCC Pstate Parameter Block OCC *MOST* systems use Bus 0 for VDD, Bus 1 for VCS, Bus 2 for VIO and VDN. If is not the case, the value must be appropriately set by the platform (eg or equivalent)</description>
    <id>AVSBUS_RAIL</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_AVSBUS_RAIL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>BMC FRU ID attribute to report the system firmware levels to the BMC.</description>
    <id>BMC_FRU_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>The type of hardware of the BMC</description>
    <id>BMC_HW_CHIP_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <default>ast2500</default>
        <sizeInclNull>32</sizeInclNull>
      </string>
    </simpleType>
  </attribute>

  <attribute>
    <description>The manufacturer of the BMC</description>
    <id>BMC_MANUFACTURER</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <default>ibm</default>
        <sizeInclNull>32</sizeInclNull>
      </string>
    </simpleType>
  </attribute>

  <attribute>
    <description>The software type of the BMC</description>
    <id>BMC_SW_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <default>openbmc</default>
        <sizeInclNull>32</sizeInclNull>
      </string>
    </simpleType>
  </attribute>

  <attribute>
    <description>EQ boot frequency</description>
    <id>BOOT_FREQ_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>2400</default>
      </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_BOOT_FREQ_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Force the SBE to boot with PAU DPLL in bypass</description>
    <id>BOOT_PAU_DPLL_BYPASS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>BYPASS</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_BOOT_PAU_DPLL_BYPASS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Force the SBE to boot with PAU DPLL in bypass</description>
    <enumerator>
      <name>BYPASS</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>NO_BYPASS</name>
      <value>0x0</value>
    </enumerator>
    <id>BOOT_PAU_DPLL_BYPASS</id>
  </enumerationType>

  <attribute>
    <description>Cec Degraded Mode Policy flags Use the CDM_POLICIES enum to decode. If the appropriate bit is 1 then the policy mode is enabled, and those type of Guard records are disabled.</description>
    <id>CDM_POLICIES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <writeable/>
  </attribute>

  <enumerationType>
    <description>Enumeration of CDM_POLICIES flags</description>
    <enumerator>
      <description>MFG_Guard policy: Used in MFG only to prevent and disable the following: . Storing or creation of new Guard records from Diagno`stic or other faults through error logs. This is all domains, CEC processor/memory, VPD, FSP, etc. . Storing or creation of Manual Guard record from user. NOTE: this does not stop FCO. . Using an already stored System or Manual Guard record from deconfiguring resources. This is all domains, CEC processor/memory, VPD, FSP, etc.</description>
      <name>MANUFACTURING_DISABLED</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <description>Predictive_Guard policy: Used in Field or development to prevent and disable the following: . Storing or creation of new Guard records from diagnostics or other faults through error logs with the error_type of Predictive. . Using an already stored System Guard record with error_type of Predictive from deconfiguring resources.</description>
      <name>PREDICTIVE_DISABLED</name>
      <value>0x02</value>
    </enumerator>
    <id>CDM_POLICIES</id>
  </enumerationType>

  <attribute>
    <description>FRU ID attribute for centaur ECID data. This fru ID is used to report the ECID data to the BMC and make it available for systems which have then centaur chips soldered to the backplane.</description>
    <id>CENTAUR_ECID_FRU_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>The address offset which each Chiplet types pervasive address space used to represent the a chiplet. 0x00 to 0x0F =&gt; For P9 all non-core and non-cache chiplets 0x10 to 0x1F =&gt; All Cache Chiplets 0x20 to 0x37 =&gt; All Core Chiplets 0x38 to 0x3F =&gt; Multicast Operation</description>
    <id>CHIPLET_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Bit vector indicating the active cores to be set by p10_sbe_select_ex for a chip contained IPL. Bit 0 = Core 0, Bit 1 = Core 1, ..., Bit 31 = Core 31.</description>
    <id>CHIP_CONTAINED_ACTIVE_CORES_VEC</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_CHIP_CONTAINED_ACTIVE_CORES_VEC</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Bit vector indicating the backing caches to be set by by p10_sbe_select_ex. Bit 0 = Cache 0, Bit 1 = Cache 1, ..., Bit 31 = Cache 31.</description>
    <id>CHIP_CONTAINED_BACKING_CACHES_VEC</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_CHIP_CONTAINED_BACKING_CACHES_VEC</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>A unit's position within the chip with respect to similar units. Note that this value is relative to the parent chip, not a parent unit. This data is from the MRW.</description>
    <id>CHIP_UNIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_CHIP_UNIT_POS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Attribute indicating the target's chip version</description>
    <hasStringConversion/>
    <id>CHIP_VER</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>CHIP_VER</id>
      </enumeration>
    </simpleType>
  </attribute>

  <enumerationType>
    <default>DD10</default>
    <description>Enumeration indicating the chip version</description>
    <enumerator>
      <name>DD10</name>
      <value>0x10</value>
    </enumerator>
    <enumerator>
      <name>DD11</name>
      <value>0x11</value>
    </enumerator>
    <enumerator>
      <name>DD20</name>
      <value>0x20</value>
    </enumerator>
    <enumerator>
      <name>DD21</name>
      <value>0x21</value>
    </enumerator>
    <id>CHIP_VER</id>
  </enumerationType>

  <attribute>
    <description>Attribute indicating the target's class</description>
    <hasStringConversion/>
    <id>CLASS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>CLASS</id>
      </enumeration>
    </simpleType>
  </attribute>

  <enumerationType>
    <default>NA</default>
    <description>Enumeration indicating the target's class</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>CARD</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ENC</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>CHIP</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>UNIT</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>DEV</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>SYS</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>LOGICAL_CARD</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>BATTERY</name>
      <value>8</value>
    </enumerator>
    <enumerator>
      <name>LED</name>
      <value>9</value>
    </enumerator>
    <enumerator>
      <name>SP</name>
      <value>10</value>
    </enumerator>
    <enumerator>
      <name>ASIC</name>
      <value>11</value>
    </enumerator>
    <enumerator>
      <name>MAX</name>
      <value>12</value>
    </enumerator>
    <id>CLASS</id>
  </enumerationType>

  <attribute>
    <description>Set up the chip so that all chiplet clocks are automatically stopped in case of a checkstop. Possible enum values: DISABLED - Don't stop clocks on any error STOP_ON_XSTOP - Stop on either an xstop in the local chiplet or on a system xstop coming in from outside the chiplet STOP_ON_XSTOP_AND_SPATTN - Like above, plus special attentions STOP_ON_STAGED_XSTOP - Stop _only_ on an incoming staged system xstop to ensure that all chiplets stop in the same instant. This will result in a longer delay between the original error and the clocks stopping.</description>
    <id>CLOCKSTOP_ON_XSTOP</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCKSTOP_ON_XSTOP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Set up the chip so that all chiplet clocks are automatically stopped in case of a checkstop. Possible enum values: DISABLED - Don't stop clocks on any error STOP_ON_XSTOP - Stop on either an xstop in the local chiplet or on a system xstop coming in from outside the chiplet STOP_ON_XSTOP_AND_SPATTN - Like above, plus special attentions STOP_ON_STAGED_XSTOP - Stop _only_ on an incoming staged system xstop to ensure that all chiplets stop in the same instant. This will result in a longer delay between the original error and the clocks stopping.</description>
    <enumerator>
      <name>DISABLED</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>STOP_ON_XSTOP</name>
      <value>0x7B</value>
    </enumerator>
    <enumerator>
      <name>STOP_ON_XSTOP_AND_SPATTN</name>
      <value>0x5B</value>
    </enumerator>
    <enumerator>
      <name>STOP_ON_STAGED_XSTOP</name>
      <value>0xFD</value>
    </enumerator>
    <id>CLOCKSTOP_ON_XSTOP</id>
  </enumerationType>

  <attribute>
    <description>RCS PLL input for TOD Filter PLL</description>
    <id>CLOCK_MUX0A_RCS_PLL_INPUT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCK_MUX0A_RCS_PLL_INPUT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>RCS PLL input for TOD Filter PLL</description>
    <enumerator>
      <name>SYS_REFCLOCK0</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>RCS_ASYNC_OUT</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>RCS_SYNC_OUT</name>
      <value>0x1</value>
    </enumerator>
    <id>CLOCK_MUX0A_RCS_PLL_INPUT</id>
  </enumerationType>

  <attribute>
    <description>RCS PLL input for Nest Filter PLL</description>
    <id>CLOCK_MUX0B_RCS_PLL_INPUT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCK_MUX0B_RCS_PLL_INPUT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>RCS PLL input for Nest Filter PLL</description>
    <enumerator>
      <name>SYS_REFCLOCK0</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>RCS_ASYNC_OUT</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>RCS_SYNC_OUT</name>
      <value>0x1</value>
    </enumerator>
    <id>CLOCK_MUX0B_RCS_PLL_INPUT</id>
  </enumerationType>

  <attribute>
    <description>RCS PLL input for IO Filter PLL</description>
    <id>CLOCK_MUX0C_RCS_PLL_INPUT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCK_MUX0C_RCS_PLL_INPUT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>RCS PLL input for IO Filter PLL</description>
    <enumerator>
      <name>SYS_REFCLOCK0</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>RCS_ASYNC_OUT</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>RCS_SYNC_OUT</name>
      <value>0x1</value>
    </enumerator>
    <id>CLOCK_MUX0C_RCS_PLL_INPUT</id>
  </enumerationType>

  <attribute>
    <description>RCS PLL input for IO Spread Spectrum Filter PLL</description>
    <id>CLOCK_MUX0D_RCS_PLL_INPUT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCK_MUX0D_RCS_PLL_INPUT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>RCS PLL input for IO Spread Spectrum Filter PLL</description>
    <enumerator>
      <name>SYS_REFCLOCK0</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>RCS_ASYNC_OUT</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>RCS_SYNC_OUT</name>
      <value>0x1</value>
    </enumerator>
    <id>CLOCK_MUX0D_RCS_PLL_INPUT</id>
  </enumerationType>

  <attribute>
    <description>PAU DPLL input from Filter PLLs</description>
    <id>CLOCK_MUX10_PAU_DPLL_INPUT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCK_MUX10_PAU_DPLL_INPUT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>PAU DPLL input from Filter PLLs</description>
    <enumerator>
      <name>PLLIOSSFLT</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>PLLIOFLT</name>
      <value>1</value>
    </enumerator>
    <id>CLOCK_MUX10_PAU_DPLL_INPUT</id>
  </enumerationType>

  <attribute>
    <description>NEST DPLL input from Filter PLLs</description>
    <id>CLOCK_MUX11_NEST_DPLL_INPUT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCK_MUX11_NEST_DPLL_INPUT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>NEST DPLL input from Filter PLLs</description>
    <enumerator>
      <name>PLLIOSSFLT</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>PLLIOFLT</name>
      <value>1</value>
    </enumerator>
    <id>CLOCK_MUX11_NEST_DPLL_INPUT</id>
  </enumerationType>

  <attribute>
    <description>OMI LCPLL input</description>
    <id>CLOCK_MUX12_OMI_LCPLL_INPUT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCK_MUX12_OMI_LCPLL_INPUT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>OMI LCPLL input</description>
    <enumerator>
      <name>PLLTODFLT</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>PLLNESTFLT</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>PLLIOFLT</name>
      <value>1</value>
    </enumerator>
    <id>CLOCK_MUX12_OMI_LCPLL_INPUT</id>
  </enumerationType>

  <attribute>
    <description>Mux 13 input</description>
    <id>CLOCK_MUX13_OPT_133_SOURCE_INPUT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCK_MUX13_OPT_133_SOURCE_INPUT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Mux 13 input</description>
    <enumerator>
      <name>PLLTODFLT</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>PLLNESTFLT</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>PLLIOFLT</name>
      <value>1</value>
    </enumerator>
    <id>CLOCK_MUX13_OPT_133_SOURCE_INPUT</id>
  </enumerationType>

  <attribute>
    <description>Mux 14 input</description>
    <id>CLOCK_MUX14_OPT_156_SOURCE_INPUT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCK_MUX14_OPT_156_SOURCE_INPUT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Mux 14 input</description>
    <enumerator>
      <name>PLLNESTFLT</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>PLLIOFLT</name>
      <value>1</value>
    </enumerator>
    <id>CLOCK_MUX14_OPT_156_SOURCE_INPUT</id>
  </enumerationType>

  <attribute>
    <description>MUX 1 input</description>
    <id>CLOCK_MUX1_INPUT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCK_MUX1_INPUT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>MUX 1 input</description>
    <enumerator>
      <name>MUX10</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TCK</name>
      <value>1</value>
    </enumerator>
    <id>CLOCK_MUX1_INPUT</id>
  </enumerationType>

  <attribute>
    <description>Mux 23 input from FPLL</description>
    <id>CLOCK_MUX23_PCI_INPUT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCK_MUX23_PCI_INPUT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Mux 23 input from FPLL</description>
    <enumerator>
      <name>PLLTODFLT</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>PLLIOSSFLT</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>MUX0D</name>
      <value>1</value>
    </enumerator>
    <id>CLOCK_MUX23_PCI_INPUT</id>
  </enumerationType>

  <attribute>
    <description>MUX 2a input</description>
    <id>CLOCK_MUX2A_INPUT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCK_MUX2A_INPUT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>MUX 2a input</description>
    <enumerator>
      <name>PAU_DPLL</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>MUX1</name>
      <value>1</value>
    </enumerator>
    <id>CLOCK_MUX2A_INPUT</id>
  </enumerationType>

  <attribute>
    <description>MUX 2b input</description>
    <id>CLOCK_MUX2B_INPUT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCK_MUX2B_INPUT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>MUX 2b input</description>
    <enumerator>
      <name>PAU_DPLL</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>MUX1</name>
      <value>1</value>
    </enumerator>
    <id>CLOCK_MUX2B_INPUT</id>
  </enumerationType>

  <attribute>
    <description>MUX 3 input</description>
    <id>CLOCK_MUX3_INPUT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCK_MUX3_INPUT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>MUX 3 input</description>
    <enumerator>
      <name>NEST_DPLL</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>MUX2B</name>
      <value>1</value>
    </enumerator>
    <id>CLOCK_MUX3_INPUT</id>
  </enumerationType>

  <attribute>
    <description>IOHS LCPLL input IOHS0: Mux15 IOHS1: Mux16 (no Mux13 input) IOHS2: Mux17 (no Mux13 input) IOHS3: Mux18 IOHS4: Mux19 IOHS5: Mux20 IOHS6: Mux21 IOHS7: Mux22</description>
    <id>CLOCK_MUX_IOHS_LCPLL_INPUT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>8</array>
      <uint8_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCK_MUX_IOHS_LCPLL_INPUT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>IOHS LCPLL input IOHS0: Mux15 IOHS1: Mux16 (no Mux13 input) IOHS2: Mux17 (no Mux13 input) IOHS3: Mux18 IOHS4: Mux19 IOHS5: Mux20 IOHS6: Mux21 IOHS7: Mux22</description>
    <enumerator>
      <name>PLLTODFLT</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>MUX14</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>MUX13</name>
      <value>1</value>
    </enumerator>
    <id>CLOCK_MUX_IOHS_LCPLL_INPUT</id>
  </enumerationType>

  <attribute>
    <description>PCI LCPLL input mux control PCI0: Mux24 PCI1: Mux25</description>
    <id>CLOCK_MUX_PCI_LCPLL_INPUT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>2</array>
      <uint8_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCK_MUX_PCI_LCPLL_INPUT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>PCI LCPLL input mux control PCI0: Mux24 PCI1: Mux25</description>
    <enumerator>
      <name>MUX23</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>PCI_REFCLOCK0</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>PCI_REFCLOCK1</name>
      <value>1</value>
    </enumerator>
    <id>CLOCK_MUX_PCI_LCPLL_INPUT</id>
  </enumerationType>

  <attribute>
    <description>setup clock mux settings for TOD Refclock input 0b0 = 32 MHz LPC reference clock 0b1 = 16 MHz I/O Filter PLL Output</description>
    <id>CLOCK_PLL_MUX_TOD</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCK_PLL_MUX_TOD</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>setup clock mux settings for TOD Refclock input 0b0 = 32 MHz LPC reference clock 0b1 = 16 MHz I/O Filter PLL Output</description>
    <enumerator>
      <name>LPC_REFCLOCK</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>PLLTODFLT</name>
      <value>1</value>
    </enumerator>
    <id>CLOCK_PLL_MUX_TOD</id>
  </enumerationType>

  <attribute>
    <description>Enables the SGPE Hcode to enable the CME instruction traces into the CHTM for debug. Note: all configured CMEs will be put into this mode if this attribute is ON. Consumer: p9_hcode_image_build.c -&gt; SGPE Header field Platform default: OFF</description>
    <id>CME_CHTM_TRACE_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_CME_CHTM_TRACE_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Enables the SGPE Hcode to enable the CME instruction traces into the CHTM for debug. Note: all configured CMEs will be put into this mode if this attribute is ON. Consumer: p9_hcode_image_build.c -&gt; SGPE Header field Platform default: OFF</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <id>CME_CHTM_TRACE_ENABLE</id>
  </enumerationType>

  <attribute>
    <description>CHTM Trace Memory Configuration value goes directly into CHTM_MEM register. User is responsible to put correct data for each bit field of the register. Consumer: p9_hcode_image_build.c -&gt; SGPE Header field Platform default: 0</description>
    <id>CME_CHTM_TRACE_MEMORY_CONFIG</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_CME_CHTM_TRACE_MEMORY_CONFIG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Enables the SGPE Hcode to enable the CME instruction traces into the L3 Trace array for debug. Note: all configured CMEs will be put into this mode if this attribute is ON. Consumer: p9_hcode_image_build.c -&gt; SGPE Header field Platform default: OFF</description>
    <id>CME_INSTRUCTION_TRACE_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_CME_INSTRUCTION_TRACE_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Enables the SGPE Hcode to enable the CME instruction traces into the L3 Trace array for debug. Note: all configured CMEs will be put into this mode if this attribute is ON. Consumer: p9_hcode_image_build.c -&gt; SGPE Header field Platform default: OFF</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <id>CME_INSTRUCTION_TRACE_ENABLE</id>
  </enumerationType>

  <attribute>
    <description>Weight factor (1 = 0.1) for each core DTS to calculate a core temperature and eventually processor temperatures that is used for DVFS and fan control.</description>
    <id>CORE_WEIGHT_TENTHS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>8</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>To skip the locking sequence and check for lock of CP IO Filter PLL</description>
    <id>CP_PLLIOFLT_BYPASS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_CP_PLLIOFLT_BYPASS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>To skip the locking sequence and check for lock of CP IO Filter PLL</description>
    <enumerator>
      <name>BYPASS</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>NO_BYPASS</name>
      <value>0x0</value>
    </enumerator>
    <id>CP_PLLIOFLT_BYPASS</id>
  </enumerationType>

  <attribute>
    <description>To skip the locking sequence and check for lock of CP IO Spread Spectrum Filter PLL</description>
    <id>CP_PLLIOSSFLT_BYPASS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_CP_PLLIOSSFLT_BYPASS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>To skip the locking sequence and check for lock of CP IO Spread Spectrum Filter PLL</description>
    <enumerator>
      <name>BYPASS</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>NO_BYPASS</name>
      <value>0x0</value>
    </enumerator>
    <id>CP_PLLIOSSFLT_BYPASS</id>
  </enumerationType>

  <attribute>
    <description>To skip the locking sequence and check for lock of CP Nest Filter PLL</description>
    <id>CP_PLLNESTFLT_BYPASS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_CP_PLLNESTFLT_BYPASS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>To skip the locking sequence and check for lock of CP Nest Filter PLL</description>
    <enumerator>
      <name>BYPASS</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>NO_BYPASS</name>
      <value>0x0</value>
    </enumerator>
    <id>CP_PLLNESTFLT_BYPASS</id>
  </enumerationType>

  <attribute>
    <description>To skip the locking sequence and check for lock of CP TOD Filter PLL</description>
    <id>CP_PLLTODFLT_BYPASS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_CP_PLLTODFLT_BYPASS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>To skip the locking sequence and check for lock of CP TOD Filter PLL</description>
    <enumerator>
      <name>BYPASS</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>NO_BYPASS</name>
      <value>0x0</value>
    </enumerator>
    <id>CP_PLLTODFLT_BYPASS</id>
  </enumerationType>

  <attribute>
    <description>The scaling factor to be applied to currents read from the respective VRM before consumption. [Index]-&gt;8 entries-: 0: VDD 1: VCS 2: VDN 3: VIO 4: AVDD 5: Reserved 6: Reserved 7: Reserved</description>
    <id>CURRENT_SCALING_FACTOR</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>8</array>
      <uint8_t>
        <default>1,1,1,1,1,1,1,1</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_CURRENT_SCALING_FACTOR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Keep core duty cycle adjust logic bypassed</description>
    <id>DCADJ_BYPASS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_DCADJ_BYPASS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Keep core duty cycle adjust logic bypassed</description>
    <enumerator>
      <name>BYPASS</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>NO_BYPASS</name>
      <value>0x0</value>
    </enumerator>
    <id>DCADJ_BYPASS</id>
  </enumerationType>

  <attribute>
    <description>Integer adjustment value applied to the #W DELAY value of the respective curve fit (CF) point that depends on the good sorted cores. 10BC/15BC is considered config A; 12BC is considered config B [Point] -&gt;8 entries-: 0: 10BC/15BC CF4; 1: 10BC/15BC CF5; 2: 10BC/15BC CF6; 3: 10BC/15BC CF7; 4: 12BC CF4; 5: 12BC CF5; 6: 12BC CF6; 7: 12BC CF7; Consumer: p10_pstate_parameter_build</description>
    <id>DDS_DELAY_ADJUST</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>8</array>
      <int16_t>
        <default>0,2,2,2,0,2,2,4</default>
      </int16_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_DDS_DELAY_ADJUST</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Indicates the response of the DPLL frequency upon DDS events if the DDS is enabled. NONE -&gt; DPLL Mode 2, JUMP_PROTECT -&gt; DPLL Mode 3, SLEW_MODE -&gt; DPLL Mode 4 Producer: MRWB</description>
    <id>DDS_DPLL_SLEW_MODE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_DDS_DPLL_SLEW_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Indicates the response of the DPLL frequency upon DDS events if the DDS is enabled. NONE -&gt; DPLL Mode 2, JUMP_PROTECT -&gt; DPLL Mode 3, SLEW_MODE -&gt; DPLL Mode 4 Producer: MRWB</description>
    <enumerator>
      <name>NONE</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>JUMP_PROTECT</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>SLEW_MODE</name>
      <value>0x02</value>
    </enumerator>
    <id>DDS_DPLL_SLEW_MODE</id>
  </enumerationType>

  <attribute>
    <description>Integer adjustment value applied to the #W LARGE_DROOP_DETECT value of the respective curve fit (CF) point. [Point] -&gt;8 entries-: 0: CF0; 1: CF1; 2: CF2; 3: CF3; 4: CF4; 5: CF5; 6: CF6; 7: CF7; Consumer: p10_pstate_parameter_build</description>
    <id>DDS_LARGE_DROOP_DETECT_ADJUST</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>8</array>
      <int8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_DDS_LARGE_DROOP_DETECT_ADJUST</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>A bit vector to indicate which of FDCR items to interpolate. Multiple items can be set to be interpolated. Producer: MRWB</description>
    <id>DDS_TRIP_INTERPOLATION_CONTROL</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0x88</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_DDS_TRIP_INTERPOLATION_CONTROL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>A bit vector to indicate which of FDCR items to interpolate. Multiple items can be set to be interpolated. Producer: MRWB</description>
    <enumerator>
      <name>TRIP</name>
      <value>0x80</value>
    </enumerator>
    <enumerator>
      <name>DATA0</name>
      <value>0x40</value>
    </enumerator>
    <enumerator>
      <name>DATA1</name>
      <value>0x20</value>
    </enumerator>
    <enumerator>
      <name>DATA2</name>
      <value>0x10</value>
    </enumerator>
    <enumerator>
      <name>LARGE</name>
      <value>0x8</value>
    </enumerator>
    <enumerator>
      <name>SMALL</name>
      <value>0x4</value>
    </enumerator>
    <enumerator>
      <name>SLOPEA</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>SLOPEB</name>
      <value>0x1</value>
    </enumerator>
    <id>DDS_TRIP_INTERPOLATION_CONTROL</id>
  </enumerationType>

  <attribute>
    <description>Indicates whether to calculate trip offsets per core or per chip. Default is per chip. CHIP or CORE Producer: MRWB</description>
    <id>DDS_TRIP_MODE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>CHIP</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_DDS_TRIP_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Indicates whether to calculate trip offsets per core or per chip. Default is per chip. CHIP or CORE Producer: MRWB</description>
    <enumerator>
      <name>CHIP</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>CORE</name>
      <value>0x01</value>
    </enumerator>
    <id>DDS_TRIP_MODE</id>
  </enumerationType>

  <attribute>
    <description>DIMM Temperature in degrees C that a DIMM overtemp error will be logged calling out the DIMM</description>
    <id>DIMM_ERROR_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>84</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Maximum time in seconds allowed without having a new DIMM temperature before memory throttling will occur</description>
    <id>DIMM_READ_TIMEOUT_SEC</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>30</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>DIMM Temperature to invoke memory throttling in degrees C</description>
    <id>DIMM_THROTTLE_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>69</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Dummy attribute with read-only permissions</description>
    <id>DUMMY_RO</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Indicates which istep we should execute the CXX testcases after, if CONFIG_EARLY_TESTCASES is set. Format: 0xMMmm, where MM=major step, mm=minor step, e.g. 6.9=0x0609.</description>
    <id>EARLY_TESTCASES_ISTEP</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0x0609</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Specifies a target's eeprom content type.</description>
    <hasStringConversion/>
    <id>EEPROM_CONTENT_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>EEPROM_CONTENT_TYPE</id>
      </enumeration>
    </simpleType>
  </attribute>

  <enumerationType>
    <default>RAW</default>
    <description>Enumeration indicating a target's eeprom content type. RAW - eeprom has no specified layout ISDIMM - uses standard JEDEC layout for DDR memory IBM_FRUVPD - uses ipz converged vpd layout with records/keywords for generic FRUs IBM_MVPD - use ipz converged vpd layout with records/keywords for processor modules DDIMM - uses Differential DIMM layout SBE_BOOT_CODE - SBE code SBE_MEASUREMENT_CODE - Measurement code WOF_DATA - WOF data KEYSTORE - Keystore data</description>
    <enumerator>
      <name>RAW</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ISDIMM</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>IBM_FRUVPD</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>IBM_MVPD</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>DDIMM</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>SBE_BOOT_CODE</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>SBE_MEASUREMENT_CODE</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>WOF_DATA</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>KEYSTORE</name>
      <value>8</value>
    </enumerator>
    <id>EEPROM_CONTENT_TYPE</id>
  </enumerationType>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for NV controller.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master.</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit value, but then shifted 2 bits left.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit value, but then shifted 6 bits left.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x03</default>
        <description>The number of bytes a device requires to set its internal address/offset. For NV controller it's only one byte addressing with no page select (3) 0 = Zero Byte Addressing 1 = One Byte Addressing with page select 2 = Two Byte Addressing 3 = OneByte Addressing with no page select</description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x01</default>
        <description>The number of kilobytes a device can hold. 'Zero' value possible for some devices.</description>
        <name>maxMemorySizeKB</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x01</default>
        <description>The number of chips making up an eeprom device.</description>
        <name>chipCount</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x01</default>
        <description>The maximum number of bytes that can be written to a device at one time. 'Zero' value means no maximum value is expected or checked.</description>
        <name>writePageSize</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x05</default>
        <description>The amount of time in milliseconds a device requires on the completion of a write command to update its internal memory.</description>
        <name>writeCycleTime</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux will connect to. OxFF indicates no mux present or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address the NV controller on the NVDIMM</description>
    <id>EEPROM_NV_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an I2C slave device.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x02</default>
        <description>The number of bytes a device requires to set its internal address/offset.</description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x100</default>
        <description>The number of kilobytes a device can hold. 'Zero' value possible for some devices.</description>
        <name>maxMemorySizeKB</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x04</default>
        <description>The number of chips making up an eeprom device.</description>
        <name>chipCount</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The maximum number of bytes that can be written to a device at one time. 'Zero' value means no maximum value is expected or checked.</description>
        <name>writePageSize</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The amount of time in milliseconds a device requires on the completion of a write command to update its internal memory.</description>
        <name>writeCycleTime</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux will connect to. OxFF indicates no mux present or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address the EERPROM slaves</description>
    <id>EEPROM_SBE_BACKUP_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an I2C slave device.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x02</default>
        <description>The number of bytes a device requires to set its internal address/offset.</description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x100</default>
        <description>The number of kilobytes a device can hold. 'Zero' value possible for some devices.</description>
        <name>maxMemorySizeKB</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x04</default>
        <description>The number of chips making up an eeprom device.</description>
        <name>chipCount</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The maximum number of bytes that can be written to a device at one time. 'Zero' value means no maximum value is expected or checked.</description>
        <name>writePageSize</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The amount of time in milliseconds a device requires on the completion of a write command to update its internal memory.</description>
        <name>writeCycleTime</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux will connect to. OxFF indicates no mux present or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address the EERPROM slaves</description>
    <id>EEPROM_SBE_PRIMARY_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached I2C eeprom device that contains secondary VPD info.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Port from the I2C Master device. This is a 6-bit value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Device address on the I2C bus. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>The number of bytes a device requires to set its internal address/offset.</description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFFFFFFFFFFFFFFFF</default>
        <description>The number of kilobytes a device can hold. 'Zero' value possible for some devices.</description>
        <name>maxMemorySizeKB</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>The number of chips making up an eeprom device.</description>
        <name>chipCount</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFFFFFFFFFFFFFFFF</default>
        <description>The maximum number of bytes that can be written to a device at one time. 'Zero' value means no maximum value is expected or checked.</description>
        <name>writePageSize</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFFFFFFFFFFFFFFFF</default>
        <description>The amount of time in milliseconds a device requires on the completion of a write command to update its internal memory.</description>
        <name>writeCycleTime</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux will connect to. OxFF indicates no mux present or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFFFFFFFF</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint32_t</type>
      </field>
    </complexType>
    <description>Information needed to address the EERPROM slaves</description>
    <id>EEPROM_VPD_BACKUP_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached I2C eeprom device that contains primary VPD info.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Port from the I2C Master device. This is a 6-bit value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Device address on the I2C bus. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>The number of bytes a device requires to set its internal address/offset. DDR4 DIMMs require a special EEPROM page switching mechanic denoted here by a value of 1 0 = Zero Byte Addressing 1 = One Byte Addressing with page select 2 = Two Byte Addressing 3 = OneByte Addressing with no page select</description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFFFFFFFFFFFFFFFF</default>
        <description>The number of kilobytes a device can hold. 'Zero' value possible for some devices.</description>
        <name>maxMemorySizeKB</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>The number of chips making up an eeprom device.</description>
        <name>chipCount</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFFFFFFFFFFFFFFFF</default>
        <description>The maximum number of bytes that can be written to a device at one time. 'Zero' value means no maximum value is expected or checked.</description>
        <name>writePageSize</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFFFFFFFFFFFFFFFF</default>
        <description>The amount of time in milliseconds a device requires on the completion of a write command to update its internal memory.</description>
        <name>writeCycleTime</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux will connect to. OxFF indicates no mux present or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFFFFFFFF</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint32_t</type>
      </field>
    </complexType>
    <description>Information needed to address the EEPROM slaves</description>
    <id>EEPROM_VPD_PRIMARY_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>Attribute indicating the target's engine type</description>
    <hasStringConversion/>
    <id>ENGINE_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>ENGINE_TYPE</id>
      </enumeration>
    </simpleType>
  </attribute>

  <enumerationType>
    <default>NA</default>
    <description>Enumeration indicating the target's engine type</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ENGINE_IIC</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ENGINE_SCOM</name>
      <value>2</value>
    </enumerator>
    <id>ENGINE_TYPE</id>
  </enumerationType>

  <enumerationType>
    <description>Enumeration indicating the IPMI entity ID, these values are defined in the IPMI specification. These values will be used in place of target type when events are sent to the BMC.</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>OTHER</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>PROCESSOR</name>
      <value>0x03</value>
    </enumerator>
    <enumerator>
      <name>SYSTEM_BOARD</name>
      <value>0x07</value>
    </enumerator>
    <enumerator>
      <name>POWER_MGMT</name>
      <value>0x15</value>
    </enumerator>
    <enumerator>
      <name>CHASSIS</name>
      <value>0x17</value>
    </enumerator>
    <enumerator>
      <name>MEMORY_DEVICE</name>
      <value>0x20</value>
    </enumerator>
    <enumerator>
      <name>SYS_MGMT_SOFTWARE</name>
      <value>0x21</value>
    </enumerator>
    <enumerator>
      <name>BIOS</name>
      <value>0x22</value>
    </enumerator>
    <enumerator>
      <name>OS</name>
      <value>0x23</value>
    </enumerator>
    <enumerator>
      <name>CORE</name>
      <value>0xD0</value>
    </enumerator>
    <enumerator>
      <name>MEMBUF</name>
      <value>0xD1</value>
    </enumerator>
    <enumerator>
      <name>OCC</name>
      <value>0xD2</value>
    </enumerator>
    <enumerator>
      <name>REF_CLOCK</name>
      <value>0xD4</value>
    </enumerator>
    <enumerator>
      <name>PCI_CLOCK</name>
      <value>0xD5</value>
    </enumerator>
    <enumerator>
      <name>TOD_CLOCK</name>
      <value>0xD6</value>
    </enumerator>
    <enumerator>
      <name>APSS</name>
      <value>0xD7</value>
    </enumerator>
    <enumerator>
      <name>GPU_CORE</name>
      <value>0xD8</value>
    </enumerator>
    <enumerator>
      <name>GPU_MEMORY</name>
      <value>0xD9</value>
    </enumerator>
    <id>ENTITY_ID</id>
  </enumerationType>

  <attribute>
    <description>Which execution platform the HW Procedure is running on Some HWPs (e.g. special wakeup) use different registers for different platforms to avoid arbitration problems when multiple platforms do the same thing concurrently</description>
    <id>EXECUTION_PLATFORM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_EXECUTION_PLATFORM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Which execution platform the HW Procedure is running on Some HWPs (e.g. special wakeup) use different registers for different platforms to avoid arbitration problems when multiple platforms do the same thing concurrently</description>
    <enumerator>
      <name>HOST</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>FSP</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>OCC</name>
      <value>0x03</value>
    </enumerator>
    <id>EXECUTION_PLATFORM</id>
  </enumerationType>

  <attribute>
    <description>Safe mode throttle value for numerator cfg_nm_n_per_port Set to below optimum value/ rate. On a per port basis Also used for emergency mode throttle MBA_FARB4Q_EMERGENCY_N Used to thermally protect the system in all supported environmental conditions when OCC is not functional</description>
    <id>EXP_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>32</default>
      </uint16_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_EXP_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Step size (binary in microvolts) to take upon external VRM voltage. This provide a limit of the external VRMs steps and is used as part of the overall voltage time calculation. The consuming code provides a default value of 50mv (5000uV) if this attribute is zero. Consumer: p10_pstate_parameter_build -&gt; p10_setup_evid Pstate Parameter (PSPB) for PGPE [index] -&gt;0: VDD; 1: VCS; 2: VDN; 3: VIO; Provided by the Machine Readable Workbook after system characterization.</description>
    <id>EXTERNAL_VRM_STEPSIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_EXTERNAL_VRM_STEPSIZE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Chip attribute. Logical fabric chip id for this chip (position within the fabric). Provided by the Machine Readable Workbook. Can vary across drawers.</description>
    <id>FABRIC_CHIP_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_CHIP_ID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Chip attribute. Logical fabric group the chip belongs to. Provided by the Machine Readable Workbook. Can vary across drawers.</description>
    <id>FABRIC_GROUP_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_GROUP_ID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define addressing this I2C slave device.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux will connect to. OxFF indicates no mux present or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address an I2C slave device</description>
    <id>FAPI_I2C_CONTROL_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>Common name across FAPI environments chip target -&gt; pu:k0:n0:s0:p00 DIMM target -&gt; dimm:k0:n0:s0:p00 chip unit target -&gt; pu.core:k0:n0:s0:p00:c0 cage/system target -&gt; k0 (chip type).(unit type):k(cage,always zero for us):n(node/drawer) :s(slot,always zero for us):p(chip position):c(core/unit position) pu = generic processor</description>
    <id>FAPI_NAME</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <default>unknown</default>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
  </attribute>

  <attribute>
    <description>Logical position of target within a system. This is derived from the SMP location of each processor and each target's relationship to a proc. - PROC = based on SMP groupid+chipid - MEMBUF = PROC:FAPI_POS * [max membuf per proc] - 1st level child unit = [parent chip]:FAPI_POS * [max children of this type per chip] - 2nd+ level child unit = [immediate parent unit]:FAPI_POS * [max units below parent] Note: This should not be used algorithmically by HWPs directly. Note: Value ignores physical drawer boundaries, the value is unique across the entire system. This data is derived from the MRW.</description>
    <id>FAPI_POS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0xFFFFFFFF</default>
      </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_FAPI_POS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <default>NA</default>
    <description>Enumeration defining special FAPI_POS values</description>
    <enumerator>
      <name>NA</name>
      <value>0xFFFFFFFF</value>
    </enumerator>
    <id>FAPI_POS</id>
  </enumerationType>

  <attribute>
    <description>This attribute represents the Maximum number of L2 Line Deletes allowed in the Field. creator: platform (generated based on MRW data)</description>
    <id>FIELD_TH_L2_LINE_DELETES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>6</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>This attribute represents the Maximum number of L3 Line Deletes allowed in the Field. creator: platform (generated based on MRW data)</description>
    <id>FIELD_TH_L3_LINE_DELETES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>6</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Core boot frequency at 1:1 from Nest DPLL</description>
    <id>FREQ_CORE_BOOT_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_CORE_BOOT_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>The nominal core frequency in MHz. This is the same for all cores in the system. Provided by the #V bucket of module VPD.</description>
    <id>FREQ_CORE_NOMINAL_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_CORE_NOMINAL_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>The frequency of the processor refclock in KHz. Provided by the Machine Readable Workbook. This can be overridden to adjust the refclock frequency.</description>
    <id>FREQ_CP_REFCLOCK_KHZ</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>100000</default>
      </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_CP_REFCLOCK_KHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>The frequency of the processor DPLL refclock in KHz. Provided by the Machine Readable Workbook. This can be overridden to adjust the refclock frequency.</description>
    <id>FREQ_DPLL_REFCLOCK_KHZ</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>133333</default>
      </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_DPLL_REFCLOCK_KHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>The frequency of a processor's IOHS link clock, in MHz. This can be set differently on a by-link basis.</description>
    <id>FREQ_IOHS_LINK_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>32500</default>
      </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_IOHS_LINK_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>The frequency of a processor's IOHS link clock, in MHz. This can be set differently on a by-link basis.</description>
    <enumerator>
      <name>25781</name>
      <value>25781</value>
    </enumerator>
    <enumerator>
      <name>31875</name>
      <value>31875</value>
    </enumerator>
    <enumerator>
      <name>32000</name>
      <value>32000</value>
    </enumerator>
    <enumerator>
      <name>32500</name>
      <value>32500</value>
    </enumerator>
    <enumerator>
      <name>33067</name>
      <value>33067</value>
    </enumerator>
    <enumerator>
      <name>33750</name>
      <value>33750</value>
    </enumerator>
    <id>FREQ_IOHS_LINK_MHZ</id>
  </enumerationType>

  <attribute>
    <description>The frequency of a processor's IOHS mesh clocks, in MHz. This can be set differently on a by-link basis.</description>
    <id>FREQ_IOHS_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_IOHS_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>The frequency of a processor's IOHS mesh clocks, in MHz. This can be set differently on a by-link basis.</description>
    <enumerator>
      <name>1611</name>
      <value>1611</value>
    </enumerator>
    <enumerator>
      <name>1992</name>
      <value>1992</value>
    </enumerator>
    <enumerator>
      <name>2000</name>
      <value>2000</value>
    </enumerator>
    <enumerator>
      <name>2031</name>
      <value>2031</value>
    </enumerator>
    <enumerator>
      <name>2067</name>
      <value>2067</value>
    </enumerator>
    <enumerator>
      <name>2109</name>
      <value>2109</value>
    </enumerator>
    <id>FREQ_IOHS_MHZ</id>
  </enumerationType>

  <attribute>
    <description>The frequency of the IO refclock in KHz. Provided by the Machine Readable Workbook. This can be overridden to adjust the refclock frequency.</description>
    <id>FREQ_IO_REFCLOCK_KHZ</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>100000</default>
      </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_IO_REFCLOCK_KHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>The frequency of the memory controller mesh clock, in MHz. This clock is asynchronous to the nest and drives the MCU queues, and all the associated logic that drives the inputs to the OMI. This can be set differently for each memory controller in the chip. This frequency is 1/16 of the OMI frequency.</description>
    <id>FREQ_MC_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_MC_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>The frequency of the memory controller mesh clock, in MHz. This clock is asynchronous to the nest and drives the MCU queues, and all the associated logic that drives the inputs to the OMI. This can be set differently for each memory controller in the chip. This frequency is 1/16 of the OMI frequency.</description>
    <enumerator>
      <name>1333</name>
      <value>1333</value>
    </enumerator>
    <enumerator>
      <name>1466</name>
      <value>1466</value>
    </enumerator>
    <enumerator>
      <name>1600</name>
      <value>1600</value>
    </enumerator>
    <enumerator>
      <name>2000</name>
      <value>2000</value>
    </enumerator>
    <id>FREQ_MC_MHZ</id>
  </enumerationType>

  <attribute>
    <description>The frequency of the OMI channel.</description>
    <id>FREQ_OMI_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_OMI_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>The frequency of the OMI channel.</description>
    <enumerator>
      <name>21330</name>
      <value>21330</value>
    </enumerator>
    <enumerator>
      <name>23460</name>
      <value>23460</value>
    </enumerator>
    <enumerator>
      <name>25600</name>
      <value>25600</value>
    </enumerator>
    <enumerator>
      <name>32000</name>
      <value>32000</value>
    </enumerator>
    <id>FREQ_OMI_MHZ</id>
  </enumerationType>

  <attribute>
    <description>The frequency of a processor's Obus mesh clocks, in MHz. Provided by the MRW.</description>
    <id>FREQ_O_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint32_t>
        <default>1611,1611,1611,1611</default>
      </uint32_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_O_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>The frequency of a processor's PAU mesh clocks, in MHz. Determines pau and ppe frequency for a given processor. Provided by the MRW.</description>
    <id>FREQ_PAU_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_PAU_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>The frequency of a processor's nest mesh clock, in MHz. This is the same for all chips in the system. Provided by the MRW.</description>
    <id>FREQ_PB_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_PB_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>The frequency of a processor's nest mesh clock, in MHz. This is the same for all chips in the system. Provided by the MRW.</description>
    <enumerator>
      <name>1600</name>
      <value>1600</value>
    </enumerator>
    <enumerator>
      <name>1866</name>
      <value>1866</value>
    </enumerator>
    <enumerator>
      <name>2000</name>
      <value>2000</value>
    </enumerator>
    <enumerator>
      <name>2133</name>
      <value>2133</value>
    </enumerator>
    <enumerator>
      <name>2400</name>
      <value>2400</value>
    </enumerator>
    <id>FREQ_PB_MHZ</id>
  </enumerationType>

  <attribute>
    <description>The frequency of a processor's PCIe bus in MHz. This is the same for all PCIe buses in the system. Provided by the MRW.</description>
    <id>FREQ_PCIE_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_PCIE_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>The frequency of a processor's PCIe bus in MHz. This is the same for all PCIe buses in the system. Provided by the MRW.</description>
    <enumerator>
      <name>2000</name>
      <value>2000</value>
    </enumerator>
    <id>FREQ_PCIE_MHZ</id>
  </enumerationType>

  <attribute>
    <description>System attribute. The frequency of the processor refclock in MHz. Provided by the MRW.</description>
    <id>FREQ_PROC_REFCLOCK</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>The frequency of a processor's Xbus mesh clocks, in MHz. This is the same for all chips in the system.</description>
    <id>FREQ_X_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>2000</default>
      </uint32_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_X_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>FRU ID attribute used to report FRU information to the BMC for each fru in the system.</description>
    <global/>
    <id>FRU_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>A comma-separated list of location codes to be called out when this target is implicated in an error. The format of each callout is "X:Y", where X is a letter 'H', 'M' or 'L' representing "high", "medium", and "low" respectively, and Y is a relative location code.</description>
    <id>FRU_PATH</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <default/>
        <sizeInclNull>128</sizeInclNull>
      </string>
    </simpleType>
  </attribute>

  <attribute>
    <description>See FRU_PATH for description.</description>
    <id>FSI_CALLOUTS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <default/>
        <sizeInclNull>128</sizeInclNull>
      </string>
    </simpleType>
  </attribute>

  <attribute>
    <complexType>
      <description>FSI flags</description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Set on FSI master chips (procs) if that chip uses slaveB to attach to the acting master chip.</description>
        <name>flipPort</name>
        <type>uint16_t</type>
      </field>
      <field>
        <bits>15</bits>
        <default>0</default>
        <description>Reserved for future expansion</description>
        <name>reserved</name>
        <type>uint16_t</type>
      </field>
    </complexType>
    <description>Reserved for any special flags we might need to access FSI</description>
    <id>FSI_OPTION_FLAGS</id>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>Size of FSP IO Region</description>
    <id>FSP_BAR_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>0x0000000100000000</default>
      </uint64_t>
    </simpleType>
  </attribute>

  <enumerationType>
    <description>1 if the target is functional, else 0. Set by the platform.</description>
    <enumerator>
      <name>NON_FUNCTIONAL</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>FUNCTIONAL</name>
      <value>0x1</value>
    </enumerator>
    <id>FUNCTIONAL</id>
  </enumerationType>

  <enumerationType>
    <description>Summarizes the fused status of cores. This is same for all p10 chips in the system. If a core is in a fused state, attribute should read 1 else zero. It needs to be populated during ipl but before istep 15.</description>
    <enumerator>
      <name>CORE_UNFUSED</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>CORE_FUSED</name>
      <value>0x1</value>
    </enumerator>
    <id>FUSED_CORE_MODE</id>
  </enumerationType>

  <attribute>
    <complexType>
      <description>Structure to define the addessing for an I2C slave device.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0</default>
        <description>Port from the I2C Master device. This is a 6-bit value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0</default>
        <description>Device address on the I2C bus. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0</default>
        <description>Logical GPIO pin number used to enabled/disable VDDR</description>
        <name>vddrPin</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux will connect to. OxFF indicates no mux present or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address GPIO device</description>
    <id>GPIO_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addessing for an I2C slave device.</description>
      <field>
        <default>physical:sys-0/node-0/proc-0</default>
        <description>Entity path to the chip that contains the I2C master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0</default>
        <description>Port from the I2C Master device. This is a 6-bit value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xC0</default>
        <description>Device address on the I2C bus. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>2</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0</default>
        <description>Logical GPIO pin number used to open or close the physcial presence window</description>
        <name>windowOpenPin</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>1</default>
        <description>Logical GPIO pin number used to determine if physical presence was asserted</description>
        <name>physicalPresencePin</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux will connect to. OxFF indicates no mux present or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address GPIO device that corresponds to the Physical Presence Detect circuit</description>
    <id>GPIO_INFO_PHYS_PRES</id>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <enumerationType>
    <description>Enumeration defining the offsets into the GPU_SENSORS array.</description>
    <enumerator>
      <name>FUNC_OFFSET</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>FUNC_ID_OFFSET</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>TEMP_OFFSET</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>TEMP_ID_OFFSET</name>
      <value>0x03</value>
    </enumerator>
    <enumerator>
      <name>MEM_TEMP_OFFSET</name>
      <value>0x04</value>
    </enumerator>
    <enumerator>
      <name>MEM_TEMP_ID_OFFSET</name>
      <value>0x05</value>
    </enumerator>
    <enumerator>
      <name>OBUS_CFG_OFFSET</name>
      <value>0x06</value>
    </enumerator>
    <id>GPU_SENSOR_ARRAY</id>
  </enumerationType>

  <attribute>
    <complexType>
      <description>Structure which defines a system's HB settings. Applicable for System target only.</description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Enable / Disable continuous trace. 0b0: Continuous trace is disabled. 0b1: Continuous trace is enabled.</description>
        <name>traceContinuous</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Override trace debug selection for SCAN component. 0b0: TRACS entries for SCAN have default behavior. 0b1: TRACS entries for SCAN are enabled.</description>
        <name>traceScanDebug</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Override trace debug selection for DBG component. 0b0: TRACS entries for DBG have default behavior. 0b1: TRACS entries for DBG are enabled.</description>
        <name>traceFapiDebug</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>5</bits>
        <default>0</default>
        <description>Reserved for future use</description>
        <name>reserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Attribute which describes how the SP has configured features in Hostboot.</description>
    <id>HB_SETTINGS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>This attribute holds the values of the I2C address from the i2c device connections as defined in the MRW. It is parsed into a struct in i2c.C</description>
    <id>HDAT_I2C_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>192</array>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>This attribute holds the values of the I2C bus frequency in Hz from the i2c device connections as defined in the MRW. It is parsed into a struct in i2c.C</description>
    <id>HDAT_I2C_BUS_FREQ</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>192</array>
      <uint32_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>This attribute holds the string descriptions of the I2C devices from the i2c device connections as defined in the MRW. It is parsed into a struct in i2c.C</description>
    <id>HDAT_I2C_DEVICE_LABEL</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>192</array>
      <string>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
  </attribute>

  <attribute>
    <description>This attribute holds the values of the I2C device purpose from the i2c device connections as defined in the MRW. It is parsed into a struct in i2c.C</description>
    <id>HDAT_I2C_DEVICE_PURPOSE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>192</array>
      <uint8_t/>
    </simpleType>
  </attribute>

  <enumerationType>
    <description>Pulled from the MRW, this describes the device purpose to the HDAT. This is for I2C devices only.</description>
    <enumerator>
      <name>CABLE_CARD_PRES</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>PCI_HOTPLUG_PGOOD</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>PCI_HOTPLUG_CONTROL</name>
      <value>0x3</value>
    </enumerator>
    <enumerator>
      <name>TPM</name>
      <value>0x4</value>
    </enumerator>
    <enumerator>
      <name>MODULE_VPD</name>
      <value>0x5</value>
    </enumerator>
    <enumerator>
      <name>DIMM_SPD</name>
      <value>0x6</value>
    </enumerator>
    <enumerator>
      <name>PROC_MODULE_VPD</name>
      <value>0x7</value>
    </enumerator>
    <enumerator>
      <name>SBE_SEEPROM</name>
      <value>0x8</value>
    </enumerator>
    <enumerator>
      <name>PLANAR_VPD</name>
      <value>0x9</value>
    </enumerator>
    <enumerator>
      <name>NVLINK_CABLE_TOPOLOGY_VERIFICATION</name>
      <value>0xA</value>
    </enumerator>
    <enumerator>
      <name>NVLINK</name>
      <value>0xB</value>
    </enumerator>
    <enumerator>
      <name>NVLINK_CABLE_MICRO_RESET</name>
      <value>0xB</value>
    </enumerator>
    <enumerator>
      <name>I2C_ASSOC_WITH_NVLINK_CABLE</name>
      <value>0xC</value>
    </enumerator>
    <enumerator>
      <name>WINDOW_OPEN</name>
      <value>0xD</value>
    </enumerator>
    <enumerator>
      <name>PHYSICAL_PRESENCE</name>
      <value>0xE</value>
    </enumerator>
    <enumerator>
      <name>MEX_FPGA</name>
      <value>0xF</value>
    </enumerator>
    <enumerator>
      <name>UNKNOWN</name>
      <value>0xFF</value>
    </enumerator>
    <id>HDAT_I2C_DEVICE_PURPOSE</id>
  </enumerationType>

  <attribute>
    <description>This attribute holds the values of the I2C device type from the i2c device connections as defined in the MRW. It is parsed into a struct in i2c.C</description>
    <id>HDAT_I2C_DEVICE_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>192</array>
      <uint8_t/>
    </simpleType>
  </attribute>

  <enumerationType>
    <description>Pulled from the MRW, this describes the device type to the HDAT. This is for I2C devices only.</description>
    <enumerator>
      <name>9551</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>955X</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel28c128</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>NUVOTON_TPM</name>
      <value>0x3</value>
    </enumerator>
    <enumerator>
      <name>MEX_FPGA</name>
      <value>0x4</value>
    </enumerator>
    <enumerator>
      <name>UCX90XX</name>
      <value>0x5</value>
    </enumerator>
    <enumerator>
      <name>NVLINK</name>
      <value>0x6</value>
    </enumerator>
    <enumerator>
      <name>9552</name>
      <value>0x6</value>
    </enumerator>
    <enumerator>
      <name>9553</name>
      <value>0x7</value>
    </enumerator>
    <enumerator>
      <name>9554</name>
      <value>0x8</value>
    </enumerator>
    <enumerator>
      <name>9555</name>
      <value>0x9</value>
    </enumerator>
    <enumerator>
      <name>SMP_or_OpenCAPI_Cable</name>
      <value>0xA</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel28c256</name>
      <value>0xB</value>
    </enumerator>
    <enumerator>
      <name>THERMAL_SENSOR</name>
      <value>0x0C</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel24c04</name>
      <value>0x0D</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel24c412</name>
      <value>0x0E</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel24c32</name>
      <value>0x0F</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel24c64</name>
      <value>0x10</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel24c16</name>
      <value>0x11</value>
    </enumerator>
    <enumerator>
      <name>NVDIA_GPU</name>
      <value>0x12</value>
    </enumerator>
    <enumerator>
      <name>NXP_LPC_Microcontroller_LPC11U35</name>
      <value>0x13</value>
    </enumerator>
    <enumerator>
      <name>9550</name>
      <value>0x14</value>
    </enumerator>
    <enumerator>
      <name>TCG_I2C_TPM</name>
      <value>0x15</value>
    </enumerator>
    <enumerator>
      <name>UNKNOWN</name>
      <value>0xFF</value>
    </enumerator>
    <id>HDAT_I2C_DEVICE_TYPE</id>
  </enumerationType>

  <attribute>
    <description>This attribute holds the number of elements that were found under this particular target, and how many devices are stored in the arrays.</description>
    <id>HDAT_I2C_ELEMENTS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>This attribute holds the values of the I2C Engine from the i2c device connections as defined in the MRW. It is parsed into a struct in i2c.C</description>
    <id>HDAT_I2C_ENGINE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>192</array>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>This attribute holds the values of the I2C Master Port from the i2c device connections as defined in the MRW. It is parsed into a struct in i2c.C</description>
    <id>HDAT_I2C_MASTER_PORT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>192</array>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>This attribute holds the values of the I2C slave port from the i2c device connections as defined in the MRW. It is parsed into a struct in i2c.C</description>
    <id>HDAT_I2C_SLAVE_PORT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>192</array>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>Defines offset to be applied to HB bootloader installation this will be added with the bootloader offset and the base address to get the target base addres</description>
    <id>HOSTBOOT_HRMOR_OFFSET</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_HOSTBOOT_HRMOR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Hot Plug Controller values for a specific processor. Purpose: Holds information about the hot plug controllers so that a Hardware procedure is able to turn them on and off. Data Format: up to 8 Hot Plug Controllers x 7 variables of information This data is at the processor level. The needed information and their individual sizes are as follows: (1) I2C Master processor engine (uint8_t) (2) I2C Master processor port (uint8_t) (3) Bus Speed (uint16_t value: 2 uint8_t values: MSB, LSB) (4) Slave address (uint8_t) (5) Device type (uint8_t: see SUPPORTED_HOT_PLUG enum) (6) I2C Master processor node (uint8_t) (7) I2C Master processor position (uint8_t) Thus, the information will be 8 bytes.</description>
    <id>HOT_PLUG_POWER_CONTROLLER_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>8,8</array>
      <uint8_t>
        <default>0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Select workaround type to be applied if HW543384 is present</description>
    <id>HW543384_WAR_MODE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_HW543384_WAR_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Select workaround type to be applied if HW543384 is present</description>
    <enumerator>
      <name>NONE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TIE_NEST_TO_PAU</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>FBC_FLOW_CONTROL</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>BOTH</name>
      <value>3</value>
    </enumerator>
    <id>HW543384_WAR_MODE</id>
  </enumerationType>

  <attribute>
    <description>Select workaround type to be applied if HW543822 is present</description>
    <id>HW543822_WAR_MODE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>NONE</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_HW543822_WAR_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Select workaround type to be applied if HW543822 is present</description>
    <enumerator>
      <name>FORCE_HUNDRED_OHM_DIFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>FORCE_NO_TERM</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>FORCE_FIFTY_OHM_SE</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>NONE</name>
      <value>3</value>
    </enumerator>
    <id>HW543822_WAR_MODE</id>
  </enumerationType>

  <enumerationType>
    <description>Enumeration indicating the services that are concerned with target changes (ie, via HCDB change). The values can be combined using a bitwise 'OR'.</description>
    <enumerator>
      <name>GARD</name>
      <value>0x00000001</value>
    </enumerator>
    <enumerator>
      <name>MEMDIAG</name>
      <value>0x00000002</value>
    </enumerator>
    <enumerator>
      <name>PSIDIAG</name>
      <value>0x00000004</value>
    </enumerator>
    <enumerator>
      <name>DIAG_MASK</name>
      <value>0x00000006</value>
    </enumerator>
    <enumerator>
      <name>HOSTSVC_HBEL</name>
      <value>0x00000008</value>
    </enumerator>
    <enumerator>
      <name>RESRC_RECOV</name>
      <value>0x00000010</value>
    </enumerator>
    <enumerator>
      <name>GARD_APPLIED</name>
      <value>0x00000020</value>
    </enumerator>
    <enumerator>
      <name>DEVTREE_SYNC</name>
      <value>0x00000040</value>
    </enumerator>
    <id>HWAS_CHANGED_BIT</id>
  </enumerationType>

  <attribute>
    <description>Attribute indicating the target's hw version</description>
    <hasStringConversion/>
    <id>HW_VER</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>HW_VER</id>
      </enumeration>
    </simpleType>
  </attribute>

  <enumerationType>
    <default>BMC_HW_VER</default>
    <description>Enumeration indicating the chip HW version</description>
    <enumerator>
      <name>FSP_HW_VER</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>BMC_HW_VER</name>
      <value>0x3</value>
    </enumerator>
    <id>HW_VER</id>
  </enumerationType>

  <attribute>
    <description>Designates the speed at which a given I2C bus should run. Creator: MRW Purpose: Used by FW to know the fastest possible bus speed that all of the devices on a given bus are able to use. Data Format: 4x16 array of uint16_t values. The first index indicates the engine number of the bus. The second index indicates the port number of the bus. The value in the array is the I2C bus speed used for that engine/port combination in KHz.</description>
    <id>I2C_BUS_SPEED_ARRAY</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4,16</array>
      <uint16_t>
        <default>0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>See FRU_PATH for a description.</description>
    <id>I2C_CALLOUTS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <default/>
        <sizeInclNull>128</sizeInclNull>
      </string>
    </simpleType>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define addressing this I2C slave device.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the I2C mux for this device must enable to connect this device to its I2C master, if applicable. 0xFF indicates no I2C mux present or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path of the I2C mux for this device, if any.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address an I2C slave device</description>
    <id>I2C_CONTROL_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>Device type of I2C slave device</description>
    <id>I2C_DEV_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_I2C_DEV_TYPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Device type of I2C slave device</description>
    <enumerator>
      <name>ADS7138_ADC</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>PCA9554A_GPIO_EXPANDER</name>
      <value>1</value>
    </enumerator>
    <id>I2C_DEV_TYPE</id>
  </enumerationType>

  <attribute>
    <description>Represents the ordinal position of this target compared to other peer GENERICI2CSLAVE targets with the same ATTR_I2C_DEV_TYPE</description>
    <id>I2C_SUB_POS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_I2C_SUB_POS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>MCS Inband Scom base address</description>
    <id>IBSCOM_MCS_BASE_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>0x0003E00000000000</default>
      </uint64_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MCS_INBAND_BASE_ADDRESS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>PROC Inband Scom base address</description>
    <id>IBSCOM_PROC_BASE_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>0x0003E00000000000</default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Per-link optics configuration OPT0 = SMPA/SMPX/OCAPI OPT1 = SMPA/SMPX OPT2 = SMPA/SMPX OPT3 = SMPA/SMPX/OCAPI OPT4 = SMPA/SMPX/OCAPI OPT5 = SMPA/SMPX/OCAPI OPT6 = SMPA/SMPX/OCAPI OPT7 = SMPA/SMPX/OCAPI Provided by the MRW.</description>
    <global/>
    <id>IOHS_CONFIG_MODE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_IOHS_CONFIG_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Per-link optics configuration OPT0 = SMPA/SMPX/OCAPI OPT1 = SMPA/SMPX OPT2 = SMPA/SMPX OPT3 = SMPA/SMPX/OCAPI OPT4 = SMPA/SMPX/OCAPI OPT5 = SMPA/SMPX/OCAPI OPT6 = SMPA/SMPX/OCAPI OPT7 = SMPA/SMPX/OCAPI Provided by the MRW.</description>
    <enumerator>
      <name>SMPX</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>SMPA</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>OCAPI</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>UNUSED</name>
      <value>0x3</value>
    </enumerator>
    <id>IOHS_CONFIG_MODE</id>
  </enumerationType>

  <attribute>
    <description>Indicates if the link is used to connect between drawers. Should be considered valid only if ATTR_IOHS_CONFIG_MODE for the given link is configured as an SMPX or SMPA. Provided by the MRW.</description>
    <global/>
    <id>IOHS_DRAWER_INTERCONNECT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_IOHS_DRAWER_INTERCONNECT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Indicates if the link is used to connect between drawers. Should be considered valid only if ATTR_IOHS_CONFIG_MODE for the given link is configured as an SMPX or SMPA. Provided by the MRW.</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x1</value>
    </enumerator>
    <id>IOHS_DRAWER_INTERCONNECT</id>
  </enumerationType>

  <attribute>
    <description>Specify the lane reversal for an IOHS target. bit 0: overall tx lane reversal (18 tx lane reversal) For link pairs only, not for 50G bit 1: link 0 rx lane reversal (9 rx lanes) bit 2: link 0 tx lane reversal (9 tx lanes) bit 3: link 1 rx lane reversal (9 rx lanes) bit 4: link 1 tx lane reversal (9 tx lanes)</description>
    <global/>
    <id>IOHS_FABRIC_LANE_REVERSAL</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_IOHS_FABRIC_LANE_REVERSAL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Indicates whether sublinks are statically intended to be split to service endpoints on distinctly different remote chips</description>
    <id>IOHS_LINK_SPLIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_IOHS_LINK_SPLIT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Indicates whether sublinks are statically intended to be split to service endpoints on distinctly different remote chips</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x1</value>
    </enumerator>
    <id>IOHS_LINK_SPLIT</id>
  </enumerationType>

  <attribute>
    <description>Specifies time to reset bad lane counter for the iohs links</description>
    <id>IOHS_MNFG_BAD_LANE_DURATION</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>15</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_IOHS_MNFG_BAD_LANE_DURATION</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Specifies the number of errors (0 through 127) before marking a lane as bad for the iohs links</description>
    <id>IOHS_MNFG_BAD_LANE_MAX</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>46</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_IOHS_MNFG_BAD_LANE_MAX</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Specifies if spread spectrum is enabled for the iohs links</description>
    <id>IOHS_SPREAD_SPECTRUM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>DISABLED</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_IOHS_SPREAD_SPECTRUM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Specifies if spread spectrum is enabled for the iohs links</description>
    <enumerator>
      <name>ENABLED</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>DISABLED</name>
      <value>0x00</value>
    </enumerator>
    <id>IOHS_SPREAD_SPECTRUM</id>
  </enumerationType>

  <attribute>
    <description>Specifies the channel loss</description>
    <global/>
    <id>IO_IOHS_CHANNEL_LOSS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>HIGH_LOSS</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_IOHS_CHANNEL_LOSS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Specifies the channel loss</description>
    <enumerator>
      <name>HIGH_LOSS</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>MID_LOSS</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>LOW_LOSS</name>
      <value>0x02</value>
    </enumerator>
    <id>IO_IOHS_CHANNEL_LOSS</id>
  </enumerationType>

  <attribute>
    <description>IOHS PRE1 settings</description>
    <id>IO_IOHS_PRE1</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_IOHS_PRE1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>IOHS PRE2 settings</description>
    <id>IO_IOHS_PRE2</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_IOHS_PRE2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Unique Mode to help with high xtalk - SW547515</description>
    <id>IO_IOHS_XTALK</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>NO_XTALK</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_IOHS_XTALK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Unique Mode to help with high xtalk - SW547515</description>
    <enumerator>
      <name>NO_XTALK</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>HI_XTALK</name>
      <value>0x01</value>
    </enumerator>
    <id>IO_IOHS_XTALK</id>
  </enumerationType>

  <attribute>
    <description>Value to select amount of tx ffe postcusor to apply.</description>
    <id>IO_OBUS_TX_FFE_POSTCURSOR</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_OBUS_TX_FFE_POSTCURSOR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Value to select amount of tx ffe precusor to apply.</description>
    <id>IO_OBUS_TX_FFE_PRECURSOR</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_OBUS_TX_FFE_PRECURSOR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Value to select amount of margin to be applied.</description>
    <id>IO_OBUS_TX_MARGIN_RATIO</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_OBUS_TX_MARGIN_RATIO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Specifies the channel loss</description>
    <id>IO_OMI_CHANNEL_LOSS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>HIGH_LOSS</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_OMI_CHANNEL_LOSS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Specifies the channel loss</description>
    <enumerator>
      <name>HIGH_LOSS</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>MID_LOSS</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>LOW_LOSS</name>
      <value>0x02</value>
    </enumerator>
    <id>IO_OMI_CHANNEL_LOSS</id>
  </enumerationType>

  <attribute>
    <description>OMI PRE1 settings</description>
    <id>IO_OMI_PRE1</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_OMI_PRE1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>OMI PRE2 settings</description>
    <id>IO_OMI_PRE2</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_OMI_PRE2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Indicates if the Obus channel is a board or a cable</description>
    <id>IO_O_CHANNEL_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_O_CHANNEL_TYPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Indicates if the Obus channel is a board or a cable</description>
    <enumerator>
      <name>BOARD</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>CABLE</name>
      <value>0x1</value>
    </enumerator>
    <id>IO_O_CHANNEL_TYPE</id>
  </enumerationType>

  <attribute>
    <description>Indicate if manufcaturing tests should be taken pre / post linktraining.</description>
    <id>IO_O_MFG_CHK</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_O_MFG_CHK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Indicate if manufcaturing tests should be taken pre / post linktraining.</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x1</value>
    </enumerator>
    <id>IO_O_MFG_CHK</id>
  </enumerationType>

  <attribute>
    <description>Minimum eye width to allow passing through manufacturing.</description>
    <id>IO_O_MFG_MIN_EYE_WIDTH</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_O_MFG_MIN_EYE_WIDTH</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>This attribute provides an a way to stress the SMP Abus Even Lanes in Manufacturing. By applying a phase rotator offset we can further stress the phy. This is a 6-bit 2's complement value that would be right justified in the 8 bit UINT attribute value.</description>
    <id>IO_O_MFG_STRESS_PR_OFFSET_EVEN</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_O_MFG_STRESS_PR_OFFSET_EVEN</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>i This attribute provides an a way to stress the SMP Abus Odd Lanes in Manufacturing. By applying a phase rotator offset we can further stress the phy. This is a 6-bit 2's complement value that would be right justified in the 8 bit UINT attribute value.</description>
    <id>IO_O_MFG_STRESS_PR_OFFSET_ODD</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_O_MFG_STRESS_PR_OFFSET_ODD</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Skip locking sequence and check for lock of IO PLLs</description>
    <id>IO_TANK_PLL_BYPASS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_TANK_PLL_BYPASS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Skip locking sequence and check for lock of IO PLLs</description>
    <enumerator>
      <name>BYPASS</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>NO_BYPASS</name>
      <value>0x0</value>
    </enumerator>
    <id>IO_TANK_PLL_BYPASS</id>
  </enumerationType>

  <attribute>
    <description>Alternate settings for short Xbus channels bit 0 -- Disable RX LTE bit 1 -- Disable AC BOOST bit 2 -- Low Gain/Peaking Init Settings bit 3 -- Lower VGA Gain Target -10%</description>
    <id>IO_XBUS_CHAN_EQ</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_XBUS_CHAN_EQ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Alternate settings for short Xbus channels bit 0 -- Disable RX LTE bit 1 -- Disable AC BOOST bit 2 -- Low Gain/Peaking Init Settings bit 3 -- Lower VGA Gain Target -10%</description>
    <enumerator>
      <name>DIS_RX_LTE</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>DIS_TX_AC_BOOST</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>LOWER_GAIN_PEAK_INITS</name>
      <value>0x04</value>
    </enumerator>
    <enumerator>
      <name>LOWER_VGA_GAIN_TARGET</name>
      <value>0x08</value>
    </enumerator>
    <id>IO_XBUS_CHAN_EQ</id>
  </enumerationType>

  <attribute>
    <description>Indicate if manufacturing tests should be taken pre / post linktraining.</description>
    <id>IO_X_MFG_CHK</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_X_MFG_CHK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Indicate if manufacturing tests should be taken pre / post linktraining.</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x1</value>
    </enumerator>
    <id>IO_X_MFG_CHK</id>
  </enumerationType>

  <attribute>
    <description>Minimum eye width to allow passing through manufacturing.</description>
    <id>IO_X_MFG_MIN_EYE_WIDTH</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_X_MFG_MIN_EYE_WIDTH</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Holds the IPMI instance number for this entity.</description>
    <id>IPMI_INSTANCE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>Attribute to hold 16 pairs of sensor name, sensor number pairs. A sensor name consists of one byte of general sensor type and one byte of sub-type</description>
    <id>IPMI_SENSORS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>16,2</array>
      <uint16_t/>
    </simpleType>
  </attribute>

  <enumerationType>
    <description>Enumeration defining the offsets into the IPMI_SENSORS array.</description>
    <enumerator>
      <name>NAME_OFFSET</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>NUMBER_OFFSET</name>
      <value>0x01</value>
    </enumerator>
    <id>IPMI_SENSOR_ARRAY</id>
  </enumerationType>

  <attribute>
    <description>Indicates if Idle Power Save is enabled. This is independent of the OPEN_POWER_PM_MODE (DPS and IPS can be enabled at the same time). Valid Values: 0 = Disabled (default), 1 = Enabled. See IPS_ENTER / IPS_EXIT attributes for IPS configuration.</description>
    <id>IPS_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>When IPS is enabled, this defines the delay time in seconds (between 10 and 600) to enter Idle Power Save.</description>
    <id>IPS_ENTER_TIME_SECONDS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>240</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>When IPS is enabled, this defines the utilization threshold as a percent (between 0 and 100) to enter Idle Power Save. This value should be less than IPS_EXIT_UTILIZATION_PERCENT.</description>
    <id>IPS_ENTER_UTILIZATION_PERCENT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>8</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>When IPS is enabled, this defines the delay time in seconds (between 10 and 600) to exit Idle Power Save.</description>
    <id>IPS_EXIT_TIME_SECONDS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>10</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>When IPS is enabled, this defines the utilization threshold as a percent (between 0 and 100) to exit Idle Power Save. This value should be greater than IPS_ENTER_UTILIZATION_PERCENT.</description>
    <id>IPS_EXIT_UTILIZATION_PERCENT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>12</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <enumerationType>
    <description>Indicates if current IPL is memory-preserving</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x1</value>
    </enumerator>
    <id>IS_MPIPL</id>
  </enumerationType>

  <attribute>
    <description>Specifies if the mpipl is supported on this platform 0 : No , 1 : Yes</description>
    <id>IS_MPIPL_SUPPORTED</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <enumerationType>
    <description>Returns the type of simics environment that the code is executing inside. 0 = RealHW/AWAN. 1 = Simics. 2 = SUET.</description>
    <enumerator>
      <name>REALHW</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>SIMICS</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>SUET</name>
      <value>0x02</value>
    </enumerator>
    <id>IS_SIMICS</id>
  </enumerationType>

  <attribute>
    <description>env: 1 = Awan/HWSimulator. 0 = Simics/RealHW.</description>
    <id>IS_SIMULATION</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_IS_SIMULATION</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Weight factor (1 = 0.1) for each L3 DTS to calculate a core temperature. A value of 0 means not to include L3 DTS in core temperature.</description>
    <id>L3_WEIGHT_TENTHS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Indicates the bitrate for the link.</description>
    <id>LINK_SPEED</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>25G</default>
      </uint16_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_LINK_SPEED</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Indicates the bitrate for the link.</description>
    <enumerator>
      <name>25G</name>
      <value>25</value>
    </enumerator>
    <enumerator>
      <name>32G</name>
      <value>32</value>
    </enumerator>
    <enumerator>
      <name>50G</name>
      <value>50</value>
    </enumerator>
    <id>LINK_SPEED</id>
  </enumerationType>

  <attribute>
    <description>Location code of the Fru target</description>
    <id>LOCATION_CODE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
  </attribute>

  <attribute>
    <description>Indicates if LPC console is enabled on system</description>
    <id>LPC_CONSOLE_CNFG</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>ENABLE</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_LPC_CONSOLE_CNFG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Indicates if LPC console is enabled on system</description>
    <enumerator>
      <name>ENABLE</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>DISABLE</name>
      <value>0x0</value>
    </enumerator>
    <id>LPC_CONSOLE_CNFG</id>
  </enumerationType>

  <attribute>
    <description>Defines if the lpc console is initialized for Hostboot to use</description>
    <id>LPC_CONSOLE_INITIALIZED</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_LPC_CONSOLE_INITIALIZED</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Maximum frequency (in MHz) that this system can run the DIMMs at. There are 5 possible values determined by the dimm configuration. For configurations which have mixed rank configurations, the lowest frequency based on ranks of either DIMM is chosen. For example if there was a 1R and a 2R DIMM installed, and 1R dual drop was a lower max freq than 2R dual drop, then the 1R max freq would be the max allowed. [0]=One rank, single drop [1]=Two rank, single drop [2]=Four rank, single drop [3]=One rank, dual drop [4]=Two rank, dual drop A value of zero would indicate an unsupported configuration. Note: Do not use this attribute to limit configurations, it is not checked during plug rules. If you have an unsupported configuration, use the value 0 as the maximum freq.</description>
    <id>MAX_ALLOWED_DIMM_FREQ</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>5</array>
      <uint32_t>
        <default>2400,2400,2400,2400,2400</default>
      </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MAX_ALLOWED_DIMM_FREQ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>System attribute. The max DIMMs per MBA Port available in the system.</description>
    <id>MAX_DIMMS_PER_MBA_PORT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>System attribute. The max DMI units per proc available in the system.</description>
    <id>MAX_DMI_PER_PROC</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>8</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>System attribute. The max EX units per proc chip available in the system.</description>
    <id>MAX_EXS_PER_PROC_CHIP</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>System attribute. The max MBAS per membuf available in the system.</description>
    <id>MAX_MBAS_PER_MEMBUF_CHIP</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>System attribute. The max MBA ports per MBA available in the system.</description>
    <id>MAX_MBA_PORTS_PER_MBA</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>Maximum theoretical Vdd current reading in 10mA units. Used when VDD_CURRENT_OVERFLOW_WORKAROUND_ENABLE is set.</description>
    <id>MAX_VDD_CURRENT_READING</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0x0000</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>MBA port DIMM number of this DIMM (deprecated in favor of POS_ON_MEM_PORT)</description>
    <id>MBA_DIMM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>MBA port this DIMM is connected to (deprecated in favor of MEM_PORT)</description>
    <id>MBA_PORT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>External MC and DRAM temperature where an error will be generated in degrees C</description>
    <id>MC_DRAM_ERROR_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>99</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Maximum time in seconds allowed without having a new temperature for the sensor covering both external MC and DRAM before memory throttling will occur</description>
    <id>MC_DRAM_READ_TIMEOUT_SEC</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>30</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>External MC and DRAM temperature threshold where throttling will occur in degrees C</description>
    <id>MC_DRAM_THROTTLE_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>89</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>External MC temperature where an error will be generated in degrees C</description>
    <id>MC_EXT_ERROR_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>99</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Maximum time in seconds allowed without having a new external MC temperature before memory throttling will occur</description>
    <id>MC_EXT_READ_TIMEOUT_SEC</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>30</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>External MC temperature threshold where throttling will occur in degrees C</description>
    <id>MC_EXT_THROTTLE_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>89</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Memory controller temperature where an error will occur in degrees C</description>
    <id>MEMCTRL_ERROR_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>99</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Maximum time in seconds allowed without having a new MC temperature before memory throttling will occur</description>
    <id>MEMCTRL_READ_TIMEOUT_SEC</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>30</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Memory controller temperature threshold where throttling will occur in degrees C</description>
    <id>MEMCTRL_THROTTLE_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>89</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Indicates if the DIMM connected to this controller are in a planar configuration</description>
    <id>MEM_MRW_IS_PLANAR</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>FALSE</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_MRW_IS_PLANAR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Indicates if the DIMM connected to this controller are in a planar configuration</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x01</value>
    </enumerator>
    <id>MEM_MRW_IS_PLANAR</id>
  </enumerationType>

  <attribute>
    <description>Memory port this DIMM is connected to</description>
    <id>MEM_PORT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>The lowest utilization allowed that the OCC could throttle memory due to a memory over temp condition. (percent from 0-100)</description>
    <id>MIN_MEM_UTILIZATION_THROTTLING</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>25</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Lowest output power in watts that a user may set, and the OCC can guarantee to hold via processor DVFS under all conditions. Aka Hard minimum power cap.</description>
    <id>MIN_POWER_CAP_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>2700</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Power used by components other than CPU, memory, or GPUs in Watts</description>
    <id>MISC_SYSTEM_COMPONENTS_MAX_POWER_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>System attribute 8 bit rx_min_eye_height value for A bus interfaces during system manufacturing creator: platform firmware notes: Attribute value is in the Machine Readable Workbook</description>
    <id>MNFG_ABUS_MIN_EYE_HEIGHT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>System attribute 6 bit rx_min_eye_width value for A bus interfaces during system manufacturing creator: platform firmware notes: Attribute value is in the Machine Readable Workbook</description>
    <id>MNFG_ABUS_MIN_EYE_WIDTH</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>System attribute. 8 bit rx_min_eye_height value for DMI bus interfaces during system manufacturing; used for both centaur and p8 creator: platform firmware notes: Attribute value is in the Machine Readable Workbook</description>
    <id>MNFG_DMI_MIN_EYE_HEIGHT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>System attribute. 6 bit rx_min_eye_width value for DMI bus interfaces during system manufacturing; used for both centaur and p8 creator: platform firmware notes: Attribute value is in the Machine Readable Workbook</description>
    <id>MNFG_DMI_MIN_EYE_WIDTH</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>NOTE: This is being deprecated and being replaced by the attribute ATTR_MFG_FLAGS, found above. Please switch over to the new attribute, ATTR_MFG_FLAGS, ASAP. @TODO: RTC 252027: Remove this attribute when possible The manufacturing flags. This is a bitfield. Each bit is a flag and multiple flags can be set</description>
    <id>MNFG_FLAGS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>0x0000000000000000</default>
      </uint64_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MNFG_FLAGS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>NOTE: This is being deprecated and being replaced by the attribute ATTR_MFG_FLAGS, found above. Please switch over to the new attribute, ATTR_MFG_FLAGS, ASAP. @TODO: RTC 252027: Remove this attribute when possible The manufacturing flags. This is a bitfield. Each bit is a flag and multiple flags can be set</description>
    <enumerator>
      <name>MNFG_NO_FLAG</name>
      <value>0x0000000000000000</value>
    </enumerator>
    <enumerator>
      <name>MNFG_THRESHOLDS</name>
      <value>0x0000000000000001</value>
    </enumerator>
    <enumerator>
      <name>MNFG_TEST_ALL_SPARE_DRAM_ROWS</name>
      <value>0x0000000000000040</value>
    </enumerator>
    <enumerator>
      <name>MNFG_DISABLE_DRAM_REPAIRS</name>
      <value>0x0000000000000080</value>
    </enumerator>
    <enumerator>
      <name>MNFG_ENABLE_STANDARD_PATTERN_TEST</name>
      <value>0x0000000000000200</value>
    </enumerator>
    <enumerator>
      <name>MNFG_DISABLE_FABRIC_eREPAIR</name>
      <value>0x0000000000000800</value>
    </enumerator>
    <enumerator>
      <name>MNFG_DISABLE_MEMORY_eREPAIR</name>
      <value>0x0000000000001000</value>
    </enumerator>
    <enumerator>
      <name>MNFG_FABRIC_DEPLOY_LANE_SPARES</name>
      <value>0x0000000000002000</value>
    </enumerator>
    <enumerator>
      <name>MNFG_DMI_DEPLOY_LANE_SPARES</name>
      <value>0x0000000000004000</value>
    </enumerator>
    <id>MNFG_FLAGS</id>
  </enumerationType>

  <attribute>
    <description>This attribute represents the Maximum number of L2 Cache CEs allowed during Manufacturing. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_L2_CACHE_CES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>This attribute represents the Maximum number of L2 Directory CEs allowed during Manufacturing. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_L2_DIR_CES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>This attribute represents the Maximum number of L2 Line Deletes allowed during Manufacturing. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_L2_LINE_DELETES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>This attribute represents the Maximum number of L3 Cache CEs allowed during Manufacturing. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_L3_CACHE_CES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>3</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>This attribute represents the Maximum number of L3 Directory CEs allowed during Manufacturing. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_L3_DIR_CES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>This attribute represents the Maximum number of L3 Line Deletes allowed during Manufacturing. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_L3_LINE_DELETES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>With MNFG thresholds enabled, PRD will make a predictive callout when a memory intermittent MPE attention count is equal to this value. A value of 0 defaults to the max threshold of 0xff.</description>
    <id>MNFG_TH_MEMORY_IMPES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>This attribute represents the Base threshold (for 2GB DRAM ) of Memory CEs allowed during IPL. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_MEMORY_IPL_SOFT_CE_TH_ALGO</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>With MNFG thresholds enabled, PRD will make a predictive callout when a memory intermittent UE attention count is equal to this value. A value of 0 defaults to the max threshold of 0xff.</description>
    <id>MNFG_TH_MEMORY_IUES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>With MNFG thresholds enabled, PRD will make a predictive callout when an RCD parity error (recovery enabled) attention count is equal to this value. A value of 0 defaults to the max threshold of 0xff.</description>
    <id>MNFG_TH_MEMORY_RCD_PARITY_ERRORS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>This attribute represents the maximum number of Memory RCEs allowed per Rank during runtime. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_MEMORY_RT_RCE_PER_RANK</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>This attribute represents the Base threshold (for 2GB DRAM ) of Memory CEs allowed during runtime. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_MEMORY_RT_SOFT_CE_TH_ALGO</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>System attribute 6 bit rx_min_eye_width value for X bus interfaces during system manufacturing creator: platform firmware notes: Attribute value is in the Machine Readable Workbook</description>
    <id>MNFG_XBUS_MIN_EYE_WIDTH</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>Attribute indicating the target's model</description>
    <hasStringConversion/>
    <id>MODEL</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>MODEL</id>
      </enumeration>
    </simpleType>
  </attribute>

  <enumerationType>
    <default>NA</default>
    <description>Enumeration indicating the target's model</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>RESERVED</name>
      <value>16</value>
    </enumerator>
    <enumerator>
      <name>VENICE</name>
    </enumerator>
    <enumerator>
      <name>MURANO</name>
    </enumerator>
    <enumerator>
      <name>NAPLES</name>
    </enumerator>
    <enumerator>
      <name>NIMBUS</name>
    </enumerator>
    <enumerator>
      <name>CUMULUS</name>
    </enumerator>
    <enumerator>
      <name>AXONE</name>
    </enumerator>
    <enumerator>
      <name>CENTAUR</name>
      <value>48</value>
    </enumerator>
    <enumerator>
      <name>OCMB</name>
    </enumerator>
    <enumerator>
      <name>JEDEC</name>
      <value>80</value>
    </enumerator>
    <enumerator>
      <name>CDIMM</name>
    </enumerator>
    <enumerator>
      <name>POWER8</name>
      <value>112</value>
    </enumerator>
    <enumerator>
      <name>POWER9</name>
      <value>144</value>
    </enumerator>
    <enumerator>
      <name>POWER10</name>
      <value>145</value>
    </enumerator>
    <enumerator>
      <name>CECTPM</name>
    </enumerator>
    <enumerator>
      <name>BMC</name>
    </enumerator>
    <enumerator>
      <name>AST2500</name>
    </enumerator>
    <enumerator>
      <name>AST2600</name>
    </enumerator>
    <enumerator>
      <name>PCA9847</name>
    </enumerator>
    <enumerator>
      <name>UCD9090</name>
    </enumerator>
    <enumerator>
      <name>UCD90120A</name>
    </enumerator>
    <enumerator>
      <name>UCD90320</name>
    </enumerator>
    <id>MODEL</id>
  </enumerationType>

  <attribute>
    <description>Convert dcbz operations into read within to modify transactions in L2</description>
    <id>MRW_CONVERT_DCBZ_TO_RWITM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MRW_CONVERT_DCBZ_TO_RWITM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Convert dcbz operations into read within to modify transactions in L2</description>
    <enumerator>
      <name>FALSE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>1</value>
    </enumerator>
    <id>MRW_CONVERT_DCBZ_TO_RWITM</id>
  </enumerationType>

  <attribute>
    <description>Maximum voltage limit for the dynamic VID DDR3 VDDR voltage setpoint. In mV.</description>
    <id>MRW_DDR3_VDDR_MAX_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Maximum voltage limit for the dynamic VID DDR3 VDDR voltage setpoint. In mV.</description>
    <id>MRW_DDR3_VDDR_MAX_LIMIT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Maximum voltage limit for the dynamic VID DDR4 VDDR voltage setpoint. In mV.</description>
    <id>MRW_DDR4_VDDR_MAX_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Maximum voltage limit for the dynamic VID DDR4 VDDR voltage setpoint. In mV.</description>
    <id>MRW_DDR4_VDDR_MAX_LIMIT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Attribute indicating the default risk level for the system. Applied if scratch registers are not overriden</description>
    <id>MRW_DEFAULT_RISK_LEVEL</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0x0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>The system defined floor frequency input to MAX(VPD or WOF Override PowerSave, ATTR_MRW_FREQ_SYSTEM_CORE_FLOOR_MHZ) from which ATTR_FREQ_SYSTEM_CORE_FLOOR_MHZ and ATTR_FREQ_CORE_FLOOR_MHZ values are derived.</description>
    <id>MRW_FREQ_SYSTEM_CORE_FLOOR_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>3250</default>
      </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MRW_FREQ_SYSTEM_CORE_FLOOR_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Increase the L2 re-request jitter for larger systems</description>
    <id>MRW_L2_INCREASE_JITTER</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MRW_L2_INCREASE_JITTER</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Increase the L2 re-request jitter for larger systems</description>
    <enumerator>
      <name>FALSE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>1</value>
    </enumerator>
    <id>MRW_L2_INCREASE_JITTER</id>
  </enumerationType>

  <attribute>
    <description>Machine Readable Workbook throttle value for denominator cfg_nm_m</description>
    <id>MRW_MEM_THROTTLE_DENOMINATOR</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>Set plus1-prefetch confidence to 3 based on system type, subject to code enforced core configuration limit</description>
    <id>MRW_P1PF_MIN_CONFIDENCE_3</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MRW_P1PF_MIN_CONFIDENCE_3</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Set plus1-prefetch confidence to 3 based on system type, subject to code enforced core configuration limit</description>
    <enumerator>
      <name>FALSE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>1</value>
    </enumerator>
    <id>MRW_P1PF_MIN_CONFIDENCE_3</id>
  </enumerationType>

  <attribute>
    <description>Machine Readable Workbook safe mode throttle value for numerator cfg_nm_n_per_chip</description>
    <id>MRW_SAFEMODE_MEM_THROTTLE_NUMERATOR_PER_CHIP</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>Machine Readable Workbook VMEM regulator power limit per CDIMM assuming a full configuration. Units in cW Used for Cumulus Consumed in mss_eff_config_thermal</description>
    <id>MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR3</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR3</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Machine Readable Workbook VMEM regulator power limit per DIMM assuming a full configuration. Units in cW Consumed in mss_eff_config_thermal</description>
    <id>MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR4</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0x000006A4</default>
      </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR4</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>An array of the supported EC levels for each chip that is allowed to ship. The size of the array should only increase when the number of entries in the MRW increases. The array takes the form: Even Entries: cfam chip id Odd Entries: Required EC level of the preceeding Target Type</description>
    <id>MSL_FIELD_SUPPORTED</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>12</array>
      <uint16_t>
        <default>0,0,0,0,0,0,0,0,0,0,0,0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>An array of the supported EC levels for each chip that is allowed to use in MFG systems. The size of the array should only increase when the number of entries in the MRW increases. The array takes the form: Even Entries: cfam chip id Odd Entries: Required EC level of the preceeding Target Type</description>
    <id>MSL_MFG_ALLOW</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>12</array>
      <uint16_t>
        <default>0,0,0,0,0,0,0,0,0,0,0,0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>AVDD memory programming type 0 = POWERON - domain is programmed as part of regular power on sequence, 1 = STATIC - domain needs to be programmed, no special computation needed, 2 = DYNAMIC - domain needs to be programmed, uses dynamic vid logic</description>
    <hasStringConversion/>
    <id>MSS_AVDD_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Units: mV</description>
    <id>MSS_CENT_AVDD_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_AVDD_SLOPE_INTERCEPT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Units: uV/Membuf</description>
    <id>MSS_CENT_AVDD_SLOPE_ACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_AVDD_SLOPE_ACTIVE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Units: uV/Membuf</description>
    <id>MSS_CENT_AVDD_SLOPE_INACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_AVDD_SLOPE_INACTIVE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Units: mV</description>
    <id>MSS_CENT_VCS_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: uV/Membuf</description>
    <id>MSS_CENT_VCS_SLOPE_ACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: uV/Membuf</description>
    <id>MSS_CENT_VCS_SLOPE_INACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: mV</description>
    <id>MSS_CENT_VDD_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: uV/Membuf</description>
    <id>MSS_CENT_VDD_SLOPE_ACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: uV/Membuf</description>
    <id>MSS_CENT_VDD_SLOPE_INACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Used in the setting of groups. It is a bit vector. If the value BITWISE_AND 0x01 = 0x01 then groups of 1 MCC is allowed, if the value BITWISE_AND 0x02 = 0x02, then groups of 2 MCCs is allowed, if the value BITWISE_AND 0x04 = 0x04, then groups of 3 MCCs is allowed, if the value BITWISE_AND 0x08 = 0x08, then groups of 4 MCCs is allowed, if the value BITWISE_AND 0x20 = 0x20, then groups of 6 MCCs is allowed, if the value BITWISE_AND 0x80 = 0x80, then groups of 8 MCCs is allowed. Provided by the MRW. The memory grouping is done at the MCC level and this attribute tells the grouping process how many MCCs are allowed be grouped together. If no groups can be formed according to the allowed groups then an error will be thrown.</description>
    <id>MSS_INTERLEAVE_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0xAF</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_INTERLEAVE_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Determines the stride covered by each granule in an interleaving group. The default stride -- 128B -- is the only value intended for production FW use. All other combinations are for experimental performance evaluation. Regardless of this attribute value, groups of size 1, 3, and 6 will be forced to 128B stride based on the logic capabilities.</description>
    <id>MSS_INTERLEAVE_GRANULARITY</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_INTERLEAVE_GRANULARITY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Determines the stride covered by each granule in an interleaving group. The default stride -- 128B -- is the only value intended for production FW use. All other combinations are for experimental performance evaluation. Regardless of this attribute value, groups of size 1, 3, and 6 will be forced to 128B stride based on the logic capabilities.</description>
    <enumerator>
      <name>128_B</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>256_B</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>512_B</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>1_KB</name>
      <value>0x03</value>
    </enumerator>
    <enumerator>
      <name>2_KB</name>
      <value>0x04</value>
    </enumerator>
    <enumerator>
      <name>4_KB</name>
      <value>0x05</value>
    </enumerator>
    <enumerator>
      <name>8_KB</name>
      <value>0x06</value>
    </enumerator>
    <enumerator>
      <name>16_KB</name>
      <value>0x07</value>
    </enumerator>
    <enumerator>
      <name>32_KB</name>
      <value>0x08</value>
    </enumerator>
    <id>MSS_INTERLEAVE_GRANULARITY</id>
  </enumerationType>

  <attribute>
    <description>sets the Centaur address bits used to interleave addresses between MBA01 and MBA23. valid values are 23 through 32.</description>
    <id>MSS_MBA_ADDR_INTERLEAVE_BIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>centaur interleave mode. 1 = 256-BIT, 0 = 128-BIT.</description>
    <id>MSS_MBA_CACHELINE_INTERLEAVE_MODE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Switch that allows unsupported raw card references by providing a default raw card setting.</description>
    <id>MSS_MRW_ALLOW_UNSUPPORTED_RCW</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_ALLOW_UNSUPPORTED_RCW</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Switch that allows unsupported raw card references by providing a default raw card setting.</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_ALLOW_UNSUPPORTED_RCW</id>
  </enumerationType>

  <attribute>
    <description>Used for to determine whether to apply an offset to AVDD. Supplied by MRW.</description>
    <id>MSS_MRW_AVDD_OFFSET_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_AVDD_OFFSET_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Used for to determine whether to apply an offset to AVDD. Supplied by MRW.</description>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <id>MSS_MRW_AVDD_OFFSET_ENABLE</id>
  </enumerationType>

  <attribute>
    <description>System specific DIMM height mixing plug rule</description>
    <id>MSS_MRW_DIMM_HEIGHT_MIXING_POLICY</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>NOT_ALLOWED</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_DIMM_HEIGHT_MIXING_POLICY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>System specific DIMM height mixing plug rule</description>
    <enumerator>
      <name>NOT_ALLOWED</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ALLOWED</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_DIMM_HEIGHT_MIXING_POLICY</id>
  </enumerationType>

  <attribute>
    <description>Machine Readable Workbook DIMM power curve percent uplift for this system at max utilization. Value should be 0 for ISDIMMs</description>
    <id>MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Machine Readable Workbook DIMM power curve percent uplift for this system at idle utilization. Value should be 0 for ISDIMMs</description>
    <id>MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Machine Readable Workbook value to describe the airflow past DIMM slots. Facing the front of the DIMM, the airflow is described as either RIGHT_TO_LEFT or LEFT_TO_RIGHT using the attribute enums. Note that the enum values here map to the left/right sensor locations in the DDIMM SPD.</description>
    <id>MSS_MRW_DIMM_SLOT_AIRFLOW</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>RIGHT_TO_LEFT</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_DIMM_SLOT_AIRFLOW</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Machine Readable Workbook value to describe the airflow past DIMM slots. Facing the front of the DIMM, the airflow is described as either RIGHT_TO_LEFT or LEFT_TO_RIGHT using the attribute enums. Note that the enum values here map to the left/right sensor locations in the DDIMM SPD.</description>
    <enumerator>
      <name>RIGHT_TO_LEFT</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>LEFT_TO_RIGHT</name>
      <value>0x01</value>
    </enumerator>
    <id>MSS_MRW_DIMM_SLOT_AIRFLOW</id>
  </enumerationType>

  <attribute>
    <description>Allows user to manually turn on and off 2N Mode. AUTO indicates to use Signal Integrity generated setting (from VPD).</description>
    <id>MSS_MRW_DRAM_2N_MODE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>AUTO</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_DRAM_2N_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Allows user to manually turn on and off 2N Mode. AUTO indicates to use Signal Integrity generated setting (from VPD).</description>
    <enumerator>
      <name>AUTO</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>FORCE_TO_1N_MODE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>FORCE_TO_2N_MODE</name>
      <value>2</value>
    </enumerator>
    <id>MSS_MRW_DRAM_2N_MODE</id>
  </enumerationType>

  <attribute>
    <description>Enables DRAM Write CRC</description>
    <id>MSS_MRW_DRAM_WRITE_CRC</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_DRAM_WRITE_CRC</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Enables DRAM Write CRC</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_DRAM_WRITE_CRC</id>
  </enumerationType>

  <attribute>
    <description>Fine refresh mode. Sets DDR4 MRS3. ZZ uses normal mode. From JEDEC DDR4 Spec 1716.78C from 07-2016 Page 47 Table 4.9.1</description>
    <id>MSS_MRW_FINE_REFRESH_MODE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>NORMAL</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_FINE_REFRESH_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Fine refresh mode. Sets DDR4 MRS3. ZZ uses normal mode. From JEDEC DDR4 Spec 1716.78C from 07-2016 Page 47 Table 4.9.1</description>
    <enumerator>
      <name>NORMAL</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>FIXED_2X</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>FIXED_4X</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>FLY_2X</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>FLY_4X</name>
      <value>6</value>
    </enumerator>
    <id>MSS_MRW_FINE_REFRESH_MODE</id>
  </enumerationType>

  <attribute>
    <description>An override switch to shut off broadcast mode Enum values: YES: broadcast mode is forced off NO: broadcast mode uses the default value</description>
    <id>MSS_MRW_FORCE_BCMODE_OFF</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_FORCE_BCMODE_OFF</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>An override switch to shut off broadcast mode Enum values: YES: broadcast mode is forced off NO: broadcast mode uses the default value</description>
    <enumerator>
      <name>NO</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>YES</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_FORCE_BCMODE_OFF</id>
  </enumerationType>

  <attribute>
    <description>Memory power control settings for IDLE powersave mode Used by OCC when entering idle power-save mode</description>
    <id>MSS_MRW_IDLE_POWER_CONTROL_REQUESTED</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>OFF</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_IDLE_POWER_CONTROL_REQUESTED</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <default>NONE</default>
    <description>Memory power control settings for IDLE powersave mode Used by OCC when entering idle power-save mode</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>POWER_DOWN</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>PD_AND_STR</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>PD_AND_STR_CLK_STOP</name>
      <value>0x03</value>
    </enumerator>
    <id>MSS_MRW_IDLE_POWER_CONTROL_REQUESTED</id>
  </enumerationType>

  <attribute>
    <description>Machine Readable Workbook value for maximum dram data bus utilization in centi percent (c%). Used to determine memory throttle values. Max databus utilization on a per port basis Default to 90%</description>
    <id>MSS_MRW_MAX_DRAM_DATABUS_UTIL</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0x00002328</default>
      </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_MAX_DRAM_DATABUS_UTIL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Machine Readable Workbook value for the maximum possible number of dimms that can be installed under any of the VMEM regulators. Consumed in eff_config_thermal to calculate mem_watt_target</description>
    <id>MSS_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Machine Readable Workbook for the number of M DRAM clocks. One approach to curbing DRAM power usage is by throttling traffic through a programmable N commands over M window.</description>
    <id>MSS_MRW_MEM_M_DRAM_CLOCKS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0x00000200</default>
      </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_MEM_M_DRAM_CLOCKS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>A bitmap containing the plug rules for NVDIMM. 1 if a DIMM supports an NVDIMM being plugged in, 0 if it does not DIMM slot 0 is the left most bit The index to the bitmap is the position of the DIMM target As such, a bitmap of 0b10010000, would allow NVDIMM plugged into DIMM0 and DIMM3 Note: this attribute is a 64 bit number to account for 16 DIMM per processor if there is ever a 4 processor system</description>
    <id>MSS_MRW_NVDIMM_PLUG_RULES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>0</default>
      </uint64_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_NVDIMM_PLUG_RULES</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>A bitmap containing the plug rules for NVDIMM. 1 if a DIMM supports an NVDIMM being plugged in, 0 if it does not DIMM slot 0 is the left most bit The index to the bitmap is the position of the DIMM target As such, a bitmap of 0b10010000, would allow NVDIMM plugged into DIMM0 and DIMM3 Note: this attribute is a 64 bit number to account for 16 DIMM per processor if there is ever a 4 processor system</description>
    <enumerator>
      <name>NO_NVDIMM</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>NVDIMM_CAPABLE</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_NVDIMM_PLUG_RULES</id>
  </enumerationType>

  <attribute>
    <description>Machine Readable Workbook Current Curve Intercept and limit for DIMM Used to calculate throttles to meet regulator current per DIMM limit Per DIMM basis, uses first matching KEY entry For DDIMM, use PMIC SW output that provides worst case throttling KEY (0-21): In order DIMM_SIZE = bits 0-3, DIMM_GEN = 4-5, DIMM_TYPE = 6-8, DIMM_WIDTH = 9-11, DIMM_DENSITY = 12-14, DIMM_STACK_TYPE = 15-16, DRAM_MFGID = 17-19, DIMM_HEIGHT = 20-21, Bits 22-32: Not used VALUE (bits 32-39): Current limit (dA) DDIMM: PMIC output current limit per DDIMM non-DDIMM: VMEM regulator current limit per DIMM VALUE (bits 40-51): Current slope (cA/utilization) DDIMM: PMIC output current slope per DDIMM non-DDIMM: VMEM regulator current slope per DIMM VALUE (bits 52-63): Current intercept (cA) DDIMM: PMIC output current intercept per DDIMM non-DDIMM: VMEM regulator current intercept per DIMM</description>
    <id>MSS_MRW_OCMB_CURRENT_CURVE_WITH_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>25</array>
      <uint64_t>
        <default>0xFFFFFC0064152094</default>
      </uint64_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_OCMB_CURRENT_CURVE_WITH_LIMIT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Machine Readable Workbook Power Curve Intercept for DIMM Used to calculate thermal throttles and port power Per DIMM basis, uses first matching KEY entry KEY (0-21): In order DIMM_SIZE = bits 0-3, DIMM_GEN = 4-5, DIMM_TYPE = 6-8, DIMM_WIDTH = 9-11, DIMM_DENSITY = 12-14, DIMM_STACK_TYPE = 15-16, DRAM_MFGID = 17-19, DIMM_HEIGHT = 20-21, Bits 22-32: Not used VALUE (bits 32-47) in cW/utilization: DIMM power intercept DDIMM: Total OCMB+DRAM power intercept per DDIMM non-DDIMM: VMEM+VPP power intercept per DIMM</description>
    <id>MSS_MRW_OCMB_PWR_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>50</array>
      <uint64_t>
        <default>0xfffffc0005260000</default>
      </uint64_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_OCMB_PWR_INTERCEPT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Machine Readable Workbook Power Curve Slope for DIMM Used to calculate thermal throttles and port power Per DIMM basis, uses first matching KEY entry KEY (0-21): In order DIMM_SIZE = bits 0-3, DIMM_GEN = 4-5, DIMM_TYPE = 6-8, DIMM_WIDTH = 9-11, DIMM_DENSITY = 12-14, DIMM_STACK_TYPE = 15-16, DRAM_MFGID = 17-19, DIMM_HEIGHT = 20-21, Bits 22-32: Not used VALUE (bits 32-47) in cW/utilization: DIMM power slope DDIMM: Total OCMB+DRAM power slope per DDIMM non-DDIMM: VMEM+VPP power slope per DIMM</description>
    <id>MSS_MRW_OCMB_PWR_SLOPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>50</array>
      <uint64_t>
        <default>0xfffffc0004620000</default>
      </uint64_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_OCMB_PWR_SLOPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>System specific definition of which RESET_N signal is connected to the OCMB's DIMM slot. RESET_N signals are ordered from 0-N</description>
    <global/>
    <id>MSS_MRW_OCMB_RESET_GROUP</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_OCMB_RESET_GROUP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Machine Readable Workbook Thermal Memory Power Limit Used to calculate throttles to meet the thermal power per DIMM limit Per DIMM basis, uses first matching KEY entry KEY (0-21): In order DIMM_SIZE = bits 0-3, DIMM_GEN = 4-5, DIMM_TYPE = 6-8, DIMM_WIDTH = 9-11, DIMM_DENSITY = 12-14, DIMM_STACK_TYPE = 15-16, DRAM_MFGID = 17-19, DIMM_HEIGHT = 20-21, Bits 22-32: Not used VALUE (bits 32-47) in cW: thermal power limit DDIMM: Total OCMB+DRAM power limit per DDIMM non-DDIMM: VMEM+VPP power limit per DIMM</description>
    <id>MSS_MRW_OCMB_THERMAL_MEMORY_POWER_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>25</array>
      <uint64_t>
        <default>0xfffffc0009c40000</default>
      </uint64_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_OCMB_THERMAL_MEMORY_POWER_LIMIT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Set to ENABLED to activate a workaround for 4U DDIMMs to set thermal sensor usage from DRAM to DRAM_AND_MEM_BUF_EXT, and from PMIC to MEM_BUF_EXT. Affects power management subsystem fan speed controls.</description>
    <id>MSS_MRW_OVERRIDE_THERM_SENSOR_USAGE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>DISABLED</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_OVERRIDE_THERM_SENSOR_USAGE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Set to ENABLED to activate a workaround for 4U DDIMMs to set thermal sensor usage from DRAM to DRAM_AND_MEM_BUF_EXT, and from PMIC to MEM_BUF_EXT. Affects power management subsystem fan speed controls.</description>
    <enumerator>
      <name>DISABLED</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ENABLED</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_OVERRIDE_THERM_SENSOR_USAGE</id>
  </enumerationType>

  <attribute>
    <description>Describes the settings for periodic calibration for all ports: Reading left to right. (DEFAULT: 0xD90C -&gt; Byte 0(11011001), Byte 1(00001100)) For each bit: OFF = 0, ON = 1. Setting to 0 indicates to disable periodic memcal. Byte 0: 0: ZCAL 1: SYSCK_ALIGN 2: RDCENTERING 3: RDLCK_ALIGN 4: DQS_ALIGN 5: RDCLK_UPDATE 6: PER_DUTYCYCLE 7: PERCAL_PWR_DIS Byte 1: 0: PERCAL_REPEAT 1: PERCAL_REPEAT 2: PERCAL_REPEAT 3: SINGLE_BIT_MPR 4: MBA_CFG_0 5: MBA_CFG_1 6: SPARE 7: SPARE</description>
    <id>MSS_MRW_PERIODIC_MEMCAL_MODE_OPTIONS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0xD90C</default>
      </uint16_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_PERIODIC_MEMCAL_MODE_OPTIONS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Describes the settings for periodic ZQ calibration for all ports: Reading left to right. For each bit: OFF = 0, ON = 1. Setting to 0 indicates to disable periodic zqcal. Byte 0: 0: ZQCAL All others reserved for future use</description>
    <id>MSS_MRW_PERIODIC_ZQCAL_MODE_OPTIONS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0x8000</default>
      </uint16_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_PERIODIC_ZQCAL_MODE_OPTIONS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Memory power control settings programmed during IPL Used by OCC when exiting idle power-save mode</description>
    <id>MSS_MRW_POWER_CONTROL_REQUESTED</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>OFF</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_POWER_CONTROL_REQUESTED</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <default>OFF</default>
    <description>Memory power control settings programmed during IPL Used by OCC when exiting idle power-save mode</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>POWER_DOWN</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>PD_AND_STR</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>PD_AND_STR_CLK_STOP</name>
      <value>0x03</value>
    </enumerator>
    <id>MSS_MRW_POWER_CONTROL_REQUESTED</id>
  </enumerationType>

  <attribute>
    <description>Machine Readable Workbook Power Curve Intercept for DIMM Used to get the VDDR and VDDR+VPP power curve for each DIMM Decoded and used to set ATTR_MSS_TOTAL_PWR_INTERCEPT Key Value pair KEY (0-19): In order DIMM_SIZE = bits 0-3, DIMM_GEN = 4-5, DIMM_TYPE = 6-7, DIMM_WIDTH = 8-10, DIMM_DENSITY = 11-13, DIMM_STACK_TYPE = 14-15, DRAM_MFGID = 16-18, DIMMS_PER_PORT = 19-20, Bits 21-32: Not used VALUE (bits 32-63) in cW: VMEM power curve = 32-47 VMEM+VPP power curve = 48-63 Consumers: eff_config_thermal</description>
    <id>MSS_MRW_PWR_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>100</array>
      <uint64_t>
        <default>0xffffe00002CC03AE,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0</default>
      </uint64_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_PWR_INTERCEPT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Machine Readable Workbook Power Curve Slope for DIMM Used to get the VDDR and VDDR+VPP power curve for each DIMM Decoded and used to set ATTR_MSS_TOTAL_PWR_INTERCEPT Key Value pair KEY (0-19): In order DIMM_SIZE = bits 0-3, DIMM_GEN = 4-5, DIMM_TYPE = 6-7, DIMM_WIDTH = 8-10, DIMM_DENSITY = 11-13, DIMM_STACK_TYPE = 14-15, DRAM_MFGID = 16-18, DIMMS_PER_PORT = 19-20, Bits 21-32: Not used VALUE (bits 32-63) in cW: VMEM power curve = 32-47 VMEM+VPP power curve = 48-63 Consumers: eff_config_thermal</description>
    <id>MSS_MRW_PWR_SLOPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>100</array>
      <uint64_t>
        <default>0xffffe00003FD0546,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0</default>
      </uint64_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_PWR_SLOPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Machine Readable Workbook Refresh Rate Desired refresh interval used in refresh register 0, MBAREF0Q_CFG_REFRESH_INTERVAL 7.8 us (SINGLE) 3.9 us (DOUBLE) 7.02 us (SINGLE_10_PERCENT_FASTER) 3.51 us (DOUBLE_10_PERCENT_FASTER)</description>
    <id>MSS_MRW_REFRESH_RATE_REQUEST</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_REFRESH_RATE_REQUEST</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Machine Readable Workbook Refresh Rate Desired refresh interval used in refresh register 0, MBAREF0Q_CFG_REFRESH_INTERVAL 7.8 us (SINGLE) 3.9 us (DOUBLE) 7.02 us (SINGLE_10_PERCENT_FASTER) 3.51 us (DOUBLE_10_PERCENT_FASTER)</description>
    <enumerator>
      <name>DOUBLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>SINGLE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SINGLE_10_PERCENT_FASTER</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>DOUBLE_10_PERCENT_FASTER</name>
      <value>3</value>
    </enumerator>
    <id>MSS_MRW_REFRESH_RATE_REQUEST</id>
  </enumerationType>

  <attribute>
    <description>For resetting the phy delay values at the beginning of calling mss_draminit_training. YES means the vaules will be reset.</description>
    <id>MSS_MRW_RESET_DELAY_BEFORE_CAL</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>YES</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_RESET_DELAY_BEFORE_CAL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>For resetting the phy delay values at the beginning of calling mss_draminit_training. YES means the vaules will be reset.</description>
    <enumerator>
      <name>YES</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>NO</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_RESET_DELAY_BEFORE_CAL</id>
  </enumerationType>

  <attribute>
    <description>Machine Readable Workbook value for safe mode dram data bus utilization in centi percent (c%). Set to below optimum value/ rate. On a per port basis Also used for emergency mode throttle Used to thermally protect the system in all supported environmental conditions when OCC is not functional Consumer: thermal_init, initfile Default to 2500 c%%</description>
    <id>MSS_MRW_SAFEMODE_DRAM_DATABUS_UTIL</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0x000009C4</default>
      </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_SAFEMODE_DRAM_DATABUS_UTIL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Machine Readable Workbook safe mode throttle value for numerator cfg_nm_n_per_port Set to below optimum value/ rate. On a per port basis Also used for emergency mode throttle FARB4Q_EMERGENCY_N Used to thermally protect the system in all supported environmental conditions when OCC is not functional Consumer: thermal_init, initfile</description>
    <id>MSS_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>32</default>
      </uint16_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Bitmap of DRAM widths supported by a system. A 1 indicates that the system supports a density. Enums below represent the the bit location in the attribute for a given DRAM width. Default value is 0xC -&gt; both x4/x8 supported</description>
    <id>MSS_MRW_SUPPORTED_DRAM_WIDTH</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0xc0</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_SUPPORTED_DRAM_WIDTH</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Bitmap of DRAM widths supported by a system. A 1 indicates that the system supports a density. Enums below represent the the bit location in the attribute for a given DRAM width. Default value is 0xC -&gt; both x4/x8 supported</description>
    <enumerator>
      <name>X4</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>X8</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_SUPPORTED_DRAM_WIDTH</id>
  </enumerationType>

  <attribute>
    <description>List of memory frequencies supported by the current system.</description>
    <id>MSS_MRW_SUPPORTED_FREQ</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint32_t>
        <default>1866,2133,2400,2667</default>
      </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_SUPPORTED_FREQ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>List of memory frequencies supported by the current system.</description>
    <enumerator>
      <name>MT1866</name>
      <value>1866</value>
    </enumerator>
    <enumerator>
      <name>MT2133</name>
      <value>2133</value>
    </enumerator>
    <enumerator>
      <name>MT2400</name>
      <value>2400</value>
    </enumerator>
    <enumerator>
      <name>MT2666</name>
      <value>2666</value>
    </enumerator>
    <enumerator>
      <name>MT2933</name>
      <value>2933</value>
    </enumerator>
    <enumerator>
      <name>MT3200</name>
      <value>3200</value>
    </enumerator>
    <id>MSS_MRW_SUPPORTED_FREQ</id>
  </enumerationType>

  <attribute>
    <description>Used in MR4 A3 Temperature refresh mode Should be defaulted to disable</description>
    <id>MSS_MRW_TEMP_REFRESH_MODE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_TEMP_REFRESH_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Used in MR4 A3 Temperature refresh mode Should be defaulted to disable</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_TEMP_REFRESH_MODE</id>
  </enumerationType>

  <attribute>
    <description>Temperature refresh range. Sets DDR4 MRS4. Should be defaulted to extended range. NORMAL for running at 85 degrees C or less, EXTENDED for 95 or less degrees C Used for calculating periodic refresh intervals JEDEC DDR4 spec 1716.78C from 07-2016 page 46 4.8.1</description>
    <id>MSS_MRW_TEMP_REFRESH_RANGE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_TEMP_REFRESH_RANGE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Temperature refresh range. Sets DDR4 MRS4. Should be defaulted to extended range. NORMAL for running at 85 degrees C or less, EXTENDED for 95 or less degrees C Used for calculating periodic refresh intervals JEDEC DDR4 spec 1716.78C from 07-2016 page 46 4.8.1</description>
    <enumerator>
      <name>NORMAL</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>EXTEND</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_TEMP_REFRESH_RANGE</id>
  </enumerationType>

  <attribute>
    <description>Machine Readable Workbook Thermal Memory Power Limit Used to calculate throttles to be at or under the power limit Per DIMM basis KEY (0-19): In order DIMM_SIZE = bits 0-3, DIMM_GEN = 4-5, DIMM_TYPE = 6-7, DIMM_WIDTH = 8-10, DIMM_DENSITY = 11-13, DIMM_STACK_TYPE = 14-15, DRAM_MFGID = 16-18, DIMMS_PER_PORT = 19-20, Bits 21-32: Not used VALUE (bits 32-63) in cW: VMEM+VPP thermal power limit per DIMM = 32-63 Consumers: eff_config_thermal and bulk_pwr_throttles</description>
    <id>MSS_MRW_THERMAL_MEMORY_POWER_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>10</array>
      <uint64_t>
        <default>0xffffe000000006a4,0,0,0,0,0,0,0,0,0</default>
      </uint64_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_THERMAL_MEMORY_POWER_LIMIT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Used for to determine whether to apply an offset to VCS. Supplied by MRW.</description>
    <id>MSS_MRW_VCS_OFFSET_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_VCS_OFFSET_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Used for to determine whether to apply an offset to VCS. Supplied by MRW.</description>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <id>MSS_MRW_VCS_OFFSET_ENABLE</id>
  </enumerationType>

  <attribute>
    <description>Used for to determine whether to apply an offset to VDDR. Supplied by MRW.</description>
    <id>MSS_MRW_VDDR_OFFSET_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_VDDR_OFFSET_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Used for to determine whether to apply an offset to VDDR. Supplied by MRW.</description>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <id>MSS_MRW_VDDR_OFFSET_ENABLE</id>
  </enumerationType>

  <attribute>
    <description>Used for to determine whether to apply an offset to VDD. Supplied by MRW.</description>
    <id>MSS_MRW_VDD_OFFSET_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_VDD_OFFSET_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Used for to determine whether to apply an offset to VDD. Supplied by MRW.</description>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <id>MSS_MRW_VDD_OFFSET_ENABLE</id>
  </enumerationType>

  <attribute>
    <description>Machine Readable Workbook enablement of the HWP code to adjust the VMEM regulator power limit based on number of installed DIMMs.</description>
    <id>MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Machine Readable Workbook enablement of the HWP code to adjust the VMEM regulator power limit based on number of installed DIMMs.</description>
    <enumerator>
      <name>FALSE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE</id>
  </enumerationType>

  <attribute>
    <description>Used for to determine whether to apply an offset to VCS. Supplied by MRW.</description>
    <id>MSS_MRW_VPP_OFFSET_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_VPP_OFFSET_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Used for to determine whether to apply an offset to VCS. Supplied by MRW.</description>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <id>MSS_MRW_VPP_OFFSET_ENABLE</id>
  </enumerationType>

  <attribute>
    <description>Indicates whether the OCMB is allowed to run in enterprise mode, commodity mode, or either. ALLOW_ENTERPRISE = Most permissive, uses whatever is installed in the way it is intended to be used. REQUIRE_ENTERPRISE = Throws an error for any commodity dimms that are installed. FORCE_NONENTERPRISE = Throws an error for any enterprise dimms that are installed.</description>
    <id>MSS_OCMB_ENTERPRISE_POLICY</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>ALLOW_ENTERPRISE</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_OCMB_ENTERPRISE_POLICY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Indicates whether the OCMB is allowed to run in enterprise mode, commodity mode, or either. ALLOW_ENTERPRISE = Most permissive, uses whatever is installed in the way it is intended to be used. REQUIRE_ENTERPRISE = Throws an error for any commodity dimms that are installed. FORCE_NONENTERPRISE = Throws an error for any enterprise dimms that are installed.</description>
    <enumerator>
      <name>ALLOW_ENTERPRISE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>REQUIRE_ENTERPRISE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>FORCE_NONENTERPRISE</name>
      <value>2</value>
    </enumerator>
    <id>MSS_OCMB_ENTERPRISE_POLICY</id>
  </enumerationType>

  <attribute>
    <description>Indicates whether to enable adaptation</description>
    <id>MSS_OCMB_EXP_BOOT_CONFIG_ADAPTATION_MODE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>ENABLE</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_OCMB_EXP_BOOT_CONFIG_ADAPTATION_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Indicates whether to enable adaptation</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <id>MSS_OCMB_EXP_BOOT_CONFIG_ADAPTATION_MODE</id>
  </enumerationType>

  <attribute>
    <description>The lane width of the OpenCapi channel</description>
    <id>MSS_OCMB_EXP_BOOT_CONFIG_LANE_MODE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_OCMB_EXP_BOOT_CONFIG_LANE_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>The lane width of the OpenCapi channel</description>
    <enumerator>
      <name>LANE_8</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>LANE_4</name>
      <value>2</value>
    </enumerator>
    <id>MSS_OCMB_EXP_BOOT_CONFIG_LANE_MODE</id>
  </enumerationType>

  <attribute>
    <description>The frequency of the OpenCAPI</description>
    <id>MSS_OCMB_EXP_BOOT_CONFIG_SERDES_FREQUENCY</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>3</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_OCMB_EXP_BOOT_CONFIG_SERDES_FREQUENCY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>The frequency of the OpenCAPI</description>
    <enumerator>
      <name>SERDES_21_33GBPS</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SERDES_23_46GBPS</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>SERDES_25_60GBPS</name>
      <value>3</value>
    </enumerator>
    <id>MSS_OCMB_EXP_BOOT_CONFIG_SERDES_FREQUENCY</id>
  </enumerationType>

  <attribute>
    <description>EDPL (Error Detection Per Lane) is a feature in the DL that adds some additional checks to the traffic going across the OpenCAPI link in order to better track which lanes are having issues. Note: EDPL must be set the same on both sides of the link. This attribute affects both the proc/mc side and the OCMB side.</description>
    <id>MSS_OMI_EDPL_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_OMI_EDPL_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>EDPL (Error Detection Per Lane) is a feature in the DL that adds some additional checks to the traffic going across the OpenCAPI link in order to better track which lanes are having issues. Note: EDPL must be set the same on both sides of the link. This attribute affects both the proc/mc side and the OCMB side.</description>
    <enumerator>
      <name>FALSE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>1</value>
    </enumerator>
    <id>MSS_OMI_EDPL_DISABLE</id>
  </enumerationType>

  <attribute>
    <description>VCS memory programming type 0 = POWERON - domain is programmed as part of regular power on sequence, 1 = STATIC - domain needs to be programmed, no special computation needed, 2 = DYNAMIC - domain needs to be programmed, uses dynamic vid logic</description>
    <hasStringConversion/>
    <id>MSS_VCS_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>VDDR memory programming type 0 = POWERON - domain is programmed as part of regular power on sequence, 1 = STATIC - domain needs to be programmed, no special computation needed, 2 = DYNAMIC - domain needs to be programmed, uses dynamic vid logic, 3 = DEFAULT - domain needs to be programmed, pgm values in sys xml file</description>
    <hasStringConversion/>
    <id>MSS_VDDR_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>VDD memory programming type 0 = POWERON - domain is programmed as part of regular power on sequence, 1 = STATIC - domain needs to be programmed, no special computation needed, 2 = DYNAMIC - domain needs to be programmed, uses dynamic vid logic</description>
    <hasStringConversion/>
    <id>MSS_VDD_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Units: mV</description>
    <id>MSS_VOLT_DDR3_VDDR_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Units: mV</description>
    <id>MSS_VOLT_DDR3_VDDR_INTERCEPT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: 1/Amps</description>
    <id>MSS_VOLT_DDR3_VDDR_SLOPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Units: 1/Amps</description>
    <id>MSS_VOLT_DDR3_VDDR_SLOPE_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: mV</description>
    <id>MSS_VOLT_DDR4_VDDR_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Units: mV</description>
    <id>MSS_VOLT_DDR4_VDDR_INTERCEPT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: 1/Amps</description>
    <id>MSS_VOLT_DDR4_VDDR_SLOPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Units: 1/Amps</description>
    <id>MSS_VOLT_DDR4_VDDR_SLOPE_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: mV</description>
    <id>MSS_VOLT_VPP_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Units: mV</description>
    <id>MSS_VOLT_VPP_INTERCEPT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: uV/DRAM</description>
    <id>MSS_VOLT_VPP_SLOPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Units: uV/DRAM</description>
    <id>MSS_VOLT_VPP_SLOPE_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>VPP memory programming type 0 = POWERON - domain is programmed as part of regular power on sequence, 1 = STATIC - domain needs to be programmed, no special computation needed, 2 = DYNAMIC - domain needs to be programmed, uses dynamic vid logic</description>
    <hasStringConversion/>
    <id>MSS_VPP_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <enumerationType>
    <description>Enumeration indicating the multi scome buffer size. The values can be combined using a bitwise 'OR'. The values will need to be kept in sync with the FAPI enumerator values. Also the enumeration type is used by the ATTR_MULTI_SCOM_BUFFER_MAX_SIZE. Should note that the MULTI_SCOM_BUFFER_MAX_SIZE values are of type uint32_t</description>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_1KB</name>
      <value>0x00000400</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_2KB</name>
      <value>0x00000800</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_4KB</name>
      <value>0x00001000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_8KB</name>
      <value>0x00002000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_16KB</name>
      <value>0x00004000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_32KB</name>
      <value>0x00008000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_64KB</name>
      <value>0x00010000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_128KB</name>
      <value>0x00020000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_256KB</name>
      <value>0x00040000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_512KB</name>
      <value>0x00080000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_1MB</name>
      <value>0x00100000</value>
    </enumerator>
    <id>MULTI_SCOM_BUFFER_MAX_SIZE_BIT</id>
  </enumerationType>

  <enumerationType>
    <description>Product name of a chip target. Provided by the MRW.</description>
    <enumerator>
      <name>NONE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>EXPLORER</name>
      <value>0x8</value>
    </enumerator>
    <enumerator>
      <name>GEMINI</name>
      <value>0x9</value>
    </enumerator>
    <enumerator>
      <name>P10</name>
      <value>0xA</value>
    </enumerator>
    <id>NAME</id>
  </enumerationType>

  <attribute>
    <description>Skip locking sequence and check for lock of NEST DPLL</description>
    <id>NEST_DPLL_BYPASS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_NEST_DPLL_BYPASS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Skip locking sequence and check for lock of NEST DPLL</description>
    <enumerator>
      <name>BYPASS</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>NO_BYPASS</name>
      <value>0x0</value>
    </enumerator>
    <id>NEST_DPLL_BYPASS</id>
  </enumerationType>

  <attribute>
    <description>SYSTEM Attribute Nest leakage percentage used to calculate the Core leakage. Will eventually be read into OCC Pstate Parameter Block so the OCC can see it for it's calculations. Valid Values: 0% thru 100% Producer: Machine Readable Workbook Consumer: OCC Firmware</description>
    <id>NEST_LEAKAGE_PERCENT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_NEST_LEAKAGE_PERCENT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Select Nest I2C and pll setting from one of the supported frequencies</description>
    <id>NEST_PLL_BUCKET</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0x05</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_NEST_PLL_BUCKET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Nest VCS Voltage Rail ID. The ID is an arbitrary value and is needed as correlation token between HB and HWSV. It will be generated by the MRW processing scripts.</description>
    <id>NEST_VCS_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Nest VDDR Voltage Rail ID. The ID is an arbitrary value and is needed as correlation token between HB and HWSV. It will be generated by the MRW processing scripts.</description>
    <id>NEST_VDDR_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Nest VDD Voltage Rail ID. The ID is an arbitrary value and is needed as correlation token between HB and HWSV. It will be generated by the MRW processing scripts.</description>
    <id>NEST_VDD_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Nest VDN Voltage Rail ID. The ID is an arbitrary value and is needed as correlation token between HB and HWSV. It will be generated by the MRW processing scripts.</description>
    <id>NEST_VDN_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Nest VIO Voltage Rail ID. The ID is an arbitrary value and is needed as correlation token between HB and HWSV. It will be generated by the MRW processing scripts.</description>
    <id>NEST_VIO_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>A constant power (in watts) that the OCC is to add onto Vdd and Vdn power to represent any processor part that is not measured(i.e.Vcs,Vio) This is used by the OCC to calculate a total processor socket power.</description>
    <id>NO_APSS_PROC_POWER_VCS_VIO_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>NPU MMIO BAR base address values creator: platform consumer: proc_setup_bars firmware notes: 64-bit address representing BAR RA NOTE: BAR register covers RA 14:51 first dimension: unit number (0:3) second dimension: BAR number (0:1)</description>
    <id>NPU_MMIO_BAR_BASE_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4,2</array>
      <uint64_t>
        <default>0</default>
      </uint64_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_NPU_MMIO_BAR_BASE_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>NPU MMIO BAR size values creator: platform consumer: proc_setup_bars firmware notes: none first dimension: unit number (0:3) second dimension: BAR number (0:1)</description>
    <id>NPU_MMIO_BAR_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4,2</array>
      <uint64_t>
        <default>0</default>
      </uint64_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_NPU_MMIO_BAR_SIZE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Enumeration indicating the BAR size used with ATTR_PROC_NPU_MMIO_BAR_SIZE</description>
    <enumerator>
      <name>2_MB</name>
      <value>0x0000000000200000</value>
    </enumerator>
    <enumerator>
      <name>1_MB</name>
      <value>0x0000000000100000</value>
    </enumerator>
    <enumerator>
      <name>512_KB</name>
      <value>0x0000000000080000</value>
    </enumerator>
    <enumerator>
      <name>256_KB</name>
      <value>0x0000000000040000</value>
    </enumerator>
    <enumerator>
      <name>128_KB</name>
      <value>0x0000000000020000</value>
    </enumerator>
    <enumerator>
      <name>64_KB</name>
      <value>0x0000000000010000</value>
    </enumerator>
    <id>NPU_MMIO_BAR_SIZE</id>
  </enumerationType>

  <attribute>
    <complexType>
      <description>Numeric POD type test structure</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path for testing purposes</description>
        <name>fsiPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>CHIP</default>
        <description>Class for testing purposes</description>
        <name>className</name>
        <type>CLASS</type>
      </field>
      <field>
        <default>0xAB</default>
        <description>Test uint8</description>
        <name>uint8</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xABCD</default>
        <description>Test uint16</description>
        <name>uint16</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xABCDEF01</default>
        <description>Test uint32</description>
        <name>uint32</name>
        <type>uint32_t</type>
      </field>
      <field>
        <default>0xABCDEF0123456789</default>
        <description>Test uint64</description>
        <name>uint64</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>-124</default>
        <description>Test int8</description>
        <name>int8</name>
        <type>int8_t</type>
      </field>
      <field>
        <default>-32764</default>
        <description>Test int16</description>
        <name>int16</name>
        <type>int16_t</type>
      </field>
      <field>
        <default>-2147483644</default>
        <description>Test int32</description>
        <name>int32</name>
        <type>int32_t</type>
      </field>
      <field>
        <default>-9223372036854775804</default>
        <description>Test int64</description>
        <name>int64</name>
        <type>int64_t</type>
      </field>
    </complexType>
    <description>Attribute which tests numeric POD types</description>
    <id>NUMERIC_POD_TYPE_TEST</id>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>Defines the number of key-addr pair available to hostboot</description>
    <id>NUM_KEY_ADDR_PAIR</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_NUM_KEY_ADDR_PAIR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>System maximum power cap in output watts when Quick Power Drop line is asserted. This value must guarantee WOF base.</description>
    <id>N_BULK_POWER_LIMIT_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>2880</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>The amount of N Bulk Power to allocate to memory, this value will be used to calculate memory throttles to cap memory to this power. This value must be the left over power from N Bulk Power after allocating power for fixed resources and processor power to guarantee WOF base. NOTE: This value is first reduced by Regulator Efficiency Factor before running the procedure to account for regulator loss.</description>
    <id>N_MAX_MEM_POWER_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>1885</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>System maximum power cap in output watts when Quick Power Drop line is not asserted. (redundant power supplies) This value must guarantee WOF base.</description>
    <id>N_PLUS_ONE_BULK_POWER_LIMIT_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>3584</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>The amount of N+1 Bulk Power to allocate to memory, this value will be used to calculate memory throttles to cap memory to this power. This value must be the left over power from N+1 Bulk Power after allocating power for fixed resources and processor power to guarantee WOF base. NOTE: This value is first reduced by Regulator Efficiency Factor before running the procedure to account for regulator loss before running the HW procedure.</description>
    <id>N_PLUS_ONE_MAX_MEM_POWER_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>1885</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Lane mask for which 8 lanes belong to this brick This is a right justified 24-bit value. Only 8 of the 24 bits will be set representing the lanes belonging to the associated brick. Provided by the MRW.</description>
    <id>OBUS_BRICK_LANE_MASK</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>Tracks the sequence id for OCMB command transactions. The platform is expected to guarantee a unique value on each read.</description>
    <id>OCMB_COUNTER</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_OCMB_COUNTER</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <default>DEFAULT_ALL</default>
    <description>Enumeration for the various OCMB Firmware update behaviors</description>
    <enumerator>
      <name>CHECK_VERSIONS</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>FORCE_UPDATE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>PREVENT_UPDATE</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>CHECK_BUT_NO_UPDATE</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>MDS_FORCE_UPDATE</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>FORCE_UPDATE_ONCE</name>
      <value>5</value>
    </enumerator>
    <id>OCMB_FW_UPDATE_BEHAVIOR</id>
  </enumerationType>

  <attribute>
    <description>An OMI target's relative logical postion to its OMIC parent target. pos | DL_GROUP_POS -----+-------------- 4 | 0 5 | 1 6 | 2 7 | 0 2 | 1 3 | 2 0 | 0 1 | 1 12 | 0 13 | 1 14 | 2 15 | 0 10 | 1 11 | 2 8 | 0 9 | 1</description>
    <id>OMI_DL_GROUP_POS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_OMI_DL_GROUP_POS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>An OMI target's logical DL number pos | DL_NUM -----+-------------- 0 | 6 1 | 7 2 | 4 3 | 5 4 | 0 5 | 1 6 | 2 7 | 3 8 | 14 9 | 15 10 | 12 11 | 13 12 | 8 13 | 9 14 | 10 15 | 11</description>
    <id>OMI_DL_NUM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_OMI_DL_NUM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Define OMI Ref clock/Swizzle for OCMB/Explorer.. Mapper from OMI unit id -&gt; ROOT CNTL 7 refclk drive enable bit consumer: p10_ocmb_enable</description>
    <global/>
    <id>OMI_REFCLOCK_SWIZZLE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_OMI_REFCLOCK_SWIZZLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Specifies if spread spectrum is enabled for the OMI links</description>
    <id>OMI_SPREAD_SPECTRUM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>DISABLED</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_OMI_SPREAD_SPECTRUM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Specifies if spread spectrum is enabled for the OMI links</description>
    <enumerator>
      <name>ENABLED</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>DISABLED</name>
      <value>0x00</value>
    </enumerator>
    <id>OMI_SPREAD_SPECTRUM</id>
  </enumerationType>

  <attribute>
    <description>Selects the settings for Host and Explorer FIRs for when x4 channel degrade occurs. Default: RECOVERABLE (channel degrade will cause recoverable error) Performance team request is to XSTOP when degrade occurs</description>
    <id>OMI_X4_DEGRADE_ACTION</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0x03</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_OMI_X4_DEGRADE_ACTION</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Selects the settings for Host and Explorer FIRs for when x4 channel degrade occurs. Default: RECOVERABLE (channel degrade will cause recoverable error) Performance team request is to XSTOP when degrade occurs</description>
    <enumerator>
      <name>MASKED</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>XSTOP</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>LOCAL_XSTOP</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>RECOVERABLE</name>
      <value>0x03</value>
    </enumerator>
    <id>OMI_X4_DEGRADE_ACTION</id>
  </enumerationType>

  <attribute>
    <description>Specifies the compatible model name for Opal to key off of. This is sourced from the MRW and should be of the format 'vendor,model', e.g. 'tyan,palmetto'.</description>
    <id>OPAL_MODEL</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <default>ibm,miscopenpower</default>
        <sizeInclNull>32</sizeInclNull>
      </string>
    </simpleType>
  </attribute>

  <attribute>
    <description>Power management mode the system should use. Valid values: 1 = Nominal (default), 5 = Static Power Save (percentage below nominal whose value is defined in OPEN_POWER_PM_MODE_FREQ_PERCENT), 6 = Dynamic Power Save - Favor Energy (DPS-FE), 10 = Dynamic Power Save - Favor Performance (DPS-FP), 11 = Fixed Frequency Override - (percentage above nominal whose value is defined in OPEN_POWER_PM_MODE_FREQ_PERCENT)</description>
    <id>OPEN_POWER_PM_MODE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Percentage from nominal that the processors should run at when OPEN_POWER_PM_MODE is set to Static Power Save or Fixed Frequency Override (ignored on all other modes). Unit is in tenths of a percent (150 = 15.0%). Static Power Save (5): percentage to decrease frequency, Fixed Frequency Override (11): percentage to increase frequency</description>
    <id>OPEN_POWER_PM_MODE_FREQ_PERCENT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>Per-link optics configuration 0 = default = SMP 1 = CAPI 2.0 2 = NV 2.0 3 = OPENCAPI Provided by the MRW.</description>
    <id>OPTICS_CONFIG_MODE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>NV</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_OPTICS_CONFIG_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Per-link optics configuration 0 = default = SMP 1 = CAPI 2.0 2 = NV 2.0 3 = OPENCAPI Provided by the MRW.</description>
    <enumerator>
      <name>SMP</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>CAPI</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>NV</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>OCAPI</name>
      <value>0x3</value>
    </enumerator>
    <id>OPTICS_CONFIG_MODE</id>
  </enumerationType>

  <attribute>
    <description>Skip locking sequence and check for lock of PAU DPLL</description>
    <id>PAU_DPLL_BYPASS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_PAU_DPLL_BYPASS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Skip locking sequence and check for lock of PAU DPLL</description>
    <enumerator>
      <name>BYPASS</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>NO_BYPASS</name>
      <value>0x0</value>
    </enumerator>
    <id>PAU_DPLL_BYPASS</id>
  </enumerationType>

  <attribute>
    <description>Attribute indicating what kind of payload is to be started.</description>
    <hasStringConversion/>
    <id>PAYLOAD_KIND</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <default>PHYP</default>
        <id>PAYLOAD_KIND</id>
      </enumeration>
    </simpleType>
    <writeable/>
  </attribute>

  <enumerationType>
    <default>UNKNOWN</default>
    <description>Enumeration indicating what kind of payload is to be started</description>
    <enumerator>
      <name>UNKNOWN</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>PHYP</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SAPPHIRE</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>NONE</name>
      <value>3</value>
    </enumerator>
    <id>PAYLOAD_KIND</id>
  </enumerationType>

  <attribute>
    <description>Receive PBAX Chipid. Value that indicates this PBA's PBAX Chipid within the Is matched to pbax_chipid of the Address phase if Provided by the Machine Readable Workbook. Platform default:Nimbus systems - set so value in ATTR_FABRIC_GROUP_ID</description>
    <global/>
    <id>PBAX_CHIPID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PBAX_CHIPID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Receive PBAX Groupid. Value that indicates this PBA's PBAX Group affinity. matched to pbax_groupid of the PMISC Address phase. Provided by the Machine Readable Workbook. Platform default:Nimbus systems = 0</description>
    <global/>
    <id>PBAX_GROUPID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PBAX_GROUPID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Defines system specific value of PCI0 refclock receiver termination</description>
    <id>PCI0_REFCLOCK_RCVR_TERM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>NONE</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PCI0_REFCLOCK_RCVR_TERM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Defines system specific value of PCI0 refclock receiver termination</description>
    <enumerator>
      <name>NONE</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>FIFTY_OHM</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>ONE_HUNDRED_OHM</name>
      <value>0</value>
    </enumerator>
    <id>PCI0_REFCLOCK_RCVR_TERM</id>
  </enumerationType>

  <attribute>
    <description>Defines system specific value of PCI1 refclock receiver termination</description>
    <id>PCI1_REFCLOCK_RCVR_TERM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>NONE</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PCI1_REFCLOCK_RCVR_TERM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Defines system specific value of PCI1 refclock receiver termination</description>
    <enumerator>
      <name>NONE</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>FIFTY_OHM</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>ONE_HUNDRED_OHM</name>
      <value>0</value>
    </enumerator>
    <id>PCI1_REFCLOCK_RCVR_TERM</id>
  </enumerationType>

  <attribute>
    <description>Designates the System PHB Configuration for NVME Backplanes Creator: MRW Purpose: Used by FW to know which PHBs to deconfigure based on NVME Backplane Data Format: 2x2 array of uint64_t values. The first entry in each array is the CCIN of the NVME backplane. The 2nd entry is a bit definition to show which PHBs on which Procs are disabled. This is also going to emulate the ATTR_PROC_PCIE_PHB_ACTIVE_BASE format. The bit set to 1 signals the particular PHB is disabled. bit 0,1,2: Proc0 Pec0 PHB0/1/2 bit 3: reserved bit 4,5,6: Proc0 Pec1 PHB0/1/2 bit 7: reserved bit 8,9,10: Proc1 Pec0 PHB0/1/2 bit 11: reserved bit 12,13,14: Proc1 Pec1 PHB0/1/2 bit 15: reserved bit 16,17,18: Proc2 Pec0 PHB0/1/2 bit 19: reserved bit 20,21,22: Proc2 Pec1 PHB0/1/2 bit 23: reserved bit 24,25,26: Proc3 Pec0 PHB0/1/2 bit 27: reserved bit 28,29,30: Proc3 Pec1 PHB0/1/2 bit 31: reserved bit 32,33,34: Proc4 Pec0 PHB0/1/2 bit 35: reserved bit 36,37,38: Proc4 Pec1 PHB0/1/2 bit 39: reserved bit 40,41,42: Proc5 Pec0 PHB0/1/2 bit 43: reserved bit 44,45,46: Proc5 Pec1 PHB0/1/2 bit 47: reserved bit 48,49,50: Proc6 Pec0 PHB0/1/2 bit 52: reserved bit 52,53,54: Proc6 Pec1 PHB0/1/2 bit 55: reserved bit 56,57,58: Proc7 Pec0 PHB0/1/2 bit 59: reserved bit 60,61,62: Proc7 Pec1 PHB0/1/2 bit 63: reserved Example: [0x1234, 0x0000, 0x4567, 0x0040080000000000] [0x1234, 0x00000000] -- For NVME Backplane with CCIN 0x1234: Do not deconfigure any PHBs on any Procs [0x4567, 0x0040080000000000) -- For NVME Backplane with CCIN 0x4567: 00 - Do not deconfigure any PHBs on Proc0 40 - Deconfigure PHB1 on Proc1 Pec0 08 - Deconfigure PHB0 on Proc2 Pec1 00 - Do not deconfigure any PHBs on Proc3 00 - Do not deconfigure any PHBs on Proc4 00 - Do not deconfigure any PHBs on Proc5 00 - Do not deconfigure any PHBs on Proc6 00 - Do not deconfigure any PHBs on Proc7</description>
    <id>PCIE_NVME_PHB_CONFIG</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>2,2</array>
      <uint64_t>
        <default>0,0, 0,0</default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Defines system specific value of PCI refclock receiver termination (FSI GP4 bits 10:11)</description>
    <hasStringConversion/>
    <id>PCI_REFCLOCK_RCVR_TERM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>This attribute indicates if the PEC can be bifurcated. The value is determined from the workbook. 0 - PEC is not bifurcateable 1 - PEC can be bifurcated Note: Altering the lane map can be done using the HX keyword.</description>
    <id>PEC_IS_BIFURCATABLE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Effective PCIE IOP reversal configuration Creator: Firmware Purpose: Holds the effective PCIE IOP reversal value after taking into account any IOP bifurcations. If no IOP bifurcations present, this is just the value of the PROC_PCIE_IOP_REVERSAL_NON_BIFURCATED attribute. Data Format: x4 array of uint8_t values. The first uint8_t value is for lane set 0, the second for lane set 1 and so on. The given index in the array is a mask which specifies which bit to invert in the lane swap settings for the given PEC/lane set.</description>
    <id>PEC_PCIE_IOP_REVERSAL</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint8_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Base PCIE IOP reversal configuration Creator: Firmware Purpose: Holds the PCIE IOP reversal value for cases where the IOP is bifurcated Data Format: x4 array of uint8_t values. The first uint8_t value is lane set 0, the second for lane set 2 and so on. The given index in the array is a mask which specifies which bit to invert in the lane swap settings for the given lane set</description>
    <id>PEC_PCIE_IOP_REVERSAL_BIFURCATED</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>Base PCIE IOP reversal configuration Creator: Firmware Purpose: Holds the base PCIE IOP reversal value without considering IOP bifurcation. Data Format: x4 array of uint8_t values. The first uint8_t value is for lane set 0, the second for lane set 1 and so on. The given index in the array is a mask which specifies which bit to invert in the lane swap settings for the given lane set.</description>
    <id>PEC_PCIE_IOP_REVERSAL_NON_BIFURCATED</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>Bifurcated PCIE IOP swap configuration value Creator: MRW Purpose: Holds the base IOP swap configuration value for the IOPs in the case where they are bifurcated. The swap value controls how PCIE lanes are recordered when the leave the IOP, to provide lane routing flexibility. Data Format: A uint8_t value. The value specifices for the hardware how to swap the PCIE lanes for the given PEC.</description>
    <id>PEC_PCIE_IOP_SWAP_BIFURCATED</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>PCIE Lane Mask bifurcated configuration Creator: MRW Purpose: Holds the PCIE lane mask assuming IOPs are bifurcated. Data Format: x4 array of uint16_t values. The first uint8_t value is lane set 0, the second for lane set 2 and so on. A lane set mask indicates which groups of lanes are assigned to an IOP. For instance, lane set 0 value of 0xFF00 and lane set 1 value of 0x00FF means the IOP is bifurcated into two x8s.</description>
    <id>PEC_PCIE_LANE_MASK_BIFURCATED</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint16_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>Peer target's address of a bus (IOHS) connection. NULL means address 0 for no peer target. If a target instance overrides the default with the peer target's PHYS_PATH. The target compiler will convert the valid PHYS_PATH string into the runtime virtual address of the peer target instance.</description>
    <id>PEER_TARGET</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <Target_t>
        <default>NULL</default>
      </Target_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Time between invocations of the 24x7 performance collection function on GPE1. The time (in milliseconds) is derived as 2^PERF_24x7_INVOCATION_TIME_MS with 0 indicating the function is OFF. Consumer: p9_hcode_image_build.c -&gt; SGPE Header field Provided by the Machine Readable Workbook to tune the collection. Platform default: 1</description>
    <id>PERF_24x7_INVOCATION_TIME_MS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PERF_24x7_INVOCATION_TIME_MS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Enumeration indicating the OFF setting for the core and cache chiplet VCS PFET controllers</description>
    <enumerator>
      <name>NOOFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT1TO7OFF</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT2TO7OFF</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT3TO7OFF</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT4TO7OFF</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT5TO7OFF</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT6TO7OFF</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT7TO7OFF</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>ALLOFF</name>
      <value>8</value>
    </enumerator>
    <id>PFET_VCS_VOFF_SEL</id>
  </enumerationType>

  <enumerationType>
    <description>Enumeration indicating the OFF setting for the core and cache chiplet DD PFET controllers</description>
    <enumerator>
      <name>NOOFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT1TO7OFF</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT2TO7OFF</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT3TO7OFF</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT4TO7OFF</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT5TO7OFF</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT6TO7OFF</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT7TO7OFF</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>ALLOFF</name>
      <value>8</value>
    </enumerator>
    <id>PFET_VDD_VOFF_SEL</id>
  </enumerationType>

  <attribute>
    <description>Base Address of PHB Register Space</description>
    <id>PHB_BASE_ADDRS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint64_t>
        <default>0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF</default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>PHYP system type value for rainier is 0x5030</description>
    <id>PHYP_SYSTEM_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0x50300000</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Physical hierarchical path to the target</description>
    <id>PHYS_PATH</id>
    <mrwRequired/>
    <nativeType>
      <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>Set to 1 by HWSV to indicate that attribute overrides exist in a PLCK IPL (not an IPL by steps). This is read by Hostboot to determine if it needs to request the attribute overrides from HWSV before starting its IPL.</description>
    <id>PLCK_IPL_ATTR_OVERRIDES_EXIST</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>PMIC temperature where an error will be generated in degrees C</description>
    <id>PMIC_ERROR_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>95</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Time to wait before PHYP makes HBRT callback to handle the call to do the PMIC health check, time in milliseconds, default to 24 hours, MS_PER_SEC * 60 * 60 * 24, 0xFFFFFFFF = disabled</description>
    <id>PMIC_HEALTH_CHECK_TIMER</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>86400000</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Maximum time in seconds allowed without having a new PMIC temperature before memory throttling will occur</description>
    <id>PMIC_READ_TIMEOUT_SEC</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>30</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>PMIC temperature threshold where throttling will occur in degrees C</description>
    <id>PMIC_THROTTLE_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>85</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <enumerationType>
    <description>Enumeration used for different PM Complex Load Types</description>
    <enumerator>
      <description>Load the PM Complex</description>
      <name>LOAD</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <description>Reload the PM Complex</description>
      <name>RELOAD</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <description>Do NOT load the PM Complex</description>
      <name>DO_NOT_LOAD</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <description>Skip first load of the PM Complex</description>
      <name>SKIP_FIRST_LOAD</name>
      <value>0x3</value>
    </enumerator>
    <id>PM_COMPLEX_LOAD_TYPE</id>
  </enumerationType>

  <attribute>
    <description>Switch to enable or disable Power Management Complex FFDC collection during the PM Complex Halt flow to HOMER to assist with failure analysis and recovery. Producer: HB must set or reset this based on the platform use-case and p10_pm_halt.C, p10_pm_callout.C</description>
    <id>PM_HALT_FFDC_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_PM_HALT_FFDC_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Switch to enable or disable Power Management Complex FFDC collection during the PM Complex Halt flow to HOMER to assist with failure analysis and recovery. Producer: HB must set or reset this based on the platform use-case and p10_pm_halt.C, p10_pm_callout.C</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x01</value>
    </enumerator>
    <id>PM_HALT_FFDC_ENABLE</id>
  </enumerationType>

  <attribute>
    <description>Position of target relative to node</description>
    <id>POSITION</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Position of this DIMM on its memory port</description>
    <id>POS_ON_MEM_PORT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Hierarchical path to the target with respect to power</description>
    <id>POWER_PATH</id>
    <nativeType>
      <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>Required Processor Compatibility Setting</description>
    <id>PROC_COMPATIBILITY_REQ</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>PROC_COMPATIBILITY_REQ</id>
      </enumeration>
    </simpleType>
  </attribute>

  <enumerationType>
    <default>ALLOW_COMPATIBILITY</default>
    <description>Enumeration specifying the compatibility setting for Processor ECs ALLOW_COMPATIBILITY = set RISK_LEVEL to best allowed FORCED_COMPATIBILITY = set RISK_LEVEL to a compatible level FORCED_NATIVE = set RISK_LEVEL to ECs native setting</description>
    <enumerator>
      <name>ALLOW_COMPATIBILITY</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>FORCED_COMPATIBILITY</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>FORCED_NATIVE</name>
      <value>2</value>
    </enumerator>
    <id>PROC_COMPATIBILITY_REQ</id>
  </enumerationType>

  <attribute>
    <description>PROC_CHIP Attribute If true, the chip is installed on a Dual Chip Module Provided by the Machine Readable Workbook</description>
    <id>PROC_DCM_INSTALLED</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>Configures position of where to set bit for mmio addr bar. (Bit position = dialvalue + 43)</description>
    <id>PROC_DSTLCFG_MMIO_ADDRBIT_POS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_DSTLCFG_MMIO_ADDRBIT_POS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Per Chip. Degrees C to change (+/-) the processor chip VPD DVFS temperature to invoke DVFS (clip max Pstate). Default is 0 (no change to VPD limit) NOTE: If we fail to read DVFS limit from VPD system will go to safe mode.</description>
    <id>PROC_DVFS_TEMP_DELTA_C</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <int8_t>
        <default>0</default>
      </int8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Enable proc downstream transmit template 1. Should be enabled by default.</description>
    <id>PROC_ENABLE_DL_TMPL_1</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>ENABLED</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_ENABLE_DL_TMPL_1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Enable proc downstream transmit template 1. Should be enabled by default.</description>
    <enumerator>
      <name>DISABLED</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ENABLED</name>
      <value>0x01</value>
    </enumerator>
    <id>PROC_ENABLE_DL_TMPL_1</id>
  </enumerationType>

  <attribute>
    <description>Enable proc downstream transmit template 4. Should be enabled by default.</description>
    <id>PROC_ENABLE_DL_TMPL_4</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>ENABLED</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_ENABLE_DL_TMPL_4</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Enable proc downstream transmit template 4. Should be enabled by default.</description>
    <enumerator>
      <name>DISABLED</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ENABLED</name>
      <value>0x01</value>
    </enumerator>
    <id>PROC_ENABLE_DL_TMPL_4</id>
  </enumerationType>

  <attribute>
    <description>Enable proc downstream transmit template 7. Should be disabled by default.</description>
    <id>PROC_ENABLE_DL_TMPL_7</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>DISABLED</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_ENABLE_DL_TMPL_7</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Enable proc downstream transmit template 7. Should be disabled by default.</description>
    <enumerator>
      <name>DISABLED</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ENABLED</name>
      <value>0x01</value>
    </enumerator>
    <id>PROC_ENABLE_DL_TMPL_7</id>
  </enumerationType>

  <attribute>
    <description>Enable proc downstream transmit template A. Should be disabled by default.</description>
    <id>PROC_ENABLE_DL_TMPL_A</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>DISABLED</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_ENABLE_DL_TMPL_A</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Enable proc downstream transmit template A. Should be disabled by default.</description>
    <enumerator>
      <name>DISABLED</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ENABLED</name>
      <value>0x01</value>
    </enumerator>
    <id>PROC_ENABLE_DL_TMPL_A</id>
  </enumerationType>

  <attribute>
    <description>Processor epsilon table type. Used to calculate the processor nest epsilon register values. Provided by the MRW.</description>
    <id>PROC_EPS_TABLE_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_EPS_TABLE_TYPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Processor epsilon table type. Used to calculate the processor nest epsilon register values. Provided by the MRW.</description>
    <enumerator>
      <name>EPS_TYPE_LE</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>EPS_TYPE_MR</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>EPS_TYPE_HE</name>
      <value>0x03</value>
    </enumerator>
    <id>PROC_EPS_TABLE_TYPE</id>
  </enumerationType>

  <attribute>
    <description>Per Chip. Degrees C to change (+/-) the processor chip VPD DVFS temperature that a processor chip over temperature error will be logged calling out the processor.</description>
    <id>PROC_ERROR_TEMP_DELTA_C</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <int8_t>
        <default>0x0a</default>
      </int8_t>
    </simpleType>
  </attribute>

  <enumerationType>
    <description>Enumeration indicating the PROC_FABRIC_A_BUS_WIDTH</description>
    <enumerator>
      <name>2_BYTE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>4_BYTE</name>
      <value>2</value>
    </enumerator>
    <id>PROC_FABRIC_A_BUS_WIDTH</id>
  </enumerationType>

  <attribute>
    <description>Processor fabric broadcast scope configuration. Provided by the MRW.</description>
    <id>PROC_FABRIC_BROADCAST_MODE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_BROADCAST_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Processor fabric broadcast scope configuration. Provided by the MRW.</description>
    <enumerator>
      <name>1HOP_CHIP_IS_GROUP</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>1HOP_CHIP_IS_NODE</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>RESERVED</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>2HOP_CHIP_IS_NODE</name>
      <value>0x03</value>
    </enumerator>
    <id>PROC_FABRIC_BROADCAST_MODE</id>
  </enumerationType>

  <enumerationType>
    <description>Enumeration indicating the PROC_FABRIC_CAPI_MODE</description>
    <enumerator>
      <name>OFF</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_FABRIC_CAPI_MODE</id>
  </enumerationType>

  <attribute>
    <description>Fabric dynamic lane reduction psave mode. Disabled =&gt; psave disabled, same as forcing full width. Quarter =&gt; force quarter-width links. Half =&gt; force half-width links. Full/quarter =&gt; start full width, can drop into quarter-width mode. Full/half =&gt; start full width, can drop into half-wdith mode.</description>
    <id>PROC_FABRIC_DLR_PSAVE_MODE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_DLR_PSAVE_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Fabric dynamic lane reduction psave mode. Disabled =&gt; psave disabled, same as forcing full width. Quarter =&gt; force quarter-width links. Half =&gt; force half-width links. Full/quarter =&gt; start full width, can drop into quarter-width mode. Full/half =&gt; start full width, can drop into half-wdith mode.</description>
    <enumerator>
      <name>DISABLED</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>QUARTER</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>HALF</name>
      <value>0x04</value>
    </enumerator>
    <enumerator>
      <name>FULL_QUARTER</name>
      <value>0x0A</value>
    </enumerator>
    <enumerator>
      <name>FULL_HALF</name>
      <value>0x0C</value>
    </enumerator>
    <id>PROC_FABRIC_DLR_PSAVE_MODE</id>
  </enumerationType>

  <attribute>
    <description>Processor fabric SL domain (proxime) configuration.</description>
    <id>PROC_FABRIC_SL_DOMAIN</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_SL_DOMAIN</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Processor fabric SL domain (proxime) configuration.</description>
    <enumerator>
      <name>HEMISPHERE</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>CHIP</name>
      <value>0x01</value>
    </enumerator>
    <id>PROC_FABRIC_SL_DOMAIN</id>
  </enumerationType>

  <enumerationType>
    <description>Enumeration indicating the PROC_FABRIC_SMP_OPTICS_MODE</description>
    <enumerator>
      <name>OPTICS_IS_X_BUS</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>OPTICS_IS_A_BUS</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_FABRIC_SMP_OPTICS_MODE</id>
  </enumerationType>

  <attribute>
    <description>Processor fabric topology ID associated with this chip. This is a 4-bit field in the format specified by ATTR_PROC_FABRIC_TOPOLOGY_MODE. Provided by the MRW.</description>
    <global/>
    <id>PROC_FABRIC_TOPOLOGY_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_TOPOLOGY_ID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Processor fabric topology mode, determines format of the topology ID. MODE0 = GGG_C (max 8x2) MODE1 = GG_CC (max 4x4) Provided by the MRW.</description>
    <id>PROC_FABRIC_TOPOLOGY_MODE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_TOPOLOGY_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Processor fabric topology mode, determines format of the topology ID. MODE0 = GGG_C (max 8x2) MODE1 = GG_CC (max 4x4) Provided by the MRW.</description>
    <enumerator>
      <name>MODE0</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>MODE1</name>
      <value>0x01</value>
    </enumerator>
    <id>PROC_FABRIC_TOPOLOGY_MODE</id>
  </enumerationType>

  <enumerationType>
    <description>Enumeration indicating the PROC_FABRIC_X_BUS_WIDTH</description>
    <enumerator>
      <name>2_BYTE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>4_BYTE</name>
      <value>2</value>
    </enumerator>
    <id>PROC_FABRIC_X_BUS_WIDTH</id>
  </enumerationType>

  <attribute>
    <description>Hardware topology for HDAT creator:MRW consumer:HDAT firmware notes: Hardware Topology 2 Bytes Byte 1: bit 0-3: Node Id bit 4-7: Socket id inside the node bit 8-11: Proc id inside socket bit 12-15:Hub Id inside proc</description>
    <id>PROC_HW_TOPOLOGY</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>Per Chip. Degrees C to change (+/-) the processor IO chip VPD DVFS temperature to invoke DVFS (clip max Pstate). Default is 0 (no change to VPD limit)</description>
    <id>PROC_IO_DVFS_TEMP_DELTA_C</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <int8_t>
        <default>0x0</default>
      </int8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Per Chip. Degrees C to change (+/-) the processor IO chip VPD DVFS temperature that an over temperature error will be logged calling out the processor.</description>
    <id>PROC_IO_ERROR_TEMP_DELTA_C</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <int8_t>
        <default>0x0a</default>
      </int8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Maximum time in seconds allowed without having a new processor IO temperature before DVFS (if supported) will occur</description>
    <id>PROC_IO_READ_TIMEOUT_SEC</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>5</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Disable Lateral CastOut mode in the caches</description>
    <id>PROC_LCO_MODE_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_LCO_MODE_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Disable Lateral CastOut mode in the caches</description>
    <enumerator>
      <name>FALSE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>1</value>
    </enumerator>
    <id>PROC_LCO_MODE_DISABLE</id>
  </enumerationType>

  <attribute>
    <description>Controls lateral castout target set formation. ALL: all cores included in LCO target set ADAPTIVE: base target set selection on percentage of ECO cores relative to all functional L3s. If the percentage of ECO cores is greater than or equal to ATTR_PROC_LCO_MODE_SETUP_ADAPTIVE_N / ATTR_PROC_LCO_MODE_SETUP_ADAPTIVE_D, restrict LCO target set to ECO cores only. Else, use all cores. ECO_ONLY: only ECO cores included in LCO target set</description>
    <id>PROC_LCO_MODE_SETUP</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_LCO_MODE_SETUP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Controls lateral castout target set formation. ALL: all cores included in LCO target set ADAPTIVE: base target set selection on percentage of ECO cores relative to all functional L3s. If the percentage of ECO cores is greater than or equal to ATTR_PROC_LCO_MODE_SETUP_ADAPTIVE_N / ATTR_PROC_LCO_MODE_SETUP_ADAPTIVE_D, restrict LCO target set to ECO cores only. Else, use all cores. ECO_ONLY: only ECO cores included in LCO target set</description>
    <enumerator>
      <name>ADAPTIVE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ALL</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ECO_ONLY</name>
      <value>2</value>
    </enumerator>
    <id>PROC_LCO_MODE_SETUP</id>
  </enumerationType>

  <attribute>
    <description>Controls lateral castout target set formation, when ATTR_PROC_LCO_MODE_SETUP specifies ADAPTIVE mode. Specifies the denominator of the ECO core threshold percentage required to restrict the LCO target set to ECO cores only</description>
    <id>PROC_LCO_MODE_SETUP_ADAPTIVE_D</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>1000</default>
      </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_LCO_MODE_SETUP_ADAPTIVE_D</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Controls lateral castout target set formation, when ATTR_PROC_LCO_MODE_SETUP specifies ADAPTIVE mode. Specifies the numerator of the ECO core threshold percentage required to restrict the LCO target set to ECO cores only</description>
    <id>PROC_LCO_MODE_SETUP_ADAPTIVE_N</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>333</default>
      </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_LCO_MODE_SETUP_ADAPTIVE_N</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Frequency (in MHz) for 1 Watt of processor power change. Used by the power capping algorithm to determine how much to change the frequency based on power available. This is used in populating CALCULATED_MAX_SYS_POWER_EXCLUDING_GPUS</description>
    <id>PROC_MHZ_PER_WATT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>28</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Enumeration of the type of processor module used in the system. Expected to be filled out by the MRW and expected to be the same for every processor module in the system</description>
    <id>PROC_MODULE_TYPE</id>
    <mrwRequired/>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>PROC_MODULE_TYPE</id>
      </enumeration>
    </simpleType>
  </attribute>

  <enumerationType>
    <description>Enumeration for processor module type that come from HDAT spec 0x50 = DCM 0x51 = SCM</description>
    <enumerator>
      <name>GODEL</name>
      <value>0x50</value>
    </enumerator>
    <enumerator>
      <name>BLAISE</name>
      <value>0x51</value>
    </enumerator>
    <id>PROC_MODULE_TYPE</id>
  </enumerationType>

  <attribute>
    <description>The OMI OpenCAPI major version supported by this processor</description>
    <id>PROC_OMI_OC_MAJOR_VER</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0x3</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_OMI_OC_MAJOR_VER</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>The OMI OpenCAPI minor version supported by this processor</description>
    <id>PROC_OMI_OC_MINOR_VER</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0x1</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_OMI_OC_MINOR_VER</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Enumeration indicating which _PBIEX_ASYNC_SEL should be use</description>
    <enumerator>
      <name>SEL0</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>SEL1</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SEL2</name>
      <value>2</value>
    </enumerator>
    <id>PROC_PBIEX_ASYNC_SEL</id>
  </enumerationType>

  <attribute>
    <description>PCIE MMIO BAR enable creator: platform consumer: p10_pcie_config firmware notes: Array index: BAR number (0:2) index 0~1 for MMIO BAR0/1 index 2 for PHB register space</description>
    <id>PROC_PCIE_BAR_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>3</array>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_BAR_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>PCIE MMIO BAR enable creator: platform consumer: p10_pcie_config firmware notes: Array index: BAR number (0:2) index 0~1 for MMIO BAR0/1 index 2 for PHB register space</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_PCIE_BAR_ENABLE</id>
  </enumerationType>

  <attribute>
    <description>PCIE MMIO BAR size values creator: platform consumer: p10_pcie_config firmware notes: Array index: BAR number (0:2) NOTE: supported MMIO BAR0/1 sizes are from 64KB-32PB NOTE: only supported PHB register size is 16KB</description>
    <id>PROC_PCIE_BAR_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>3</array>
      <uint64_t>
        <default>0xFFFFFFC000000000, 0xFFFFFFC000000000, 0xFFFFFFC000000000</default>
      </uint64_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_BAR_SIZE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>PCIE MMIO BAR size values creator: platform consumer: p10_pcie_config firmware notes: Array index: BAR number (0:2) NOTE: supported MMIO BAR0/1 sizes are from 64KB-32PB NOTE: only supported PHB register size is 16KB</description>
    <enumerator>
      <name>32_PB</name>
      <value>0x8000000000000000</value>
    </enumerator>
    <enumerator>
      <name>16_PB</name>
      <value>0xC000000000000000</value>
    </enumerator>
    <enumerator>
      <name>8_PB</name>
      <value>0xE000000000000000</value>
    </enumerator>
    <enumerator>
      <name>4_PB</name>
      <value>0xF000000000000000</value>
    </enumerator>
    <enumerator>
      <name>2_PB</name>
      <value>0xF800000000000000</value>
    </enumerator>
    <enumerator>
      <name>1_PB</name>
      <value>0xFC00000000000000</value>
    </enumerator>
    <enumerator>
      <name>512_TB</name>
      <value>0xFE00000000000000</value>
    </enumerator>
    <enumerator>
      <name>256_TB</name>
      <value>0xFF00000000000000</value>
    </enumerator>
    <enumerator>
      <name>128_TB</name>
      <value>0xFF80000000000000</value>
    </enumerator>
    <enumerator>
      <name>64_TB</name>
      <value>0xFFC0000000000000</value>
    </enumerator>
    <enumerator>
      <name>32_TB</name>
      <value>0xFFE0000000000000</value>
    </enumerator>
    <enumerator>
      <name>16_TB</name>
      <value>0xFFF0000000000000</value>
    </enumerator>
    <enumerator>
      <name>8_TB</name>
      <value>0xFFF8000000000000</value>
    </enumerator>
    <enumerator>
      <name>4_TB</name>
      <value>0xFFFC000000000000</value>
    </enumerator>
    <enumerator>
      <name>2_TB</name>
      <value>0xFFFE000000000000</value>
    </enumerator>
    <enumerator>
      <name>1_TB</name>
      <value>0xFFFF000000000000</value>
    </enumerator>
    <enumerator>
      <name>512_GB</name>
      <value>0xFFFF800000000000</value>
    </enumerator>
    <enumerator>
      <name>256_GB</name>
      <value>0xFFFFC00000000000</value>
    </enumerator>
    <enumerator>
      <name>128_GB</name>
      <value>0xFFFFE00000000000</value>
    </enumerator>
    <enumerator>
      <name>64_GB</name>
      <value>0xFFFFF00000000000</value>
    </enumerator>
    <enumerator>
      <name>32_GB</name>
      <value>0xFFFFF80000000000</value>
    </enumerator>
    <enumerator>
      <name>16_GB</name>
      <value>0xFFFFFC0000000000</value>
    </enumerator>
    <enumerator>
      <name>8_GB</name>
      <value>0xFFFFFE0000000000</value>
    </enumerator>
    <enumerator>
      <name>4_GB</name>
      <value>0xFFFFFF0000000000</value>
    </enumerator>
    <enumerator>
      <name>2_GB</name>
      <value>0xFFFFFF8000000000</value>
    </enumerator>
    <enumerator>
      <name>1_GB</name>
      <value>0xFFFFFFC000000000</value>
    </enumerator>
    <enumerator>
      <name>512_MB</name>
      <value>0xFFFFFFE000000000</value>
    </enumerator>
    <enumerator>
      <name>256_MB</name>
      <value>0xFFFFFFF000000000</value>
    </enumerator>
    <enumerator>
      <name>128_MB</name>
      <value>0xFFFFFFF800000000</value>
    </enumerator>
    <enumerator>
      <name>64_MB</name>
      <value>0xFFFFFFFC00000000</value>
    </enumerator>
    <enumerator>
      <name>32_MB</name>
      <value>0xFFFFFFFE00000000</value>
    </enumerator>
    <enumerator>
      <name>16_MB</name>
      <value>0xFFFFFFFF00000000</value>
    </enumerator>
    <enumerator>
      <name>8_MB</name>
      <value>0xFFFFFFFF80000000</value>
    </enumerator>
    <enumerator>
      <name>4_MB</name>
      <value>0xFFFFFFFFC0000000</value>
    </enumerator>
    <enumerator>
      <name>2_MB</name>
      <value>0xFFFFFFFFE0000000</value>
    </enumerator>
    <enumerator>
      <name>1_MB</name>
      <value>0xFFFFFFFFF0000000</value>
    </enumerator>
    <enumerator>
      <name>512_KB</name>
      <value>0xFFFFFFFFF8000000</value>
    </enumerator>
    <enumerator>
      <name>256_KB</name>
      <value>0xFFFFFFFFFC000000</value>
    </enumerator>
    <enumerator>
      <name>128_KB</name>
      <value>0xFFFFFFFFFE000000</value>
    </enumerator>
    <enumerator>
      <name>64_KB</name>
      <value>0xFFFFFFFFFF000000</value>
    </enumerator>
    <enumerator>
      <name>16_KB</name>
      <value>0xFFFFFFFFFFFFFFFF</value>
    </enumerator>
    <id>PROC_PCIE_BAR_SIZE</id>
  </enumerationType>

  <attribute>
    <description>PCIE IOP lane configuration creator: platform consumer: proc_pcie_scominit firmware notes: Encoded PCIE IOP lane configuration</description>
    <id>PROC_PCIE_IOP_CONFIG</id>
    <ignoreEkb/>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_CONFIG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Indicates whether PCIE lanes terminate at a pluggable slot Creator: MRW Purpose: Used by FW to know whether the given PCIE lanes terminate at a pluggable slot or not. If this is the case, and the platform supports bifurcation, the card's VPD should be interrogated to determine whether to bifurcate the IOP or not. Data Format: x4 array of uint8_t values. The first value indicates whether lane set 0 terminates at a pluggable slot. The next three values indicate the same for lane sets 1-3. A value of 1 at a given array index indicates the lanes terminate at a pluggable slot, 0 otherwise.</description>
    <id>PROC_PCIE_IS_SLOT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>PCIE Lane Equalization values for each PHB Creator: MRW Purpose: Holds settings which are loaded into the HW to optimize the PCIE lane signal eye between the chips + PCIE Gen3 endpoints Data Format: 16 entries of 16 bytes of EQ data per PHB. Each PHB has an EQ value for each of its 16 lanes. Each value is a uint16 formatted as follows: Bit 0:3 - up_rx_hint (bit 0 reserved) Bit 4:7 - up_tx_preset Bit 8:11 - dn_rx_hint (bit 0 reserved) Bit 12:15 - dn_tx_preset</description>
    <id>PROC_PCIE_LANE_EQUALIZATION_GEN3</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>16</array>
      <uint16_t>
        <default>0x5454,0x5454,0x5454,0x5454, 0x5454,0x5454,0x5454,0x5454, 0x5454,0x5454,0x5454,0x5454, 0x5454,0x5454,0x5454,0x5454,</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>PCIE Lane Equalization values for each PHB Creator: MRW Purpose: Holds settings which are loaded into the HW to optimize the PCIE lane signal eye between the chips + PCIE Gen4 endpoints Data Format: 16 entries of 16 bytes of EQ data per PHB. Each PHB has an EQ value for each of its 16 lanes. Each value is a uint16 formatted as follows: Bit 0:3 - up_rx_hint (bit 0 reserved) Bit 4:7 - up_tx_preset Bit 8:11 - dn_rx_hint (bit 0 reserved) Bit 12:15 - dn_tx_preset</description>
    <id>PROC_PCIE_LANE_EQUALIZATION_GEN4</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>16</array>
      <uint16_t>
        <default>0x7777,0x7777,0x7777,0x7777, 0x7777,0x7777,0x7777,0x7777, 0x7777,0x7777,0x7777,0x7777, 0x7777,0x7777,0x7777,0x7777</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>PCIE Lane Equalization values for each PHB Creator: MRW Purpose: Holds settings which are loaded into the HW to optimize the PCIE lane signal eye between the chips + PCIE Gen5 endpoints Data Format: 16 entries of 16 bytes of EQ data per PHB. Each PHB has an EQ value for each of its 16 lanes. Each value is a uint16 formatted as follows: Bit 0:3 - up_rx_hint (bit 0 reserved) Bit 4:7 - up_tx_preset Bit 8:11 - dn_rx_hint (bit 0 reserved) Bit 12:15 - dn_tx_preset</description>
    <id>PROC_PCIE_LANE_EQUALIZATION_GEN5</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>16</array>
      <uint16_t>
        <default>0x7777,0x7777,0x7777,0x7777, 0x7777,0x7777,0x7777,0x7777, 0x7777,0x7777,0x7777,0x7777, 0x7777,0x7777,0x7777,0x7777</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>This attribute controls the latches required to configure the PHBs to swap its lanes if wiring to the connector/device is straight or reverse. creator: platform consumer: p10_pcie_scominit firmware notes: These are config dependent attributes based on PCIe Lane/sideband signal routing and PCIe endpoints attached. Attribute Name Definition Example Comments Targeted HWP Attributes ATTR_PROC_PCIE_LANE_REVERSAL (Stack0, Stack1, Stack2) (1, 0, 0) Reverse lanes on PHB0. TC_PCI_LANE_CFG_DC_2H Do not reverse lanes on PHB1. TC_PCI_LANE_CFG_DC_3H Do not reverse lanes on PHB2. TC_PCI_LANE_CFG_DC_4H Register Address Register Name Bit Signal Name Bit Description 8000009 / 9000009 TPPCI.PCI.CPLT_CONF1 0 TC_PCI_LANE_CFG_DC_0H MSB for LANE CFG in the logic that configures x16, x8x8, x8x4x4 1 TC_PCI_LANE_CFG_DC_1H LSB for LANE CFG in the logic that configures x16, x8x8, x8x4x4 2 TC_PCI_SWAP_DC_2H LANE SWAP control for Stack0 3 TC_PCI_SWAP_DC_3H LANE SWAP control for Stack0 4 TC_PCI_SWAP_DC_4H LANE SWAP control for Stack0 8 TC_PCI_IOVALID_DC_8H IOVALID control for Stack0 9 TC_PCI_IOVALID_DC_9H IOVALID control for Stack1 10 TC_PCI_IOVALID_DC_10H IOVALID control for Stack2</description>
    <id>PROC_PCIE_LANE_REVERSAL</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>3</array>
      <uint8_t>
        <default>DISABLE,DISABLE,DISABLE</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_LANE_REVERSAL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>This attribute controls the latches required to configure the PHBs to swap its lanes if wiring to the connector/device is straight or reverse. creator: platform consumer: p10_pcie_scominit firmware notes: These are config dependent attributes based on PCIe Lane/sideband signal routing and PCIe endpoints attached. Attribute Name Definition Example Comments Targeted HWP Attributes ATTR_PROC_PCIE_LANE_REVERSAL (Stack0, Stack1, Stack2) (1, 0, 0) Reverse lanes on PHB0. TC_PCI_LANE_CFG_DC_2H Do not reverse lanes on PHB1. TC_PCI_LANE_CFG_DC_3H Do not reverse lanes on PHB2. TC_PCI_LANE_CFG_DC_4H Register Address Register Name Bit Signal Name Bit Description 8000009 / 9000009 TPPCI.PCI.CPLT_CONF1 0 TC_PCI_LANE_CFG_DC_0H MSB for LANE CFG in the logic that configures x16, x8x8, x8x4x4 1 TC_PCI_LANE_CFG_DC_1H LSB for LANE CFG in the logic that configures x16, x8x8, x8x4x4 2 TC_PCI_SWAP_DC_2H LANE SWAP control for Stack0 3 TC_PCI_SWAP_DC_3H LANE SWAP control for Stack0 4 TC_PCI_SWAP_DC_4H LANE SWAP control for Stack0 8 TC_PCI_IOVALID_DC_8H IOVALID control for Stack0 9 TC_PCI_IOVALID_DC_9H IOVALID control for Stack1 10 TC_PCI_IOVALID_DC_10H IOVALID control for Stack2</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>0x01</value>
    </enumerator>
    <id>PROC_PCIE_LANE_REVERSAL</id>
  </enumerationType>

  <attribute>
    <description>This attribute holds the base MRW values that controls the latches required to configure the PHBs to swap its lanes if wiring to the connector/device is straight or reverse. On some systems Dynamic Bifurcation can occur (based on VPD values or some other indicator) which may tweak the value provided in this _BASE attribute and the ATTR_PROC_PCIE_LANE_REVERSAL used by the HWP directly. If no dynamic bifurcation occurs the _BASE attribute value and ATTR_PROC_PCIE_LANE_REVERSAL will be identical. creator: platform consumer: p10_pcie_scominit firmware notes: These are config dependent attributes based on PCIe Lane/sideband signal routing and PCIe endpoints attached. Attribute Name Definition Example Comments Targeted HWP Attributes ATTR_PROC_PCIE_LANE_REVERSAL_BASE (Stack0, Stack1, Stack2) (1, 0, 0) Reverse lanes on PHB0. TC_PCI_LANE_CFG_DC_2H Do not reverse lanes on PHB1. TC_PCI_LANE_CFG_DC_3H Do not reverse lanes on PHB2. TC_PCI_LANE_CFG_DC_4H Register Address Register Name Bit Signal Name Bit Description 8000009 / 9000009 TPPCI.PCI.CPLT_CONF1 0 TC_PCI_LANE_CFG_DC_0H MSB for LANE CFG in the logic that configures x16, x8x8, x8x4x4 1 TC_PCI_LANE_CFG_DC_1H LSB for LANE CFG in the logic that configures x16, x8x8, x8x4x4 2 TC_PCI_SWAP_DC_2H LANE SWAP control for Stack0 3 TC_PCI_SWAP_DC_3H LANE SWAP control for Stack0 4 TC_PCI_SWAP_DC_4H LANE SWAP control for Stack0 8 TC_PCI_IOVALID_DC_8H IOVALID control for Stack0 9 TC_PCI_IOVALID_DC_9H IOVALID control for Stack1 10 TC_PCI_IOVALID_DC_10H IOVALID control for Stack2</description>
    <global/>
    <id>PROC_PCIE_LANE_REVERSAL_BASE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>3</array>
      <uint8_t>
        <default>0x0,0x0,0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>PCIE MMIO0 BAR base address offset creator: platform consumer: p10_setup_bars firmware notes: Attribute holds offset (relative to chip MMIO origin) to program into chip address range field of BAR -- RA bits 8:47 (excludes system/memory select/group/chip fields) Array index: PHB number (0:5)</description>
    <id>PROC_PCIE_MMIO_BAR0_BASE_ADDR_OFFSET</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>6</array>
      <uint64_t>
        <default>0x0000000000000000, 0x0000000100000000, 0x0000000200000000, 0x0000000300000000, 0x0000000400000000, 0x0000000500000000</default>
      </uint64_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_MMIO_BAR0_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>PCIE MMIO1 BAR base address offset creator: platform consumer: p10_setup_bars firmware notes: Attribute holds offset (relative to chip MMIO origin) to program into chip address range field of BAR -- RA bits 8:47 (excludes system/memory select/group/chip fields) Array index: PHB number (0:5)</description>
    <id>PROC_PCIE_MMIO_BAR1_BASE_ADDR_OFFSET</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>6</array>
      <uint64_t>
        <default>0x0000000600000000, 0x0000000700000000, 0x0000000800000000, 0x0000000900000000, 0x0000000A00000000, 0x0000000B00000000</default>
      </uint64_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_MMIO_BAR1_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>PCS rx loff control creator: platform consumer: p9_pcie_scominit firmware notes: The value of rx loff control for PCS. Array index: Configuration number index 0~3 for CONFIG0~3</description>
    <id>PROC_PCIE_PCS_RX_LOFF_CONTROL</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint16_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>Value of PCS rx phase rotator control creator: platform consumer: p9_pcie_scominit</description>
    <id>PROC_PCIE_PCS_RX_PHASE_ROTATOR_CNTL</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>Value of PCS rx sigdet control creator: platform consumer: p9_pcie_scominit</description>
    <id>PROC_PCIE_PCS_RX_SIGDET_CNTL</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>PCS rx vga control register3 creator: platform consumer: p9_pcie_scominit firmware notes: The value of rx vga control register3. Array index: Configuration number index 0~3 for CONFIG0~3</description>
    <id>PROC_PCIE_PCS_RX_VGA_CONTRL_REGISTER3</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint16_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>This attribute controls the latches required to configure the PEC as a x16, x8x8, or x8x4x4 based on what PHBs are active defined from the MRW. creator: platform consumer: p10_pcie_scominit firmware notes: These are config dependent attributes based on PCIe Lane/sideband signal routing and PCIe endpoints attached. Attribute Name Definition Example Comments Targeted Register Latches ATTR_PROC_PCIE_PHB_ACTIVE (Stack0, Stack1, Stack2) (1, 0, 0) PHB0 enabled TC_PCI_LANE_CFG_DC_0H, TC_PCI_LANE_CFG_DC_1H PHB1 disabled PHB2 disabled Register Latch Definition: PCI0 / PCI1 Register Address Register Name Bit Signal Name Bit Description 8000009 / 9000009 TPPCI.PCI.CPLT_CONF1 0 TC_PCI_LANE_CFG_DC_0H MSB for LANE CFG in the logic that configures x16, x8x8, x8x4x4 1 TC_PCI_LANE_CFG_DC_1H LSB for LANE CFG in the logic that configures x16, x8x8, x8x4x4 2 TC_PCI_SWAP_DC_2H LANE SWAP control for Stack0 3 TC_PCI_SWAP_DC_3H LANE SWAP control for Stack0 4 TC_PCI_SWAP_DC_4H LANE SWAP control for Stack0 8 TC_PCI_IOVALID_DC_8H IOVALID control for Stack0 9 TC_PCI_IOVALID_DC_9H IOVALID control for Stack1 10 TC_PCI_IOVALID_DC_10H IOVALID control for Stack2</description>
    <id>PROC_PCIE_PHB_ACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>3</array>
      <uint8_t>
        <default>ENABLE,ENABLE,ENABLE</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PHB_ACTIVE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>This attribute controls the latches required to configure the PEC as a x16, x8x8, or x8x4x4 based on what PHBs are active defined from the MRW. creator: platform consumer: p10_pcie_scominit firmware notes: These are config dependent attributes based on PCIe Lane/sideband signal routing and PCIe endpoints attached. Attribute Name Definition Example Comments Targeted Register Latches ATTR_PROC_PCIE_PHB_ACTIVE (Stack0, Stack1, Stack2) (1, 0, 0) PHB0 enabled TC_PCI_LANE_CFG_DC_0H, TC_PCI_LANE_CFG_DC_1H PHB1 disabled PHB2 disabled Register Latch Definition: PCI0 / PCI1 Register Address Register Name Bit Signal Name Bit Description 8000009 / 9000009 TPPCI.PCI.CPLT_CONF1 0 TC_PCI_LANE_CFG_DC_0H MSB for LANE CFG in the logic that configures x16, x8x8, x8x4x4 1 TC_PCI_LANE_CFG_DC_1H LSB for LANE CFG in the logic that configures x16, x8x8, x8x4x4 2 TC_PCI_SWAP_DC_2H LANE SWAP control for Stack0 3 TC_PCI_SWAP_DC_3H LANE SWAP control for Stack0 4 TC_PCI_SWAP_DC_4H LANE SWAP control for Stack0 8 TC_PCI_IOVALID_DC_8H IOVALID control for Stack0 9 TC_PCI_IOVALID_DC_9H IOVALID control for Stack1 10 TC_PCI_IOVALID_DC_10H IOVALID control for Stack2</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>0x01</value>
    </enumerator>
    <id>PROC_PCIE_PHB_ACTIVE</id>
  </enumerationType>

  <attribute>
    <description>This attribute holds the base values from the MRW to define how to configure the PEC as a x16, x8x8, or x8x4x4 based on what PHBs are active defined from the MRW. On some systems Dynamic Bifurcation can occur (based on VPD values or some other indicator) which may tweak the value provided in this _BASE attribute and the ATTR_PROC_PCIE_PHB_ACTIVE used by the HWP directly. If no dynamic bifurcation occurs the _BASE attribute value and ATTR_PROC_PCIE_PHB_ACTIVE will be identical. creator: platform consumer: p10_pcie_scominit firmware notes: These are config dependent attributes based on PCIe Lane/sideband signal routing and PCIe endpoints attached. Attribute Name Definition Example Comments Targeted Register Latches ATTR_PROC_PCIE_PHB_ACTIVE_BASE (Stack0, Stack1, Stack2) (1, 0, 0) PHB0 enabled TC_PCI_LANE_CFG_DC_0H, TC_PCI_LANE_CFG_DC_1H PHB1 disabled PHB2 disabled Register Latch Definition: PCI0 / PCI1 Register Address Register Name Bit Signal Name Bit Description 8000009 / 9000009 TPPCI.PCI.CPLT_CONF1 0 TC_PCI_LANE_CFG_DC_0H MSB for LANE CFG in the logic that configures x16, x8x8, x8x4x4 1 TC_PCI_LANE_CFG_DC_1H LSB for LANE CFG in the logic that configures x16, x8x8, x8x4x4 2 TC_PCI_SWAP_DC_2H LANE SWAP control for Stack0 3 TC_PCI_SWAP_DC_3H LANE SWAP control for Stack0 4 TC_PCI_SWAP_DC_4H LANE SWAP control for Stack0 8 TC_PCI_IOVALID_DC_8H IOVALID control for Stack0 9 TC_PCI_IOVALID_DC_9H IOVALID control for Stack1 10 TC_PCI_IOVALID_DC_10H IOVALID control for Stack2</description>
    <global/>
    <id>PROC_PCIE_PHB_ACTIVE_BASE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>3</array>
      <uint8_t>
        <default>0x1,0x1,0x1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>PCIE PHB register space BAR base address offset creator: platform consumer: p10_setup_bars firmware notes: Attribute holds offset (relative to chip MMIO origin) to program into chip address range field of BAR -- RA bits 8:49 (excludes system/memory select/group/chip fields) Array index: PHB number (0:5)</description>
    <id>PROC_PCIE_PHB_REGISTER_BASE_ADDR_OFFSET</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>6</array>
      <uint64_t>
        <default>0x0000000C00000000, 0x0000000D00000000, 0x0000000E00000000, 0x0000000F00000000, 0x0000001000000000, 0x0000001100000000</default>
      </uint64_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PHB_REGISTER_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Maximum time in seconds allowed without having a new processor temperature before DVFS will occur</description>
    <id>PROC_READ_TIMEOUT_SEC</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>5</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Defines system specific value of processor refclock receiver termination (FSI GP4 bits 8:9)</description>
    <hasStringConversion/>
    <id>PROC_REFCLOCK_RCVR_TERM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Impedance (binary in microOhms) of the distribution loss sense point to the value is applied to each processor instance. [index] -&gt;0: VDD; 1: VCS; 2: VDN; 3: VIO Producer: Machine Readable Workbook (per the power subsystem design) Consumers: p10_pstate_parameter_build</description>
    <id>PROC_R_DISTLOSS_UOHM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint32_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_R_DISTLOSS_UOHM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Impedance (binary microOhms) of the load line from a processor VRM to the pins. This value is applied to each processor instance. [index] -&gt;0: VDD; 1: VCS; 2: VDN; 3: VIO Note:no loadline may be present in the system; thus, a value of 0 is legal. Producer: Machine Readable Workbook (per the power subsystem design) Consumers: p10_pstate_parameter_build</description>
    <id>PROC_R_LOADLINE_UOHM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint32_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_R_LOADLINE_UOHM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Enumeration indicating which chip should be used as the PROC_SELECT_BOOT_MASTER</description>
    <enumerator>
      <name>PRIMARY</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SECONDARY</name>
      <value>2</value>
    </enumerator>
    <id>PROC_SELECT_BOOT_MASTER</id>
  </enumerationType>

  <attribute>
    <description>The maximum power a single procesor socket can support (in watts) This is used to populate CALCULATED_MAX_SYS_POWER_EXCLUDING_GPUS</description>
    <id>PROC_SOCKET_POWER_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>250</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Downstream Template 0 pacing</description>
    <id>PROC_TMPL_0_PACING</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0xF</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_TMPL_0_PACING</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Downstream Template 1 pacing</description>
    <id>PROC_TMPL_1_PACING</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_TMPL_1_PACING</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Downstream Template 4 pacing</description>
    <id>PROC_TMPL_4_PACING</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_TMPL_4_PACING</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Downstream Template 7 pacing</description>
    <id>PROC_TMPL_7_PACING</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_TMPL_7_PACING</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Downstream Template A pacing</description>
    <id>PROC_TMPL_A_PACING</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_TMPL_A_PACING</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Offset voltage (binary in microvolts) to apply to the VDD VRM distribution processor module. This value is applied to each processor instance. [index] -&gt;0: VDD; 1: VCS; 2: VDN; 3: VIO Producer: Machine Readable Workbook (per the power subsystem design) Consumers: p10_pstate_parameter_build</description>
    <id>PROC_VRM_VOFFSET_UV</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint32_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_VRM_VOFFSET_UV</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Weight factor (1 = 0.1) for each quad (racetrack) DTS to calculate a core temperature. A value of 0 means not to include racetrack DTS in core temperature.</description>
    <id>QUAD_WEIGHT_TENTHS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>1 = System has redundant clock oscillators 0 = System does not have redundant clock oscillators From the Machine Readable Workbook</description>
    <id>REDUNDANT_CLOCKS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>Percentage to lower N+1 Maximum Memory Power and N Maximum Memory Power to account for regulator loss prior to calling procedure to calculate memory throttles. NOTE: The procedure calculating memory throttles do not account for regulator loss.</description>
    <id>REGULATOR_EFFICIENCY_FACTOR</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>83</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Indicates if OCC should wait to report DVFS due to power/thermal until max frequency has been lowered below nominal. Default OCC will report DVFS when max frequency is lowered below turbo. DVFS is reported in poll response extended status bits and in OPAL shared memory throttle status byte. 1 = OCC report throttling only when max freq. lowered below nominal 0 = OCC report throttling when max freq. lowered below turbo</description>
    <id>REPORT_THROTTLE_BELOW_NOMINAL</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Specify the system policy to enforce synchronous mode between memory and nest. This drives the value of ATTR_MEM_IN_SYNCH_MODE. UNDETERMINED : Run synchronously if the dimm and nest freq matches ALWAYS : Require matching frequencies and deconfigure memory that does not match the nest NEVER : Do not run synchronously, even if the frequencies match</description>
    <id>REQUIRED_SYNCH_MODE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_REQUIRED_SYNCH_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Specify the system policy to enforce synchronous mode between memory and nest. This drives the value of ATTR_MEM_IN_SYNCH_MODE. UNDETERMINED : Run synchronously if the dimm and nest freq matches ALWAYS : Require matching frequencies and deconfigure memory that does not match the nest NEVER : Do not run synchronously, even if the frequencies match</description>
    <enumerator>
      <name>UNDETERMINED</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ALWAYS</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>NEVER</name>
      <value>2</value>
    </enumerator>
    <id>REQUIRED_SYNCH_MODE</id>
  </enumerationType>

  <attribute>
    <description>Used to tell if a resource is critical to perform an IPL. If this attribute is set to 1 and the target is deconfigured, the IPL MUST terminate.</description>
    <global/>
    <id>RESOURCE_IS_CRITICAL</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Size of RNG IO Region</description>
    <id>RNG_BAR_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>0x000000000001000</default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Base Address of RNG IO Region</description>
    <id>RNG_BASE_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>0xFFFFFFFFFFFFFFFF</default>
      </uint64_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_NX_MMIO_BAR_BASE_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Attribute indicating the target's role</description>
    <hasStringConversion/>
    <id>ROLE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>ROLE</id>
      </enumeration>
    </simpleType>
  </attribute>

  <enumerationType>
    <default>PRIMARY</default>
    <description>Enumeration indicating the master's FSI type</description>
    <enumerator>
      <name>PRIMARY</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>BACKUP</name>
      <value>0</value>
    </enumerator>
    <id>ROLE</id>
  </enumerationType>

  <attribute>
    <description>True or false whether row repair is supported MRW attribute</description>
    <id>ROW_REPAIR_SUPPORTED_MRW</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>UNSUPPORTED</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_ROW_REPAIR_SUPPORTED_MRW</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>True or false whether row repair is supported MRW attribute</description>
    <enumerator>
      <name>SUPPORTED</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>UNSUPPORTED</name>
      <value>0</value>
    </enumerator>
    <id>ROW_REPAIR_SUPPORTED_MRW</id>
  </enumerationType>

  <attribute>
    <description>Set the index into a 64 entry Core Throttle Table to use while in Safe Mode. Legal values are 0 to 63. All others are invalid. Consumer: p10_pstate_parameter_build -&gt; PGPE Hcode -&gt; QME Hcode</description>
    <id>SAFE_MODE_THROTTLE_IDX</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>48</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_SAFE_MODE_THROTTLE_IDX</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Instruction for HB Boatloader to pick the Add-Key Stash Pair from this memory into the exception vector</description>
    <id>SBE_ADDR_KEY_STASH_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_SBE_ADDR_KEY_STASH_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Defines offset to be applied to SBE bootloader installation this will be added with the base address and hostboot HRMOR offset to get the target base address</description>
    <id>SBE_BOOTLOADER_OFFSET</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_SBE_BOOTLOADER_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Defines sbe boot side that will be put into the exception vector if written</description>
    <id>SBE_BOOT_SIDE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_SBE_BOOT_SIDE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Drives whether to update ATTR_PG independently of ATTR_PG_MVPD or to update ATTR_PG equal to ATTR_PG_MVPD during SBE customization. For systems with a service processor that always communicates guarded targets to the SBE via scratch registers, set ATTR_PG_MVPD and ATTR_PG equal to each other to avoid extraneous SBE updates when a target is guarded, otherwise update them independently and potentially go through another SBE update. 0x00: Update ATTR_PG (based on target functional state) and ATTR_PG_MVPD independently of each other 0x01: Update ATTR_PG with the value of ATTR_PG_MVPD</description>
    <id>SBE_CUST_FORCE_MVPD_ONLY</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0x01</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_SBE_CUST_FORCE_MVPD_ONLY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Instruction for exception vector that will be put into the exception vector if not 0</description>
    <id>SBE_HBBL_EXCEPTION_INSTRUCT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_SBE_HBBL_EXCEPTION_INSTRUCT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Enumeration defining the states of an SBE HRESET operation. These values correspond to the values of the PLDM_OEM_IBM_SBE_HRESET_STATE PLDM state set.</description>
    <enumerator>
      <name>UNKNOWN</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>NOT_READY</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>READY</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>FAILED</name>
      <value>3</value>
    </enumerator>
    <id>SBE_HRESET_STATUS</id>
  </enumerationType>

  <attribute>
    <description>Instruction for HB Boatloader to pick the HW Key Hash from this memory</description>
    <id>SBE_HW_KEY_HASH_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_SBE_HW_KEY_HASH_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Control execution of updateProcessorSbeSeeproms() if 0, enable SBE update of processor SEEPROM if 1, disable SBE update of processor SEEPROM Consumer: sbe_update.C Default: 0</description>
    <id>SBE_UPDATE_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <enumerationType>
    <description>Enumeration used in OR expression to indicate why to update SBE.</description>
    <enumerator>
      <description>Just clears the value</description>
      <name>CLEAR</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <description>See targetservicestart for details, if processor is swapped need to update SBE.</description>
      <name>BAR_MISMATCH</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <description>See call_mss_freq for details, if new and old frequency changes need to update SBE.</description>
      <name>MSS_FREQ_CHANGE</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <description>See call_mss_attr_update for details, if topology changes need to update SBE.</description>
      <name>TOPOLOGY_CHECKS</name>
      <value>0x4</value>
    </enumerator>
    <enumerator>
      <description>See call_mss_attr_update for details, if HRMOR outside configured range need to update SBE.</description>
      <name>HRMOR_OUTSIDE_CONFIGURED_MEM</name>
      <value>0x8</value>
    </enumerator>
    <enumerator>
      <description>See call_mss_attr_update for details, if fabric topology changes need to update SBE.</description>
      <name>FABRIC_EFF_TOPOLOGY</name>
      <value>0x10</value>
    </enumerator>
    <id>SBE_UPDATE_TYPE</id>
  </enumerationType>

  <attribute>
    <description>Sector buffer strength</description>
    <id>SECTOR_BUFFER_STRENGTH</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_SECTOR_BUFFER_STRENGTH</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Enumeration indicating the IPMI sensor name, which will be used by hostboot when determining the sensor number to return. The sensor name consists of one byte of sensor type plus one byte of sub-type, to differentiate similar sensors under the same target. Our implementaion uses the IPMI defined entity ID as the sub-type.</description>
    <enumerator>
      <name>PROC_TEMP</name>
      <value>0x0103</value>
    </enumerator>
    <enumerator>
      <name>DIMM_TEMP</name>
      <value>0x0120</value>
    </enumerator>
    <enumerator>
      <name>CORE_TEMP</name>
      <value>0x01D0</value>
    </enumerator>
    <enumerator>
      <name>STATE</name>
      <value>0x0500</value>
    </enumerator>
    <enumerator>
      <name>MEMBUF_TEMP</name>
      <value>0x01D1</value>
    </enumerator>
    <enumerator>
      <name>GPU_TEMP</name>
      <value>0x01D8</value>
    </enumerator>
    <enumerator>
      <name>GPU_MEM_TEMP</name>
      <value>0x01D9</value>
    </enumerator>
    <enumerator>
      <name>VRM_VDD_TEMP</name>
      <value>0x01DA</value>
    </enumerator>
    <enumerator>
      <name>GPU_STATE</name>
      <value>0x17D8</value>
    </enumerator>
    <enumerator>
      <name>PROC_STATE</name>
      <value>0x0703</value>
    </enumerator>
    <enumerator>
      <name>CORE_STATE</name>
      <value>0x07D0</value>
    </enumerator>
    <enumerator>
      <name>HOST_AUTO_REBOOT_CONTROL</name>
      <value>0x0921</value>
    </enumerator>
    <enumerator>
      <name>DIMM_STATE</name>
      <value>0x0C20</value>
    </enumerator>
    <enumerator>
      <name>HB_VOLATILE</name>
      <value>0x0C21</value>
    </enumerator>
    <enumerator>
      <name>MEMBUF_STATE</name>
      <value>0x0CD1</value>
    </enumerator>
    <enumerator>
      <name>FW_BOOT_PROGRESS</name>
      <value>0x0F22</value>
    </enumerator>
    <enumerator>
      <name>SYSTEM_EVENT</name>
      <value>0x1201</value>
    </enumerator>
    <enumerator>
      <name>OS_BOOT</name>
      <value>0x1F23</value>
    </enumerator>
    <enumerator>
      <name>HOST_STATUS</name>
      <value>0x2223</value>
    </enumerator>
    <enumerator>
      <name>OCC_ACTIVE</name>
      <value>0x07D2</value>
    </enumerator>
    <enumerator>
      <name>CORE_FREQ</name>
      <value>0xC1D0</value>
    </enumerator>
    <enumerator>
      <name>APSS_CHANNEL</name>
      <value>0xC2D7</value>
    </enumerator>
    <enumerator>
      <name>PCI_ACTIVE</name>
      <value>0xC423</value>
    </enumerator>
    <enumerator>
      <name>REBOOT_COUNT</name>
      <value>0xC322</value>
    </enumerator>
    <enumerator>
      <name>FAULT</name>
      <value>0xC700</value>
    </enumerator>
    <enumerator>
      <name>BACKPLANE_FAULT</name>
      <value>0xC707</value>
    </enumerator>
    <enumerator>
      <name>REF_CLOCK_FAULT</name>
      <value>0xC7D4</value>
    </enumerator>
    <enumerator>
      <name>PCI_CLOCK_FAULT</name>
      <value>0xC7D5</value>
    </enumerator>
    <enumerator>
      <name>TOD_CLOCK_FAULT</name>
      <value>0xC7D6</value>
    </enumerator>
    <enumerator>
      <name>APSS_FAULT</name>
      <value>0xC7D7</value>
    </enumerator>
    <enumerator>
      <name>VRM_VDD_FAULT</name>
      <value>0xC707</value>
    </enumerator>
    <enumerator>
      <name>DERATING_FACTOR</name>
      <value>0xC815</value>
    </enumerator>
    <enumerator>
      <name>REDUNDANT_PS_POLICY</name>
      <value>0xCA22</value>
    </enumerator>
    <enumerator>
      <name>TURBO_ALLOWED</name>
      <value>0xCB03</value>
    </enumerator>
    <enumerator>
      <name>TPM_REQUIRED</name>
      <value>0xCC03</value>
    </enumerator>
    <enumerator>
      <name>PCI_BIFURCATED</name>
      <value>0xCD03</value>
    </enumerator>
    <enumerator>
      <name>KEY_CLEAR_REQUEST</name>
      <value>0xCDD0</value>
    </enumerator>
    <id>SENSOR_NAME</id>
  </enumerationType>

  <enumerationType>
    <description>Enumeration indicating the IPMI sensor type, these values are defined in the IPMI specification. These values will be used when sending sensor reading events to the BMC.</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TEMPERATURE</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>PROCESSOR</name>
      <value>0x07</value>
    </enumerator>
    <enumerator>
      <name>POWER_UNIT</name>
      <value>0x09</value>
    </enumerator>
    <enumerator>
      <name>MEMORY</name>
      <value>0x0c</value>
    </enumerator>
    <enumerator>
      <name>SYS_FW_PROGRESS</name>
      <value>0x0F</value>
    </enumerator>
    <enumerator>
      <name>SYS_EVENT</name>
      <value>0x12</value>
    </enumerator>
    <enumerator>
      <name>ADDIN_CARD</name>
      <value>0x17</value>
    </enumerator>
    <enumerator>
      <name>OS_BOOT</name>
      <value>0x1F</value>
    </enumerator>
    <enumerator>
      <name>APCI_POWER_STATE</name>
      <value>0x22</value>
    </enumerator>
    <enumerator>
      <name>FREQ</name>
      <value>0xC1</value>
    </enumerator>
    <enumerator>
      <name>POWER</name>
      <value>0xC2</value>
    </enumerator>
    <enumerator>
      <name>BOOT_COUNT</name>
      <value>0xC3</value>
    </enumerator>
    <enumerator>
      <name>PCI_LINK_PRES</name>
      <value>0xC4</value>
    </enumerator>
    <enumerator>
      <name>PWR_LIMIT_ACTIVE</name>
      <value>0xC4</value>
    </enumerator>
    <enumerator>
      <name>FAULT</name>
      <value>0xC7</value>
    </enumerator>
    <id>SENSOR_TYPE</id>
  </enumerationType>

  <attribute>
    <description>Keep skew adjust logic between nest, cores and caches bypassed</description>
    <id>SKEWADJ_BYPASS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_SKEWADJ_BYPASS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Keep skew adjust logic between nest, cores and caches bypassed</description>
    <enumerator>
      <name>BYPASS</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>NO_BYPASS</name>
      <value>0x0</value>
    </enumerator>
    <id>SKEWADJ_BYPASS</id>
  </enumerationType>

  <attribute>
    <description>Controls the enabling and disabling of smf. Used by unit initfiles, p10_mss_eff_grouping.</description>
    <id>SMF_CONFIG</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_SMF_CONFIG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Controls the enabling and disabling of smf. Used by unit initfiles, p10_mss_eff_grouping.</description>
    <enumerator>
      <name>DISABLED</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ENABLED</name>
      <value>0x01</value>
    </enumerator>
    <id>SMF_CONFIG</id>
  </enumerationType>

  <attribute>
    <description>Minimum soft power cap, this is the lowest output power in watts that a user may set. A power cap set below the hard minimum (MIN_POWER_CAP_WATTS) is called a soft power cap and is not guaranteed under all conditions.</description>
    <id>SOFT_MIN_POWER_CAP_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>500</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>SPIPSS Clock Frequency (binary in KHz) Valid range: 500KHz to 2500KHz Consumer: p10_pss_init Overridden by the Machine Readable Workbook. If default of 0 is read, HWP will set SPIPSS frequency to 10MHz.</description>
    <id>SPIPSS_FREQUENCY</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_SPIPSS_FREQUENCY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>See FRU_PATH for description.</description>
    <id>SPI_MVPD_BACKUP_INFO_CALLOUTS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <default/>
        <sizeInclNull>128</sizeInclNull>
      </string>
    </simpleType>
  </attribute>

  <attribute>
    <description>See FRU_PATH for description.</description>
    <id>SPI_MVPD_PRIMARY_INFO_CALLOUTS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <default/>
        <sizeInclNull>128</sizeInclNull>
      </string>
    </simpleType>
  </attribute>

  <attribute>
    <description>See FRU_PATH for description.</description>
    <id>SPI_SBE_BOOT_CODE_BACKUP_INFO_CALLOUTS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <default/>
        <sizeInclNull>128</sizeInclNull>
      </string>
    </simpleType>
  </attribute>

  <attribute>
    <description>See FRU_PATH for description.</description>
    <id>SPI_SBE_BOOT_CODE_PRIMARY_INFO_CALLOUTS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <default/>
        <sizeInclNull>128</sizeInclNull>
      </string>
    </simpleType>
  </attribute>

  <attribute>
    <description>See FRU_PATH for description.</description>
    <id>SPI_TPM_INFO_CALLOUTS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <default/>
        <sizeInclNull>128</sizeInclNull>
      </string>
    </simpleType>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure which defines a system's SP functions. Applicable for System target only. Structure is read-only. Default values match OpenBMC implementation.</description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>If this flag is set then mailboxEnabled MUST also be set 0b0: SP does not support for VPD, payload, ATTR sync, VDDR, TOD; 0b1: SP supports VPD, payload, ATTR sync, VDDR, TOD</description>
        <name>baseServices</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: SP does not initialize FSI slave logic, Hostboot must; 0b1: SP does initialize FSI slave logic so Hostboot should not</description>
        <name>fsiSlaveInit</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: There is no SP mailbox support; 0b1: There is SP mailbox support</description>
        <name>mailboxEnabled</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: SP does not initialize FSI master logic, Hostboot must; 0b1: SP does initialize FSI master logic so Hostboot should not</description>
        <name>fsiMasterInit</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: SP does not perform hardware change detection, Hostboot must; 0b1: SP does perform hardware change detection (HCDB) so Hostboot should not</description>
        <name>hardwareChangeDetection</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: SP does not perform Power Line Disturbance (PLD) detection, Hostboot must; 0b1: SP does perform Power Line Disturbance (PLD) detection so Hostboot should not</description>
        <name>powerLineDisturbance</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>26</bits>
        <default>0</default>
        <description>Reserved for future use</description>
        <name>reserved</name>
        <type>uint32_t</type>
      </field>
    </complexType>
    <description>Attribute which describes what the SP is or is not doing in this system</description>
    <id>SP_FUNCTIONS</id>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>Control CME response to execution of PowerPC STOP instruction if OFF, treat STOP5 as STOP5 if ON, treat STOP5 as STOP4 Producer: ??? Consumer: p8_hcode_image_build.C Platform default: OFF</description>
    <id>STOP5_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_STOP5_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Defines the STOP levels supported by the Hcode in the present driver. Represented as bit vector where bit 0 = STOP0; bit 1 = STOP 1, ..., bit 15 = STOP15.</description>
    <id>STOP_LEVELS_SUPPORTED</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0xB010</default>
      </uint16_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_STOP_LEVELS_SUPPORTED</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <default>NA</default>
    <description>Enumeration indication which Hot Plug Controllers are supported by the current system.</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>MAX5961</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>PCA9551</name>
      <value>0x02</value>
    </enumerator>
    <id>SUPPORTED_HOT_PLUG</id>
  </enumerationType>

  <attribute>
    <description>STOP levels supported at runtime (sent to Host via HDAT): Bit 0: STOP0 Supported - Quiesce thread only Bit 1: STOP1 Supported - P8 Nap Bit 2: STOP2 Supported - P8 Fast Sleep Bit 3: STOP3 Supported - P8 Fast Sleep using iVRMs Bit 4: STOP4 supported - P8 Deep Sleep Bit 5: STOP5 Supported - WOF-friendly "Instant on" Bit 6,7: Reserved Bit 8: STOP8 supported - Half Quad Sleep Bit 9: STOP9 supported - P8 Fast Winkle Bit 10: Reserved Bit 11: STOP11 supported - P8 Deep Winkle Bit 12-15 : Reserved Bits 16..31 - Reserved</description>
    <id>SUPPORTED_STOP_STATES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0xEC100000</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Do we support dynamically updating memory voltages? 0 = no, 1 = yes</description>
    <id>SUPPORTS_DYNAMIC_MEM_VOLT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Attribute indicating the target's software version</description>
    <hasStringConversion/>
    <id>SW_VER</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>SW_VER</id>
      </enumeration>
    </simpleType>
  </attribute>

  <enumerationType>
    <default>BMC_SW_VER</default>
    <description>Enumeration indicating the SW version</description>
    <enumerator>
      <name>FSP_SW_VER</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>BMC_SW_VER</name>
      <value>0x2</value>
    </enumerator>
    <id>SW_VER</id>
  </enumerationType>

  <attribute>
    <description>Defines system specific value of SYS0 refclock receiver termination</description>
    <id>SYS0_REFCLOCK_RCVR_TERM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>NONE</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_SYS0_REFCLOCK_RCVR_TERM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Defines system specific value of SYS0 refclock receiver termination</description>
    <enumerator>
      <name>NONE</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>FIFTY_OHM</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>ONE_HUNDRED_OHM</name>
      <value>0</value>
    </enumerator>
    <id>SYS0_REFCLOCK_RCVR_TERM</id>
  </enumerationType>

  <attribute>
    <description>Defines system specific value of SYS1 refclock receiver termination</description>
    <id>SYS1_REFCLOCK_RCVR_TERM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>NONE</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_SYS1_REFCLOCK_RCVR_TERM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Defines system specific value of SYS1 refclock receiver termination</description>
    <enumerator>
      <name>NONE</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>FIFTY_OHM</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>ONE_HUNDRED_OHM</name>
      <value>0</value>
    </enumerator>
    <id>SYS1_REFCLOCK_RCVR_TERM</id>
  </enumerationType>

  <attribute>
    <description>Brand Name of OEM systems</description>
    <id>SYSTEM_BRAND_NAME</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>This field is of the form "vendor,name" where the name indicates the family of the systems. The textual portion of the string has a maximum length of 63 characters to accommodate a terminating NULL. Both vendor and name fields are lower case US ASCII. No special characters other than ",", "-", and "+" as described below should be used in the string.</description>
    <id>SYSTEM_FAMILY</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <default>ibm,p10-openbmc</default>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
  </attribute>

  <attribute>
    <description>Enable the use of the #V Fmax value within each chip in the system. In this mode, Pstate 0 is determined by finding the maximimum of all #V FMax values. If this attribute is OFF, Pstate 0 is set by the UltraTurbo value that is to be common across all parts in the system as they must be from the same sort. Default: OFF Producer: MRW Consumers: p10_pstate_parameter_block RTC: 269546: remove the FMax Enable mode control Changing the default to ON until the RTC removes all support.</description>
    <id>SYSTEM_FMAX_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>ON</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_FMAX_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Enable the use of the #V Fmax value within each chip in the system. In this mode, Pstate 0 is determined by finding the maximimum of all #V FMax values. If this attribute is OFF, Pstate 0 is set by the UltraTurbo value that is to be common across all parts in the system as they must be from the same sort. Default: OFF Producer: MRW Consumers: p10_pstate_parameter_block RTC: 269546: remove the FMax Enable mode control Changing the default to ON until the RTC removes all support.</description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <id>SYSTEM_FMAX_ENABLE</id>
  </enumerationType>

  <attribute>
    <description>Disables IVRM enablement in the system Producer: Override Consumers: p9_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB) for PGPE/OCC CME Quad Pstate Region (CQPR) for CM Quad Manager</description>
    <id>SYSTEM_IVRM_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_IVRM_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Disables IVRM enablement in the system Producer: Override Consumers: p9_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB) for PGPE/OCC CME Quad Pstate Region (CQPR) for CM Quad Manager</description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <id>SYSTEM_IVRM_DISABLE</id>
  </enumerationType>

  <attribute>
    <description>Time to delay before powering off the MMA due to the lack of MMA instructions. Time = 1ms * 2**ATTR_SYSTEM_MMA_POWEROFF_DELAY_POWEROF2_MS. Valid values of 0x00 - 0x1B to yield times from 1ms to 24 hours -: 0x00 - 1ms ... 0x0A - 1 second (default, 2^10) ... 0x1B - 1 day (2^27) 0x1C - 0xFD - Reserved (maps as 0x1C) 0xFE - every QME FIT timer interrupt (~250us) 0xFF - no power off of MMA (QME Hcode still runs; different behavior ATTR_SYSTEM_MMA_POWEROFF_DISABLE) Producer: Machine Readable Workbook Consumer: QME Hcode</description>
    <id>SYSTEM_MMA_POWEROFF_DELAY_POWEROF2_MS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0xA</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_MMA_POWEROFF_DELAY_POWEROF2_MS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Debug modes supported for QME Scan layout in HOMER.</description>
    <id>SYSTEM_RING_DBG_MODE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_RING_DBG_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Debug modes supported for QME Scan layout in HOMER.</description>
    <enumerator>
      <name>SCAN_RING_NO_DEBUG</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>SCAN_RING_TRACE_DEBUG</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>SCAN_RING_DEEP_DEBUG</name>
      <value>0x02</value>
    </enumerator>
    <id>SYSTEM_RING_DBG_MODE</id>
  </enumerationType>

  <attribute>
    <description>Limits the number of Pstates below the frequency floor that can be used for throttling. Valid responsive values: 0 to 63. Values above 63 will be capped to 63. Consumer: p10_pstate_parameter_build -&gt; OCC Parameter Block</description>
    <id>SYSTEM_THROTTLE_PSTATE_NUMBER_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_THROTTLE_PSTATE_NUMBER_LIMIT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>This field is of the form ?vendor,type? where the type indicates a type of system within the System Family. The textual portion of the string has a maximum length of 63 characters to accommodate a terminating NULL. Both vendor and name fields are lower case US ASCII. No special characters other than ",", "-", and "+" as described below should be used in the string. If identification of specific models within a system type is desired, "-model" should be appended to the end of the name. The "-model" portion is optional and could be used to identify the packaging, specific model numbers, etc. NOTE: No Hostboot code should ever key off of this value.</description>
    <id>SYSTEM_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <default>ibm,rainier</default>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
  </attribute>

  <attribute>
    <description>Disables the enablement of Voltage Droop Monitors (VDM) in the system. Producer: MRW Consumers: p9_pstate_parameter_block to clear flag for CME QuadManager Hcode reaction</description>
    <id>SYSTEM_VDM_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>OFF</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_VDM_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Disables the enablement of Voltage Droop Monitors (VDM) in the system. Producer: MRW Consumers: p9_pstate_parameter_block to clear flag for CME QuadManager Hcode reaction</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <id>SYSTEM_VDM_DISABLE</id>
  </enumerationType>

  <enumerationType>
    <description>Determine whether planar or processor should take care of outgoing refclock near-end termination.</description>
    <enumerator>
      <name>PLANAR</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>PROC</name>
      <value>1</value>
    </enumerator>
    <id>SYS_CLK_NE_TERMINATION_SITE</id>
  </enumerationType>

  <attribute>
    <description>Per-region drive strength selection for near-end termination. Drive strength can be selected between 20 mA and 40 mA for all optics clocks as a group, and for almost each PCIe slot clock individually (PCI1 slot B+C are grouped together).</description>
    <id>SYS_CLK_NE_TERMINATION_STRENGTH</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>20MA</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_SYS_CLK_NE_TERMINATION_STRENGTH</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Per-region drive strength selection for near-end termination. Drive strength can be selected between 20 mA and 40 mA for all optics clocks as a group, and for almost each PCIe slot clock individually (PCI1 slot B+C are grouped together).</description>
    <enumerator>
      <name>20MA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>OP_40MA</name>
      <value>0x80</value>
    </enumerator>
    <enumerator>
      <name>PCI0A_40MA</name>
      <value>0x40</value>
    </enumerator>
    <enumerator>
      <name>PCI0B_40MA</name>
      <value>0x20</value>
    </enumerator>
    <enumerator>
      <name>PCI0C_40MA</name>
      <value>0x10</value>
    </enumerator>
    <enumerator>
      <name>PCI1A_40MA</name>
      <value>0x08</value>
    </enumerator>
    <enumerator>
      <name>PCI1BC_40MA</name>
      <value>0x04</value>
    </enumerator>
    <id>SYS_CLK_NE_TERMINATION_STRENGTH</id>
  </enumerationType>

  <attribute>
    <description>Enables pstate parameter block code to use the static system vfrt data Consumer: p9_pstate_parameter_block.C -&gt; Platform default: OFF</description>
    <id>SYS_VFRT_STATIC_DATA_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_SYS_VFRT_STATIC_DATA_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Enables pstate parameter block code to use the static system vfrt data Consumer: p9_pstate_parameter_block.C -&gt; Platform default: OFF</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>VDN_STEP_OFF</name>
      <value>0x02</value>
    </enumerator>
    <id>SYS_VFRT_STATIC_DATA_ENABLE</id>
  </enumerationType>

  <attribute>
    <description>Enables pstate parameter block code to use the static system vrt data Consumer: p10_pstate_parameter_build.C -&gt; PGPE Hcode Platform default:OFF</description>
    <id>SYS_VRT_STATIC_DATA_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_SYS_VRT_STATIC_DATA_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Enables pstate parameter block code to use the static system vrt data Consumer: p10_pstate_parameter_build.C -&gt; PGPE Hcode Platform default:OFF</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>VDN_STEP_OFF</name>
      <value>0x02</value>
    </enumerator>
    <id>SYS_VRT_STATIC_DATA_ENABLE</id>
  </enumerationType>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an I2C slave device.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux will connect to. OxFF indicates no mux present or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address an I2C slave device</description>
    <id>TEMP_SENSOR_I2C_CONFIG</id>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>Kill-switch to withhold the use of TPM if any problem is found. HB code will not be updating this attribute. 0: TPM is not enabled 1: TPM is enabled</description>
    <id>TPM_ENABLED</id>
    <persistency>non-volatile</persistency>
    <range>
      <max>1</max>
      <min>0</min>
    </range>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Indicates TPM Model (or family) for a TPM Target 0x00 = Undetermined (reserved if actively detected in the future) 0x01 = Nuvoton 65x (default) 0x02 = Nuvoton 75x</description>
    <id>TPM_MODEL</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Setting to require(0x1) or not require(0x0) a functional TPM to boot the system.</description>
    <id>TPM_REQUIRED</id>
    <persistency>non-volatile</persistency>
    <range>
      <max>1</max>
      <min>0</min>
    </range>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>At-speed SPI bus divider for the TPM during measurement SEEPROM execution bits 0:11 - clock divider; fSPI = fPAU / 8 / (divider + 1); minimum allowed value is 4 bits 12:15 - receiver delay in fPAU/4 cycles; allowed range 0..7</description>
    <id>TPM_SPI_BUS_DIV</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0x00A7</default>
      </uint16_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_TPM_SPI_BUS_DIV</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Attribute indicating the target's type</description>
    <hasStringConversion/>
    <id>TYPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>TYPE</id>
      </enumeration>
    </simpleType>
  </attribute>

  <enumerationType>
    <default>NA</default>
    <description>Enumeration indicating the target's type</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>SYS</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>NODE</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>DIMM</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>MEMBUF</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>PROC</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>EX</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>CORE</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>L2</name>
      <value>8</value>
    </enumerator>
    <enumerator>
      <name>L3</name>
      <value>9</value>
    </enumerator>
    <enumerator>
      <name>L4</name>
      <value>10</value>
    </enumerator>
    <enumerator>
      <name>MCS</name>
      <value>11</value>
    </enumerator>
    <enumerator>
      <name>MBA</name>
      <value>13</value>
    </enumerator>
    <enumerator>
      <name>XBUS</name>
      <value>14</value>
    </enumerator>
    <enumerator>
      <name>ABUS</name>
      <value>15</value>
    </enumerator>
    <enumerator>
      <name>PCI</name>
      <value>16</value>
    </enumerator>
    <enumerator>
      <name>DPSS</name>
      <value>17</value>
    </enumerator>
    <enumerator>
      <name>APSS</name>
      <value>18</value>
    </enumerator>
    <enumerator>
      <name>OCC</name>
      <value>19</value>
    </enumerator>
    <enumerator>
      <name>PSI</name>
      <value>20</value>
    </enumerator>
    <enumerator>
      <name>FSP</name>
      <value>21</value>
    </enumerator>
    <enumerator>
      <name>PNOR</name>
      <value>22</value>
    </enumerator>
    <enumerator>
      <name>OSC</name>
      <value>23</value>
    </enumerator>
    <enumerator>
      <name>TODCLK</name>
      <value>24</value>
    </enumerator>
    <enumerator>
      <name>CONTROL_NODE</name>
      <value>25</value>
    </enumerator>
    <enumerator>
      <name>OSCREFCLK</name>
      <value>26</value>
    </enumerator>
    <enumerator>
      <name>OSCPCICLK</name>
      <value>27</value>
    </enumerator>
    <enumerator>
      <name>REFCLKENDPT</name>
      <value>28</value>
    </enumerator>
    <enumerator>
      <name>PCICLKENDPT</name>
      <value>29</value>
    </enumerator>
    <enumerator>
      <name>NX</name>
      <value>30</value>
    </enumerator>
    <enumerator>
      <name>PORE</name>
      <value>31</value>
    </enumerator>
    <enumerator>
      <name>PCIESWITCH</name>
      <value>32</value>
    </enumerator>
    <enumerator>
      <name>CAPP</name>
      <value>33</value>
    </enumerator>
    <enumerator>
      <name>FSI</name>
      <value>34</value>
    </enumerator>
    <enumerator>
      <name>EQ</name>
      <value>35</value>
    </enumerator>
    <enumerator>
      <name>MCA</name>
      <value>36</value>
    </enumerator>
    <enumerator>
      <name>MCBIST</name>
      <value>37</value>
    </enumerator>
    <enumerator>
      <name>MI</name>
      <value>38</value>
    </enumerator>
    <enumerator>
      <name>DMI</name>
      <value>39</value>
    </enumerator>
    <enumerator>
      <name>OBUS</name>
      <value>40</value>
    </enumerator>
    <enumerator>
      <name>SBE</name>
      <value>42</value>
    </enumerator>
    <enumerator>
      <name>PPE</name>
      <value>43</value>
    </enumerator>
    <enumerator>
      <name>PERV</name>
      <value>44</value>
    </enumerator>
    <enumerator>
      <name>PEC</name>
      <value>45</value>
    </enumerator>
    <enumerator>
      <name>PHB</name>
      <value>46</value>
    </enumerator>
    <enumerator>
      <name>SYSREFCLKENDPT</name>
      <value>47</value>
    </enumerator>
    <enumerator>
      <name>MFREFCLKENDPT</name>
      <value>48</value>
    </enumerator>
    <enumerator>
      <name>TPM</name>
      <value>49</value>
    </enumerator>
    <enumerator>
      <name>SP</name>
      <value>50</value>
    </enumerator>
    <enumerator>
      <name>UART</name>
      <value>51</value>
    </enumerator>
    <enumerator>
      <name>PS</name>
      <value>52</value>
    </enumerator>
    <enumerator>
      <name>FAN</name>
      <value>53</value>
    </enumerator>
    <enumerator>
      <name>VRM</name>
      <value>54</value>
    </enumerator>
    <enumerator>
      <name>USB</name>
      <value>55</value>
    </enumerator>
    <enumerator>
      <name>ETH</name>
      <value>56</value>
    </enumerator>
    <enumerator>
      <name>PANEL</name>
      <value>57</value>
    </enumerator>
    <enumerator>
      <name>BMC</name>
      <value>58</value>
    </enumerator>
    <enumerator>
      <name>FLASH</name>
      <value>59</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM</name>
      <value>60</value>
    </enumerator>
    <enumerator>
      <name>TMP</name>
      <value>61</value>
    </enumerator>
    <enumerator>
      <name>GPIO_EXPANDER</name>
      <value>62</value>
    </enumerator>
    <enumerator>
      <name>POWER_SEQUENCER</name>
      <value>63</value>
    </enumerator>
    <enumerator>
      <name>RTC</name>
      <value>64</value>
    </enumerator>
    <enumerator>
      <name>FANCTLR</name>
      <value>65</value>
    </enumerator>
    <enumerator>
      <name>OBUS_BRICK</name>
      <value>66</value>
    </enumerator>
    <enumerator>
      <name>NPU</name>
      <value>67</value>
    </enumerator>
    <enumerator>
      <name>MC</name>
      <value>68</value>
    </enumerator>
    <enumerator>
      <name>TEST_FAIL</name>
      <value>69</value>
    </enumerator>
    <enumerator>
      <name>MFREFCLK</name>
      <value>70</value>
    </enumerator>
    <enumerator>
      <name>SMPGROUP</name>
      <value>71</value>
    </enumerator>
    <enumerator>
      <name>OMI</name>
      <value>72</value>
    </enumerator>
    <enumerator>
      <name>MCC</name>
      <value>73</value>
    </enumerator>
    <enumerator>
      <name>OMIC</name>
      <value>74</value>
    </enumerator>
    <enumerator>
      <name>OCMB_CHIP</name>
      <value>75</value>
    </enumerator>
    <enumerator>
      <name>MEM_PORT</name>
      <value>76</value>
    </enumerator>
    <enumerator>
      <name>I2C_MUX</name>
      <value>77</value>
    </enumerator>
    <enumerator>
      <name>PMIC</name>
      <value>78</value>
    </enumerator>
    <enumerator>
      <name>NMMU</name>
      <value>79</value>
    </enumerator>
    <enumerator>
      <name>PAU</name>
      <value>80</value>
    </enumerator>
    <enumerator>
      <name>IOHS</name>
      <value>81</value>
    </enumerator>
    <enumerator>
      <name>PAUC</name>
      <value>82</value>
    </enumerator>
    <enumerator>
      <name>FC</name>
      <value>83</value>
    </enumerator>
    <enumerator>
      <name>LPCREFCLKENDPT</name>
      <value>84</value>
    </enumerator>
    <enumerator>
      <name>GENERIC_I2C_DEVICE</name>
      <value>85</value>
    </enumerator>
    <enumerator>
      <name>MDS_CTLR</name>
      <value>86</value>
    </enumerator>
    <enumerator>
      <name>DCM</name>
      <value>87</value>
    </enumerator>
    <enumerator>
      <name>LAST_IN_RANGE</name>
      <value>88</value>
    </enumerator>
    <id>TYPE</id>
  </enumerationType>

  <attribute>
    <description>Indicator to Host Firmware to use the 11S SPD data for Part Number and Serial Number in DDIMM SPD instead of the standard location.</description>
    <id>USE_11S_SPD</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Memory VCS voltage domain ID. All memory buffers in the same VCS voltage domain will share the same ID. IDs are arbitrarily assigned, used for correlation between HB + HWSV, and are generated by MRW processing scripts.</description>
    <id>VCS_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Memory VDD voltage domain ID. All memory buffers in the same VDD voltage domain will share the same ID. IDs are arbitrarily assigned, used for correlation between HB + HWSV, and are generated by MRW processing scripts.</description>
    <id>VDD_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <enumerationType>
    <description>Enumeration for Voltage Drop Monitor enable</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <id>VDM_ENABLE</id>
  </enumerationType>

  <attribute>
    <description>Voltage (in mV) to uplift the VDN rail if the #V PAU frequency is 205OMHz. This value is present in early sorted parts where extra voltage margin is needed. Consumer: p10_setup_evid.C Producer: Machine Readable Workbook</description>
    <id>VDN_UPLIFT_MV</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>25</default>
      </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_VDN_UPLIFT_MV</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Memory VPP voltage domain ID. All memory buffers in the same VPP voltage domain will share the same ID. IDs are arbitrarily assigned, used for correlation between HB + HWSV, and are generated by MRW processing scripts.</description>
    <id>VPP_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>VRM Vdd Temperature in degrees C to invoke DVFS (clip max Pstate)</description>
    <id>VRM_VDD_DVFS_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>85</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>VRM Vdd Temperature in degrees C that an overtemp error will be logged</description>
    <id>VRM_VDD_ERROR_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>95</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Maximum time in seconds allowed without having a new VRM Vdd temperature before DVFS will occur</description>
    <id>VRM_VDD_READ_TIMEOUT_SEC</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>5</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>If wof_enabled, defines the Frequency Ratio calculation performed. (THIS IS NOT SUPPORTED IN P9 GA1!).</description>
    <id>WOF_ENABLE_FRATIO</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_WOF_ENABLE_FRATIO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>If wof_enabled, defines the Frequency Ratio calculation performed. (THIS IS NOT SUPPORTED IN P9 GA1!).</description>
    <enumerator>
      <name>FIXED</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>STEPPED</name>
      <value>1</value>
    </enumerator>
    <id>WOF_ENABLE_FRATIO</id>
  </enumerationType>

  <attribute>
    <description>If wof_enabled, defines the Voltage Ratio calculation performed. THIS IS NOT SUPPORTED AT PRESENT. GA1 SUPPORT IS TBD).</description>
    <id>WOF_ENABLE_VRATIO</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_WOF_ENABLE_VRATIO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>If wof_enabled, defines the Voltage Ratio calculation performed. THIS IS NOT SUPPORTED AT PRESENT. GA1 SUPPORT IS TBD).</description>
    <enumerator>
      <name>FIXED</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>CALCULATED</name>
      <value>1</value>
    </enumerator>
    <id>WOF_ENABLE_VRATIO</id>
  </enumerationType>

  <attribute>
    <description>Selects the WOF table from a set of WOF tables Valid values: 0, 1, 2 Consumers: Hostboot firmware</description>
    <id>WOF_INDEX_SELECT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_WOF_INDEX_SELECT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>The base TDP power (in 0.01W units) of AVDD, VPCI, and VDN rails that don't vary with I/O configuration. The value comes from the maximum power assumed for the system during WOF table generation minus the computed link power based on the VIO voltage for the system TDP configuration. The value represented is the per socket configuration that supports 4 node operation. Each dimension assumes a different value for the VIO rail. [index] -&gt;2 entries-: 0: 1.0V; 1: 0.9V; 2: Reserved; 3: Reserved; Producer: Machine Readable Workbook Consumers: p10_hcode_image_build -&gt; XGPE Hcode</description>
    <id>WOF_IO_BASE_POWER_0P01W</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint16_t>
        <default>1721,2482,0,0</default>
      </uint16_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_WOF_IO_BASE_POWER_0P01W</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>System control to set the power limit for Workload Optimized Frequency (WOF) algorithms. This is used to select the proper VFRT tables. Producer: TMGT Consumers: FW that selects VFRT tables</description>
    <id>WOF_POWER_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable/>
  </attribute>

  <enumerationType>
    <description>Enumeration to select WOF Power Limit</description>
    <enumerator>
      <name>NOMINAL</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TURBO</name>
      <value>1</value>
    </enumerator>
    <id>WOF_POWER_LIMIT</id>
  </enumerationType>

  <attribute>
    <description>LID id used to load tables for Workload Optimized Frequency (WOF) algorithms. Producer: TMGT Consumers: FW that selects VFRT tables</description>
    <id>WOF_TABLE_LID_NUMBER</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0x81E00440</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>If wof_enabled AND ATTR_WOF_ENABLE_VRATIO = CALCULATED, this attribute selects the Vratio calculation type. ACTIVE_CORES: Vratio is the number of active cores to the number of good cores FULL: Vratio is Vaverage to Vclip(Fclip) where Vclip(Fclip) is the normal interpolated regulator voltage (including load line uplife @ RDP current) derated with presently measured Idd current (from the AVSBus) and the loadline.</description>
    <id>WOF_VRATIO_SELECT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_WOF_VRATIO_SELECT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>If wof_enabled AND ATTR_WOF_ENABLE_VRATIO = CALCULATED, this attribute selects the Vratio calculation type. ACTIVE_CORES: Vratio is the number of active cores to the number of good cores FULL: Vratio is Vaverage to Vclip(Fclip) where Vclip(Fclip) is the normal interpolated regulator voltage (including load line uplife @ RDP current) derated with presently measured Idd current (from the AVSBus) and the loadline.</description>
    <enumerator>
      <name>ACTIVE_CORES</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>FULL</name>
      <value>1</value>
    </enumerator>
    <id>WOF_VRATIO_SELECT</id>
  </enumerationType>

</attributes>
