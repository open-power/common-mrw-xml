<attributes>
  <attribute>
    <description>The frequency of the processor refclock in kHz. Provided by the Machine Readable Workbook. This can be overridden to adjust the refclock frequency.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_PROC_REFCLOCK_KHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_PROC_REFCLOCK_KHZ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>133333</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>The frequency of the memory refclock in MHz. Provided by the Machine Readable Workbook. This is read by the set_ref_clock HWP to find out the desired frequency. This can be overridden to adjust the refclock frequency.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_MEM_REFCLOCK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_MEM_REFCLOCK</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Maximum frequency (in MHz) that this system can run the DIMMs at. There are 5 possible values determined by the dimm configuration. For configurations which have mixed rank configurations, the lowest frequency based on ranks of either DIMM is chosen. For example if there was a 1R and a 2R DIMM installed, and 1R dual drop was a lower max freq than 2R dual drop, then the 1R max freq would be the max allowed. [0]=One rank, single drop [1]=Two rank, single drop [2]=Four rank, single drop [3]=One rank, dual drop [4]=Two rank, dual drop A value of zero would indicate an unsupported configuration. Note: Do not use this attribute to limit configurations, it is not checked during plug rules. If you have an unsupported configuration, use the value 0 as the maximum freq.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MAX_ALLOWED_DIMM_FREQ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MAX_ALLOWED_DIMM_FREQ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>5</array>
      <uint32_t>
        <default>2400,2400,2400,2400,2400</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Specify the system policy to enforce synchronous mode between memory and nest. This drives the value of ATTR_MEM_IN_SYNCH_MODE. UNDETERMINED : Run synchronously if the dimm and nest freq matches ALWAYS : Require matching frequencies and deconfigure memory that does not match the nest NEVER : Do not run synchronously, even if the frequencies match</description>
    <hwpfToHbAttrMap>
      <id>ATTR_REQUIRED_SYNCH_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>REQUIRED_SYNCH_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook safe mode throttle value for numerator cfg_nm_n_per_port Set to below optimum value/ rate. On a per port (MCA) basis Also used for emergency mode throttle MBA_FARB4Q_EMERGENCY_N Used to thermally protect the system in all supported environmental conditions when OCC is not functional Consumer: thermal_init, initfile</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>32</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook Thermal Memory Power Limit Used to calculate throttles to be at or under the power limit Per DIMM basis KEY (0-19): In order DIMM_SIZE = bits 0-3, DIMM_GEN = 4-5, DIMM_TYPE = 6-7, DIMM_WIDTH = 8-10, DIMM_DENSITY = 11-13, DIMM_STACK_TYPE = 14-15, DRAM_MFGID = 16-18, DIMMS_PER_PORT = 19-20, Bits 21-32: Not used VALUE (bits 32-63) in cW: VMEM+VPP thermal power limit per DIMM = 32-63 Consumers: eff_config_thermal and bulk_pwr_throttles</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_THERMAL_MEMORY_POWER_LIMIT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_THERMAL_MEMORY_POWER_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>10</array>
      <uint64_t>
        <default>0xffffe000000006a4,0,0,0,0,0,0,0,0,0</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook Power Curve Intercept for DIMM Used to get the VDDR and VDDR+VPP power curve for each DIMM Decoded and used to set ATTR_MSS_TOTAL_PWR_INTERCEPT Key Value pair KEY (0-19): In order DIMM_SIZE = bits 0-3, DIMM_GEN = 4-5, DIMM_TYPE = 6-7, DIMM_WIDTH = 8-10, DIMM_DENSITY = 11-13, DIMM_STACK_TYPE = 14-15, DRAM_MFGID = 16-18, DIMMS_PER_PORT = 19-20, Bits 21-32: Not used VALUE (bits 32-63) in cW: VMEM power curve = 32-47 VMEM+VPP power curve = 48-63 Consumers: eff_config_thermal</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_PWR_INTERCEPT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_PWR_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>100</array>
      <uint64_t>
        <default>0xffffe00002CC03AE,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook Power Curve Slope for DIMM Used to get the VDDR and VDDR+VPP power curve for each DIMM Decoded and used to set ATTR_MSS_TOTAL_PWR_INTERCEPT Key Value pair KEY (0-19): In order DIMM_SIZE = bits 0-3, DIMM_GEN = 4-5, DIMM_TYPE = 6-7, DIMM_WIDTH = 8-10, DIMM_DENSITY = 11-13, DIMM_STACK_TYPE = 14-15, DRAM_MFGID = 16-18, DIMMS_PER_PORT = 19-20, Bits 21-32: Not used VALUE (bits 32-63) in cW: VMEM power curve = 32-47 VMEM+VPP power curve = 48-63 Consumers: eff_config_thermal</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_PWR_SLOPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_PWR_SLOPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>100</array>
      <uint64_t>
        <default>0xffffe00003FD0546,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook Refresh Rate Desired refresh interval used in refresh register 0, MBAREF0Q_CFG_REFRESH_INTERVAL 7.8 us (SINGLE) 3.9 us (DOUBLE) 7.02 us (SINGLE_10_PERCENT_FASTER) 3.51 us (DOUBLE_10_PERCENT_FASTER)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_REFRESH_RATE_REQUEST</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_REFRESH_RATE_REQUEST</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook DIMM power curve percent uplift for this system at max utilization. Value should be 0 for ISDIMMs</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook DIMM power curve percent uplift for this system at idle utilization. Value should be 0 for ISDIMMs</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook for the number of M DRAM clocks. One approach to curbing DRAM power usage is by throttling traffic through a programmable N commands over M window.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_MEM_M_DRAM_CLOCKS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_MEM_M_DRAM_CLOCKS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x00000200</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook value for maximum dram data bus utilization in centi percent (c%). Used to determine memory throttle values. Max databus utilization on a per port basis Default to 90%</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_MAX_DRAM_DATABUS_UTIL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_MAX_DRAM_DATABUS_UTIL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x00002328</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Option to control MCS prefetch retry threshold, for performance optimization. This attribute controls the number of retries in the prefetch engine. Retry threshold available ranges from 16 to 30. Note: Values outside those ranges will default to 30. In MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_MCS_PREFETCH_RETRY_THRESHOLD</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_MCS_PREFETCH_RETRY_THRESHOLD</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Memory power control settings programmed during IPL Used by OCC when exiting idle power-save mode</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_POWER_CONTROL_REQUESTED</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_POWER_CONTROL_REQUESTED</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>OFF</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Memory power control settings for IDLE powersave mode Used by OCC when entering idle power-save mode</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_IDLE_POWER_CONTROL_REQUESTED</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_IDLE_POWER_CONTROL_REQUESTED</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>OFF</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook enablement of the HWP code to adjust the VMEM regulator power limit based on number of installed DIMMs.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook VMEM regulator power limit per CDIMM assuming a full configuration. Units in cW Used for Cumulus Consumed in mss_eff_config_thermal</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR3</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR3</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook VMEM regulator power limit per DIMM assuming a full configuration. Units in cW Consumed in mss_eff_config_thermal</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR4</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR4</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x000006A4</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook value for the maximum possible number of dimms that can be installed under any of the VMEM regulators. Consumed in eff_config_thermal to calculate mem_watt_target</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Used for to determine whether to apply an offset to AVDD. Supplied by MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_AVDD_OFFSET_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_AVDD_OFFSET_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Used for to determine whether to apply an offset to VDD. Supplied by MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_VDD_OFFSET_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_VDD_OFFSET_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Used for to determine whether to apply an offset to VCS. Supplied by MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_VCS_OFFSET_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_VCS_OFFSET_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Used for to determine whether to apply an offset to VCS. Supplied by MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_VPP_OFFSET_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_VPP_OFFSET_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Used for to determine whether to apply an offset to VDDR. Supplied by MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_VDDR_OFFSET_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_VDDR_OFFSET_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Fine refresh mode. Sets DDR4 MRS3. ZZ uses normal mode. From JEDEC DDR4 Spec 1716.78C from 07-2016 Page 47 Table 4.9.1</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_FINE_REFRESH_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_FINE_REFRESH_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>NORMAL</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Temperature refresh range. Sets DDR4 MRS4. Should be defaulted to extended range. NORMAL for running at 85 degrees C or less, EXTENDED for 95 or less degrees C Used for calculating periodic refresh intervals JEDEC DDR4 spec 1716.78C from 07-2016 page 46 4.8.1</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_TEMP_REFRESH_RANGE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_TEMP_REFRESH_RANGE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>For resetting the phy delay values at the beginning of calling mss_draminit_training. YES means the vaules will be reset.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_RESET_DELAY_BEFORE_CAL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_RESET_DELAY_BEFORE_CAL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>YES</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of on or off. Determines if prefetching enabled or not.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_PREFETCH_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_PREFETCH_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of on or off. Determines if the cleaner of the L4 cache (write modified entries to memory on idle cycles) enabled or not. See chapter 7 of the Centaur Workbook.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_CLEANER_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_CLEANER_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>OFF</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Describes the settings for periodic calibration for all ports: Reading left to right. (DEFAULT: 0xD90C -&gt; Byte 0(11011001), Byte 1(00001100)) For each bit: OFF = 0, ON = 1. Setting to 0 indicates to disable periodic memcal. Byte 0: 0: ZCAL 1: SYSCK_ALIGN 2: RDCENTERING 3: RDLCK_ALIGN 4: DQS_ALIGN 5: RDCLK_UPDATE 6: PER_DUTYCYCLE 7: PERCAL_PWR_DIS Byte 1: 0: PERCAL_REPEAT 1: PERCAL_REPEAT 2: PERCAL_REPEAT 3: SINGLE_BIT_MPR 4: MBA_CFG_0 5: MBA_CFG_1 6: SPARE 7: SPARE</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_PERIODIC_MEMCAL_MODE_OPTIONS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_PERIODIC_MEMCAL_MODE_OPTIONS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0xD90C</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Describes the settings for periodic ZQ calibration for all ports: Reading left to right. For each bit: OFF = 0, ON = 1. Setting to 0 indicates to disable periodic zqcal. Byte 0: 0: ZQCAL All others reserved for future use</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_PERIODIC_ZQCAL_MODE_OPTIONS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_PERIODIC_ZQCAL_MODE_OPTIONS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0x8000</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Allows user to manually turn on and off 2N Mode. AUTO indicates to use Signal Integrity generated setting (from VPD).</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_DRAM_2N_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_DRAM_2N_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>AUTO</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>List of memory frequencies supported by the current system.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_SUPPORTED_FREQ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_SUPPORTED_FREQ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint32_t>
        <default>1866,2133,2400,2667</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Each MCA value is a 64-bit vector, where each byte represents an unsupported rank configuration. Each nibble in the byte represents the total count of ranks (master and slave) on each DIMM. The left-most nibble represents slot 0 and the right represents 1.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_UNSUPPORTED_RANK_CONFIG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_UNSUPPORTED_RANK_CONFIG</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint64_t>
        <default>0</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Enables DRAM Write CRC</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_DRAM_WRITE_CRC</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_DRAM_WRITE_CRC</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Used in MR4 A3 Temperature refresh mode Should be defaulted to disable</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_TEMP_REFRESH_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_TEMP_REFRESH_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>An override switch to shut off broadcast mode Enum values: YES: broadcast mode is forced off NO: broadcast mode uses the default value</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_FORCE_BCMODE_OFF</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_FORCE_BCMODE_OFF</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>A bitmap containing the plug rules for NVDIMM. 1 if a DIMM supports an NVDIMM being plugged in, 0 if it does not DIMM slot 0 is the left most bit The index to the bitmap is the position of the DIMM target As such, a bitmap of 0b10010000, would allow NVDIMM plugged into DIMM0 and DIMM3 Note: this attribute is a 64 bit number to account for 16 DIMM per processor if there is ever a 4 processor system</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_NVDIMM_PLUG_RULES</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_NVDIMM_PLUG_RULES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Switch that allows unsupported raw card references by providing a default raw card setting.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_ALLOW_UNSUPPORTED_RCW</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_ALLOW_UNSUPPORTED_RCW</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Bitmap of DRAM widths supported by a system. A 1 indicates that the system supports a density. Enums below represent the the bit location in the attribute for a given DRAM width. Default value is 0xC -&gt; both x4/x8 supported</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_SUPPORTED_DRAM_WIDTH</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_SUPPORTED_DRAM_WIDTH</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0xc0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>True or false whether row repair is supported MRW attribute</description>
    <hwpfToHbAttrMap>
      <id>ATTR_ROW_REPAIR_SUPPORTED_MRW</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>ROW_REPAIR_SUPPORTED_MRW</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>UNSUPPORTED</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>The frequency of a processor's nest mesh clock, in MHz. This is the same for all chips in the system. Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_PB_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_PB_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>The frequency of a processor's Obus mesh clocks, in MHz. Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_O_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_O_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint32_t>
        <default>1611,1611,1611,1611</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>The frequency of a processor's Abus, in MHz. This is the same for all chips in the system. Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_A_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_A_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x1900</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>The frequency of a processor's Xbus mesh clocks, in MHz. This is the same for all chips in the system.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_X_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_X_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>2000</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Frequency (in MHz) to move to if the Power Management function fails. This is the same for all cores in the system. Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PM_SAFE_FREQUENCY_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PM_SAFE_FREQUENCY_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Voltage (in mV) to move to if the Power Management function fails. Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PM_SAFE_VOLTAGE_MV</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PM_SAFE_VOLTAGE_MV</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>The frequency of a processor's PCI-e bus in MHz. This is the same for all PCI-e busses in the system. Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_PCIE_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_PCIE_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>MRW control to permit Normal (100 MHz) or Slow (94 MHz) operation of PCIE reference clock. On Nimbus DD1 HW, Slow operation is required to achieve Gen4 operation. Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_DD1_SLOW_PCI_REF_CLOCK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DD1_SLOW_PCI_REF_CLOCK</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Processor SMP A bus width. Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_A_BUS_WIDTH</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_A_BUS_WIDTH</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>4_BYTE</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Processor SMP X bus width. Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_X_BUS_WIDTH</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_X_BUS_WIDTH</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>4_BYTE</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Processor SMP Fabric broadcast scope configuration. CHIP_IS_NODE = MODE1 = default CHIP_IS_GROUP = MODE2 Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_PUMP_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_PUMP_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Processor SMP topology configuration. 0 = default = 1 or 2 hop topology (PHYP image spans system) Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_CCSM_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_CCSM_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Per-link optics configuration 0 = default = SMP 1 = CAPI 2.0 2 = NV 2.0 3 = OPENCAPI Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_OPTICS_CONFIG_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>OPTICS_CONFIG_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>NV</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Processor SMP optics mode. 0 = default = Optics_is_X_bus 1 = Optics_is_A_bus Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_SMP_OPTICS_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_SMP_OPTICS_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>OPTICS_IS_X_BUS</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Processor CAPI attachement protocol mode. 0 = default = no: SMPA CAPI attachement 1 = yes: SMPA CAPI attachement Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_CAPI_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_CAPI_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>OFF</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Logical fabric system ID associated with this chip. Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_SYSTEM_ID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_SYSTEM_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Processor epsilon table type. Used to calculate the processor nest epsilon register values. Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_EPS_TABLE_TYPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_EPS_TABLE_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Define DMI Ref clock/Swizzle for Centaur. Mapper from DMI unit id -&gt; ROOT CNTL 6 refclk drive enable bit consumer: p9_cen_ref_clk_enable</description>
    <hwpfToHbAttrMap>
      <id>ATTR_DMI_REFCLOCK_SWIZZLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DMI_REFCLOCK_SWIZZLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Used in the setting of groups. It is a bit vector. If the value BITWISE_AND 0x01 = 0x01 then groups of 1 are enabled, if the value BITWISE_AND 0x02 = 0x02, then groups of 2 are possible, if the value BITWISE_AND 0x04 = 0x04, then group of 3 are possible, if the value BITWISE_AND 0x08 = 0x08, then groups of 4 are possible, if the value BITWISE_AND 0x20 = 0x20, then groups of 6 are possible, if the value BITWISE_AND 0x80 = 0x80, then groups of 8 are possible. If no groups can formed according to this input, then an error will be thrown. Provided by the MRW</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_INTERLEAVE_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_INTERLEAVE_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0xAF</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Determines the stride covered by each granule in an interleaving group. The default stride -- 128B -- is the only value intended for production FW use. All other combinations are for experimental performance evaluation. Regardless of this attribute value, groups of size 1, 3, and 6 will be forced to 128B stride based on the logic capabilities.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_INTERLEAVE_GRANULARITY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_INTERLEAVE_GRANULARITY</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>REQUIRED/TRUE: HW mirroring is enabled, and all channels are required to be part of a mirrored group. REQUESTED : HW mirroring is enabled. Mirroring will be configured for groups which support it, but not all channels are required to be mirrored. FALSE : HW mirroring is disabled. Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MRW_HW_MIRRORING_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MRW_HW_MIRRORING_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Enable early data from Memory. This also enable cp_me from L3.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_ENABLE_MEM_EARLY_DATA_SCOM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>ENABLE_MEM_EARLY_DATA_SCOM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>DMI inband BAR enable. Set by platform. Used by p9c_set_inband_addr.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_OMI_INBAND_BAR_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>OMI_INBAND_BAR_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>OMI inband BAR address offset. Set by platform. One Axone bar register is set per MC channel for MMIO and another is set per MC channel for config space. The bar is shared between both sub-channels each with an OCMB. The upper bit of the bar size is used to determine which sub-channel is selected. This means that for two OCMB's their config space is contiguous and their MMIO space is contiguous. Therefore a single OCMB's MMIO and config space cannot be contiguous. However, we can still use one BAR attribute. The p9a_omi_setup_bars procedure can interleave the config space and MMIO space as shown in the table bellow. For example, both MMIO and config bar sizes are 2GB. The 2GB bit becomes the selector for the subchannel. The 4GB bit becomes the offset applied for MMIO operations. Each OCMB is assigned one base address attribute. ocmb | BAR ATTRIBUTE | Type | Base reg - end addr | size | sub-ch +-----+--------------------+------+-----------------------------------------+------+------- ocmb0 | 0x0006030200000000 | cnfg | 0x0006030200000000 - 0x000603027FFFFFFF | 2GB | 0 ocmb1 | 0x0006030280000000 | cnfg | 0x0006030280000000 - 0x00060302FFFFFFFF | 2GB | 1 ocmb0 | N/A | mmio | 0x0006030300000000 - 0x000603037FFFFFFF | 2GB | 0 ocmb1 | N/A | mmio | 0x0006030380000000 - 0x00060303FFFFFFFF | 2GB | 1 +-----+--------------------+------+-----------------------------------------+------+------- ocmb2 | 0x0006030400000000 | cnfg | 0x0006030400000000 - 0x000603047FFFFFFF | 2GB | 0 ocmb3 | 0x0006030480000000 | cnfg | 0x0006030480000000 - 0x00060304FFFFFFFF | 2GB | 1 ocmb2 | N/A | mmio | 0x0006030500000000 - 0x000603057FFFFFFF | 2GB | 0 ocmb3 | N/A | mmio | 0x0006030580000000 - 0x00060305FFFFFFFF | 2GB | 1 Used by p9a_omi_setup_bars</description>
    <hwpfToHbAttrMap>
      <id>ATTR_OMI_INBAND_BAR_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>OMI_INBAND_BAR_BASE_ADDR_OFFSET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Source: MRW: Downstream MSB Swap and Upstream MSB Swap Usage: TX_MSBSWAP initfile setting for DMI and X buses This attribute represents whether or not a single clock group bus such as DMI and X bus was wired by the board designer using a feature called MSB Swap where lane 0 of the TX chip wires to lane n-1 on the RX chip where 'n' is the width of the bus. A basic description of this capability is that the board designer can save layers on the board wiring by crossing the wiring between the two chips in a prescribed manner. In a non-MSB Swapped bus Lane 0 on the TX chip wires to lane 0 on the RX chip, lane 1 to lane 1 and so on. If a bus is MSB Swapped then lane 0 of the TX chip wires to lane 'n-1' of the RX chip, lane 1 to lane 'n-2', etc. Random or arbitrary wiring of TX to RX lanes on different chips is NOT ALLOWED. The Master Chip of two connected chips is defined as the chip with the smaller value of (100*Node + Pos). The Slave Chip of two connected chips is defined as the chip with the larger value of (100*Node + Pos). The Downstream direction is defined as the direction from the Master chip to the Slave chip. The Upstream direction is defined as the direction from the Slave chip to the Master chip. The Downstream TX_MSBSWAP from the MRW is a uint8 value. 0x01 means the Downstream bus is wired msb to lsb etc. and 0x00 means the bus is wired normally, msb to msb, lsb to lsb (lane0 to lane0). The Upstream TX_MSBSWAP from the MRW is a uint8 value. 0x01 means the Upstream bus is wired msb to lsb etc. and 0x00 means the bus is wired normally, msb to msb, lsb to lsb (lane0 to lane0). It is up to the platform code to set up each ATTR_EI_BUS_TX_MSBSWAP value for the correct target endpoints.</description>
    <global />
    <hwpfToHbAttrMap>
      <id>ATTR_EI_BUS_TX_MSBSWAP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EI_BUS_TX_MSBSWAP</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Firmware specified eRepair threshold limit of X Bus for Field usage This value must be initialized by platforms by reading the value from System Model - x_threshold_field of system_policy_table</description>
    <hwpfToHbAttrMap>
      <id>ATTR_X_EREPAIR_THRESHOLD_FIELD</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>X_EREPAIR_THRESHOLD_FIELD</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Firmware specified eRepair threshold limit of X Bus for MNFG usage This value must be initialized by platforms by reading the value from System Model - x_threshold_mnfg of system_policy_table</description>
    <hwpfToHbAttrMap>
      <id>ATTR_X_EREPAIR_THRESHOLD_MNFG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>X_EREPAIR_THRESHOLD_MNFG</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Firmware specified eRepair threshold limit of O Bus for Field usage This value must be initialized by platforms by reading the value from System Model - a_threshold_field of system_policy_table</description>
    <hwpfToHbAttrMap>
      <id>ATTR_O_EREPAIR_THRESHOLD_FIELD</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>O_EREPAIR_THRESHOLD_FIELD</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Firmware specified eRepair threshold limit of O Bus for MNFG usage This value must be initialized by platforms by reading the value from System Model - a_threshold_mnfg of system_policy_table</description>
    <hwpfToHbAttrMap>
      <id>ATTR_O_EREPAIR_THRESHOLD_MNFG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>O_EREPAIR_THRESHOLD_MNFG</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Firmware specified eRepair threshold limit of Memory Bus for Field usage This value must be initialized by platforms by reading the value from System Model - dmi_threshold_field of system_policy_table</description>
    <hwpfToHbAttrMap>
      <id>ATTR_DMI_EREPAIR_THRESHOLD_FIELD</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DMI_EREPAIR_THRESHOLD_FIELD</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Firmware specified eRepair threshold limit of Memory Bus for MNFG usage This value must be initialized by platforms by reading the value from System Model - dmi_threshold_mnfg of system_policy_table</description>
    <hwpfToHbAttrMap>
      <id>ATTR_DMI_EREPAIR_THRESHOLD_MNFG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DMI_EREPAIR_THRESHOLD_MNFG</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Indicate if debug data should be taken pre / post linktraining.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_DMI_PROC_DEBUG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_DMI_PROC_DEBUG</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Value to select amount of margin to be applied.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_DMI_PROC_TX_MARGIN_RATIO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_DMI_PROC_TX_MARGIN_RATIO</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Value to select amount of tx ffe precusor to apply.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_DMI_PROC_TX_FFE_PRECURSOR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_DMI_PROC_TX_FFE_PRECURSOR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Indicate if manufcaturing tests should be taken pre / post linktraining.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_O_MFG_CHK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_O_MFG_CHK</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Minimum eye width to allow passing through manufacturing.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_O_MFG_MIN_EYE_WIDTH</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_O_MFG_MIN_EYE_WIDTH</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Value to select amount of margin to be applied.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_OBUS_TX_MARGIN_RATIO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_OBUS_TX_MARGIN_RATIO</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Value to select amount of tx ffe precusor to apply.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_OBUS_TX_FFE_PRECURSOR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_OBUS_TX_FFE_PRECURSOR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Value to select amount of tx ffe postcusor to apply.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_OBUS_TX_FFE_POSTCURSOR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_OBUS_TX_FFE_POSTCURSOR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute provides a place for Hostboot to save off the IO_OLLFIR_MASK. During IPL time Hostboot wants to change the value of the FIR but it will write the value back during Hostboot Runtime (HBRT). Hostboot will need to wait to save the values until after p9_chiplet_scominit is called because that HWP sets the fir masks we want to save off. Values will need to restored after the PEER_TARGET values have been updated in HBRT</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_OLLFIR_MASK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_OLLFIR_MASK</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>This attribute provides a place for Hostboot to save off the PB_IOOFIR_MASK. During IPL time Hostboot wants to change the value of the FIR but it will write the value back during Hostboot Runtime (HBRT). Hostboot will need to wait to save the values until after p9_chiplet_scominit is called because that HWP sets the fir masks we want to save off. Values will need to restored after the PEER_TARGET values have been updated in HBRT</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_PB_IOOFIR_MASK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_PB_IOOFIR_MASK</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Indicates if the Obus channel is a board or a cable</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_O_CHANNEL_TYPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_O_CHANNEL_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute provides an a way to stress the SMP Abus Even Lanes in Manufacturing. By applying a phase rotator offset we can further stress the phy. This is a 6-bit 2's complement value that would be right justified in the 8 bit UINT attribute value.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_O_MFG_STRESS_PR_OFFSET_EVEN</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_O_MFG_STRESS_PR_OFFSET_EVEN</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>i This attribute provides an a way to stress the SMP Abus Odd Lanes in Manufacturing. By applying a phase rotator offset we can further stress the phy. This is a 6-bit 2's complement value that would be right justified in the 8 bit UINT attribute value.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_O_MFG_STRESS_PR_OFFSET_ODD</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_O_MFG_STRESS_PR_OFFSET_ODD</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Indicate if manufacturing tests should be taken pre / post linktraining.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_X_MFG_CHK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_X_MFG_CHK</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Minimum eye width to allow passing through manufacturing.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_X_MFG_MIN_EYE_WIDTH</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_X_MFG_MIN_EYE_WIDTH</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Value to select amount of margin to be applied.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_XBUS_TX_MARGIN_RATIO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_XBUS_TX_MARGIN_RATIO</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Value to select amount of tx ffe precusor to apply.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_XBUS_TX_FFE_PRECURSOR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_XBUS_TX_FFE_PRECURSOR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>6</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Alternate settings for short Xbus channels bit 0 -- Disable RX LTE bit 1 -- Disable AC BOOST bit 2 -- Low Gain/Peaking Init Settings bit 3 -- Lower VGA Gain Target -10%</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_XBUS_CHAN_EQ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_XBUS_CHAN_EQ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>PCIE MMIO BAR enable creator: platform consumer: p9_pcie_config firmware notes: Array index: BAR number (0:2) index 0~1 for MMIO BAR0/1 index 2 for PHB register space</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_BAR_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_BAR_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>3</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>PCIE MMIO0 BAR base address offset creator: platform consumer: p9_setup_bars firmware notes: Attribute holds offset (relative to chip MMIO origin) to program into chip address range field of BAR -- RA bits 8:47 (excludes system/memory select/group/chip fields) Array index: PHB number (0:5)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_MMIO_BAR0_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_MMIO_BAR0_BASE_ADDR_OFFSET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>6</array>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>PCIE MMIO1 BAR base address offset creator: platform consumer: p9_setup_bars firmware notes: Attribute holds offset (relative to chip MMIO origin) to program into chip address range field of BAR -- RA bits 8:47 (excludes system/memory select/group/chip fields) Array index: PHB number (0:5)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_MMIO_BAR1_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_MMIO_BAR1_BASE_ADDR_OFFSET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>6</array>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>PCIE PHB register space BAR base address offset creator: platform consumer: p9_setup_bars firmware notes: Attribute holds offset (relative to chip MMIO origin) to program into chip address range field of BAR -- RA bits 8:49 (excludes system/memory select/group/chip fields) Array index: PHB number (0:5)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_REGISTER_BAR_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_REGISTER_BAR_BASE_ADDR_OFFSET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>6</array>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>PCIE MMIO BAR size values creator: platform consumer: p9_pcie_config firmware notes: Array index: BAR number (0:2) NOTE: supported MMIO BAR0/1 sizes are from 64KB-32PB NOTE: only supported PHB register size is 16KB</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_BAR_SIZE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_BAR_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>3</array>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>PCS rx cdr gains creator: platform consumer: p9_pcie_scominit firmware notes: This is a MRW seting. The value of rx cdr gains for PCS. Array index: Configuration number index 0~3 for CONFIG0~3</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PCS_RX_CDR_GAIN</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_PCS_RX_CDR_GAIN</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>PCS rx vga peak init value creator: platform consumer: p9_pcie_scominit firmware notes: This is a MRW setting. The value of rx vga peak init for PCS. Array index: Configuration number index 0~3 for CONFIG0~3 lane 0~15 for each PCIE Lane</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PCS_RX_PK_INIT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_PCS_RX_PK_INIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4,16</array>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>PCS rx vga gain init value creator: platform consumer: p9_pcie_scominit firmware notes: This is a MRW setting. The value of rx vga gain init for PCS. Array index: Configuration number index 0~3 for CONFIG0~3 lane 0~15 for each PCIE Lane</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PCS_RX_INIT_GAIN</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_PCS_RX_INIT_GAIN</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4,16</array>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>PCS rx sigdet lvl value creator: platform consumer: p9_pcie_scominit firmware notes: This is a MRW setting. The value of rx sigdet lvl for PCS. Array index: Configuration number index 0~3 for CONFIG0~3</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PCS_RX_SIGDET_LVL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_PCS_RX_SIGDET_LVL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint8_t>
        <default>0x0B</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of PCS RX ROT CNTL CDR lookahead creator: platform consumer: p9_pcie_scominit firmware notes: This is a MRW setting. 0 for disable (default) 1 for enable Used for spread spectrum enablement.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PCS_RX_ROT_CDR_LOOKAHEAD</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_PCS_RX_ROT_CDR_LOOKAHEAD</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of PCS RX ROT CNTL CDR ssc creator: platform consumer: p9_pcie_scominit firmware notes: This is a MRW setting. 0 for disable (default) 1 for enable Used for Spread Spectrum enablement.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PCS_RX_ROT_CDR_SSC</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_PCS_RX_ROT_CDR_SSC</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of PCS RX ROT rstfw latch creator: platform consumer: p9_pcie_scominit firmware notes: This is a common setting that can be overwritten by code logic. 0 normal, flywheel is enabled (default) 1 assert reset to the phase rotator flywheel (disable the flywheel)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PCS_RX_ROT_RST_FW</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_PCS_RX_ROT_RST_FW</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of PCS pclck control plla creator: platform consumer: p9_pcie_scominit firmware notes: This is a common setting that can be overwritten by code logic.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PCS_PCLCK_CNTL_PLLA</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_PCS_PCLCK_CNTL_PLLA</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of PCS pclck control pllb creator: platform consumer: p9_pcie_scominit firmware notes: This is a common setting that can be overwritten by code logic.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PCS_PCLCK_CNTL_PLLB</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_PCS_PCLCK_CNTL_PLLB</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of PCS tx dclck rotator override creator: platform consumer: p9_pcie_scominit firmware notes: This is a common setting that can be overwritten by code logic.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PCS_TX_DCLCK_ROT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_PCS_TX_DCLCK_ROT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of PCS tx pcie receiver detect control register 1 creator: platform consumer: p9_pcie_scominit firmware notes: This is a common setting that can be overwritten by code logic.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PCS_TX_PCIE_RECV_DETECT_CNTL_REG1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_PCS_TX_PCIE_RECV_DETECT_CNTL_REG1</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of PCS tx pcie receiver detect control register 2 creator: platform consumer: p9_pcie_scominit firmware notes: This is a common setting that can be overwritten by code logic.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PCS_TX_PCIE_RECV_DETECT_CNTL_REG2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_PCS_TX_PCIE_RECV_DETECT_CNTL_REG2</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of PCS tx power sequence enable creator: platform consumer: p9_pcie_scominit firmware notes: This is a common setting that can be overwritten by code logic.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PCS_TX_POWER_SEQ_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_PCS_TX_POWER_SEQ_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of PCS rx vga control register 1 creator: platform consumer: p9_pcie_scominit firmware notes: This is a common setting that can be overwritten by code logic.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PCS_RX_VGA_CNTL_REG1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_PCS_RX_VGA_CNTL_REG1</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of PCS rx vga control register 2 creator: platform consumer: p9_pcie_scominit firmware notes: This is a common setting that can be overwritten by code logic.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PCS_RX_VGA_CNTL_REG2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_PCS_RX_VGA_CNTL_REG2</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of PCS m1-m4 control creator: platform consumer: p9_pcie_scominit This is a common setting that can be overwritten by code logic. Array index: 0 -&gt; M1 1 -&gt; M2 2 -&gt; M3 3 -&gt; M4</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PCS_M_CNTL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_PCS_M_CNTL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>The minimum number of valid ECs that is required to be used when customizing an SBE image. The customization will fail if it cannot create an image with at least this many ECs.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SBE_IMAGE_MINIMUM_VALID_ECS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SBE_IMAGE_MINIMUM_VALID_ECS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Axone only - setup clock mux settings for TOD Refclk input 0b0 = 16 MHz I/O Filter PLL Output 0b1 = 32 MHz LPC reference clock</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCK_PLL_MUX_TOD</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CLOCK_PLL_MUX_TOD</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>setup clock mux settings</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCK_PLL_MUX</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CLOCK_PLL_MUX</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Clock Mux#0 settings</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCK_PLL_MUX0</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CLOCK_PLL_MUX0</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Ref clock I2C bus divider consumed by code running out of OTPROM</description>
    <hwpfToHbAttrMap>
      <id>ATTR_I2C_BUS_DIV_REF</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>I2C_BUS_DIV_REF</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0x0003</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Select Nest I2C and pll setting from one of the supported frequencies</description>
    <hwpfToHbAttrMap>
      <id>ATTR_NEST_PLL_BUCKET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>NEST_PLL_BUCKET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x05</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>System specific value for Filter PLL bucket, provided by MRW. If non-zero, this value will directly set ATTR_FILTER_PLL_BUCKET (used by SBE to select bucket). If zero, VPD MK content will set ATTR_FILTER_PLL_BUCKET.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MRW_FILTER_PLL_BUCKET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MRW_FILTER_PLL_BUCKET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>EQ boot frequency multiplier The equation for this setting is BOOT_FREQ(MHz)/(REFCLK/DPLL_DIVIDER) where the DPLL DIVIDER is planned for being set to 8. The value needs to be loaded right justified. The value's right most 11 bits (becoming 0:10) is written as bits 17:27 of PPM DPLL freq ctrl register. Bits 0:7 become DPLL.MULT_INTG(0:7) and bits 8:10 are DPLL.MULT_FRAC(0:2). As an example: 3000MHz / (133MHz/8) = 3000 / 16.667 = ~180 =&gt; 0xB4</description>
    <hwpfToHbAttrMap>
      <id>ATTR_BOOT_FREQ_MULT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>BOOT_FREQ_MULT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>150</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>EQ boot frequency</description>
    <hwpfToHbAttrMap>
      <id>ATTR_BOOT_FREQ_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>BOOT_FREQ_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>2400</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>FIXME - NEEDS DESCRIPTION</description>
    <hwpfToHbAttrMap>
      <id>ATTR_BRANCH_PIBMEM_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>BRANCH_PIBMEM_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>I2C Bus speed based on nest freq, ref clock</description>
    <hwpfToHbAttrMap>
      <id>ATTR_I2C_BUS_DIV_NEST</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>I2C_BUS_DIV_NEST</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>FIXME - NEEDS DESCRIPTION</description>
    <hwpfToHbAttrMap>
      <id>ATTR_LEN_OF_SEEPROM_DATA</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>LEN_OF_SEEPROM_DATA</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>FIXME - NEEDS DESCRIPTION</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MB_BIT_RATE_DIVISOR_PLL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MB_BIT_RATE_DIVISOR_PLL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>FIXME - NEEDS DESCRIPTION</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MB_BIT_RATE_DIVISOR_REFCLK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MB_BIT_RATE_DIVISOR_REFCLK</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>133</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Ring image for pb_bndy_dmipll ring creator: platform firmware notes:</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PB_BNDY_DMIPLL_DATA</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PB_BNDY_DMIPLL_DATA</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Ring image for pb_bndy_dmipll ring for DC cal creator: platform firmware notes:</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PB_BNDY_DMIPLL_FOR_DCCAL_DATA</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PB_BNDY_DMIPLL_FOR_DCCAL_DATA</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Ring image for perv_bndy_pll ring containing filter plls and xb_pll,nest_pll creator: platform firmware notes:</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PERV_BNDY_PLL_DATA</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PERV_BNDY_PLL_DATA</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Indicates if SBE on this chip is serving as hosboot drawer master</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_SBE_MASTER_CHIP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_SBE_MASTER_CHIP</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>FIXME - NEEDS DESCRIPTION</description>
    <hwpfToHbAttrMap>
      <id>ATTR_START_PIBMEM_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>START_PIBMEM_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>FIXME - NEEDS DESCRIPTION</description>
    <hwpfToHbAttrMap>
      <id>ATTR_START_SEEPROM_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>START_SEEPROM_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>FIXME - NEEDS DESCRIPTION</description>
    <hwpfToHbAttrMap>
      <id>ATTR_WAIT_N0</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>WAIT_N0</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>FIXME - NEEDS DESCRIPTION</description>
    <hwpfToHbAttrMap>
      <id>ATTR_WAIT_N1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>WAIT_N1</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>FIXME - NEEDS DESCRIPTION</description>
    <hwpfToHbAttrMap>
      <id>ATTR_WAIT_N2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>WAIT_N2</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>FIXME - NEEDS DESCRIPTION</description>
    <hwpfToHbAttrMap>
      <id>ATTR_WAIT_N3</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>WAIT_N3</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Holds the state of Security Access Bit (SAB)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SECURITY_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SECURITY_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>To disable force pfet off control from fuse status</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PFET_OFF_CONTROLS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PFET_OFF_CONTROLS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Holds Obus ratio value 0b00 Normal speed. 0b01 Half speed.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_OBUS_RATIO_VALUE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>OBUS_RATIO_VALUE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>To skip the locking sequence and check for lock of CP filter PLL</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CP_FILTER_BYPASS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CP_FILTER_BYPASS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>To skip the locking sequence and check for lock of SS filter PLL</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SS_FILTER_BYPASS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SS_FILTER_BYPASS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>To skip the locking sequence and check for lock of IO filter PLL</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_FILTER_BYPASS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_FILTER_BYPASS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Skip locking sequence and check for lock of DPLL</description>
    <hwpfToHbAttrMap>
      <id>ATTR_DPLL_BYPASS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DPLL_BYPASS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Skip the locking sequence and check for lock of NEST/MEM/XBUS/OBUS/PCI PLLs</description>
    <hwpfToHbAttrMap>
      <id>ATTR_NEST_MEM_X_O_PCI_BYPASS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>NEST_MEM_X_O_PCI_BYPASS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines system specific value of processor refclock receiver termination</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CP_REFCLOCK_RCVR_TERM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CP_REFCLOCK_RCVR_TERM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines system specific value of PCI refclock receiver termination</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_REFCLOCK_RCVR_TERM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_REFCLOCK_RCVR_TERM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Sector buffer strength</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SECTOR_BUFFER_STRENGTH</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SECTOR_BUFFER_STRENGTH</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>enable the pulse mode</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PULSE_MODE_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PULSE_MODE_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>value for pulse mode</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PULSE_MODE_VALUE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PULSE_MODE_VALUE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Step size (binary in microvolts) to take upon external VRM voltage transitions. The value set here must take into account where internal VRMs are enabled or not as, when they are enabled, the step size must account for the tracking (eg PFET strength recalculation) for the step. Firmware provides a default value of 50mV if this attribute is zero. Consumer: p9_pstate_parameter_block -&gt; p9_setup_evid Pstate Parameter Block (PSPB) for PGPE Provided by the Machine Readable Workbook after system characterization.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXTERNAL_VRM_STEPSIZE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXTERNAL_VRM_STEPSIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x00</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Delay (binary in nanoseconds) from the time the VRM receives the write voltage command until the voltage actually moves. This value is used for both increasing and decreasing transitions as part of the overall voltage transition time calculation. Firmware provides a default value of 8000ns (eg 8us)) if this attribute is zero. Note: the smallest possible delay is limited to 1ns. Consumer: p9_pstate_parameter_block -&gt; Pstate Parameter Block (PSPB) for PGPE Provided by the Machine Readable Workbook after system characterization.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXTERNAL_VRM_TRANSITION_START_NS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXTERNAL_VRM_TRANSITION_START_NS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x00</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Transition rate (binary in microVolts per microsecond) of the VRM for an increasing voltage transition. This is used as part of the overall voltage transition time calculation Firmware provides a default value of 10000 uV/us (eg 10mV/us) if this attribute is zero. Note: the fastest possible rate is limited to 1uV/us. Consumer: p9_pstate_parameter_block -&gt; Pstate Parameter Block (PSPB) for PGPE Provided by the Machine Readable Workbook after system characterization.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXTERNAL_VRM_TRANSITION_RATE_INC_UV_PER_US</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXTERNAL_VRM_TRANSITION_RATE_INC_UV_PER_US</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x00</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Transition rate (binary in microVolts per microsecond) of the VRM for an decreasing voltage transition. This is used as part of the overall voltage transition time calculation Firmware provides a default value of 10000 uV/us (eg 10mV/us) if this attribute is zero. Note: the fastest possible rate is limited to 1uV/us. Consumer: p9_pstate_parameter_block -&gt; Pstate Parameter Block (PSPB) for PGPE Provided by the Machine Readable Workbook after system characterization.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXTERNAL_VRM_TRANSITION_RATE_DEC_UV_PER_US</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXTERNAL_VRM_TRANSITION_RATE_DEC_UV_PER_US</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x00</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Time (binary in nanoseconds) to allow the voltage rail to stabilize before considering the transition to be fully complete. This value is used for both increasing and decreasing transitions as part of the overall voltage transition time calculation. Firmware provides a default value of 5000ns (5us) if this attribute is zero. Note: the smallest delay is limited to 1ns. Consumer: p9_pstate_parameter_block -&gt; Pstate Parameter Block (PSPB) for PGPE Provided by the Machine Readable Workbook after system characterization.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXTERNAL_VRM_TRANSITION_STABILIZATION_TIME_NS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXTERNAL_VRM_TRANSITION_STABILIZATION_TIME_NS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x00</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>AVSBus Clock Frequency (binary in KHz) Consumer: p9_ocb_init.C Overridden by the Machine Readable Workbook. If default of 0 is read, HWP will set AVSBus frequency to 1MHz.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_AVSBUS_FREQUENCY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>AVSBUS_FREQUENCY</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines the AVSBus (0 or 1) which has the core VDD rail VRM Producer: Machine Readable Workbook Consumers: p9_set_evid; p9_set_voltage (tool); p9_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB) for PGPE *MOST* systems use Bus 0 for VDD. If this is not the case, the value must be appropriately set by the platform (eg MRWB or equivalent)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VDD_AVSBUS_BUSNUM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VDD_AVSBUS_BUSNUM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines the AVSBus (0 or 1) which has the chip VDN rail VRM Producer: Machine Readable Workbook Consumers: p9_set_evid; p9_set_voltage (tool); p9_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB) for PGPE *MOST* systems use Bus 1 for VDD. If this is not the case, the value must be appropriately set by the platform (eg MRWB or equivalent)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VDN_AVSBUS_BUSNUM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VDN_AVSBUS_BUSNUM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines the AVSBus (0 or 1) which has the chip VCS rail VRM Producer: Machine Readable Workbook Consumers: p9_set_evid; p9_set_voltage (tool); p9_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB) for PGPE For systems where VCS is not connected via AVSBus, set to 0xFF.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VCS_AVSBUS_BUSNUM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VCS_AVSBUS_BUSNUM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines the AVSBus rail selector number (0 - 15) for the VDD VRM on the bus defined by ATTR_AVSBUS_VDD_BUSNUM. Producer: Machine Readable Workbook Consumers: p9_set_evid; p9_set_voltage (tool); p9_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB) for PGPE *MOST* systems use Rail 0 for VDD for the bus on which they are connected. If this is not the case, the value must be appropriately set by the platform (eg MRWB or equivalent)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VDD_AVSBUS_RAIL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VDD_AVSBUS_RAIL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines the AVSBus rail selector number (0 - 15) for the VDN VRM on the bus defined by ATTR_AVSBUS_VDN_BUSNUM. Producer: Machine Readable Workbook Consumers: p9_set_avsbus_voltage (tool); p9_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB) for PGPE *MOST* systems use Rail 0 for VDN for the bus on which they are connected. If this is not the case, the value must be appropriately set by the platform (eg MRWB or equivalent)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VDN_AVSBUS_RAIL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VDN_AVSBUS_RAIL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines the AVSBus rail selector number (0 - 15) for the VCS VRM on the bus defined by ATTR_AVSBUS_VCS_BUSNUM. Producer: Machine Readable Workbook Consumers: p9_set_avsbus_voltage (tool); p9_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB) for PGPE</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VCS_AVSBUS_RAIL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VCS_AVSBUS_RAIL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines the I2C bus number (0 - 15) that has the VCS VRM. Producer: Machine Readable Workbook Consumers: p9_set_evid; p9_set_voltage (tool)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VCS_I2C_BUSNUM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VCS_I2C_BUSNUM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>SPIPSS Clock Frequency (binary in KHz) Valid range: 500KHz to 2500KHz Consumer: p9_pss_init Overridden by the Machine Readable Workbook. If default of 0 is read, HWP will set SPIPSS frequency to 10MHz.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SPIPSS_FREQUENCY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SPIPSS_FREQUENCY</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines which of the PSS chip selects (0 or 1) that the APSS is connected Provided by the Machine Readable Workbook. Consumer: p9_pm_pss_init</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PM_APSS_CHIP_SELECT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PM_APSS_CHIP_SELECT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Impedance (binary microOhms) of the load line from a processor VDD VRM to the Processor Module pins. This value is applied to each processor instance. Producer: Machine Readable Workbook (per the power subsystem design) Consumers: p9_pstate_parameter_block</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_R_LOADLINE_VDD_UOHM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_R_LOADLINE_VDD_UOHM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Impedance (binary in microOhms) of the VDD distribution loss sense point to the circuit. This value is applied to each processor instance. Producer: Machine Readable Workbook (per the power subsystem design) Consumers: p9_pstate_parameter_block</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_R_DISTLOSS_VDD_UOHM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_R_DISTLOSS_VDD_UOHM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Offset voltage (binary in microvolts) to apply to the VDD VRM distribution to the processor module. This value is applied to each processor instance. Note: no loadline may be present in the system; thus, a value of 0 is legal. Producer: Machine Readable Workbook (per the power subsystem design) Consumers: p9_pstate_parameter_block</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_VRM_VOFFSET_VDD_UV</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_VRM_VOFFSET_VDD_UV</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Impedance (binary microOhms) of the load line from a processor VDN VRM to the Processor Module pins. This value is applied to each processor instance. Note: no loadline may be present in the system; thus, a value of 0 is legal. Producer: Machine Readable Workbook (per the power subsystem design) Consumers: p9_pstate_parameter_block</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_R_LOADLINE_VDN_UOHM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_R_LOADLINE_VDN_UOHM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Impedance (binary in microOhms) of the VDN distribution loss sense point to the circuit. This value is applied to each processor instance. Producer: Machine Readable Workbook (per the power subsystem design) Consumers: p9_pstate_parameter_block</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_R_DISTLOSS_VDN_UOHM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_R_DISTLOSS_VDN_UOHM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Offset voltage (binary in microvolts) to apply to the VDN VRM distribution to the processor module. This value is applied to each processor instance. Producer: Machine Readable Workbook (per the power subsystem design) Consumers: p9_pstate_parameter_block</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_VRM_VOFFSET_VDN_UV</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_VRM_VOFFSET_VDN_UV</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Impedance (binary microOhms) of the load line from a processor VCS VRM to the Processor Module pins. This value is applied to each processor instance. Note: no loadline may be present in the system; thus, a value of 0 is legal. Producer: Machine Readable Workbook (per the power subsystem design) Consumers: p9_pstate_parameter_block</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_R_LOADLINE_VCS_UOHM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_R_LOADLINE_VCS_UOHM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Impedance (binary in microOhms) of the VCS distribution loss sense point to the circuit. This value is applied to each processor instance. Producer: Machine Readable Workbook (via the power subsystem design per system) Consumer: p9_pstate_parameter_block</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_R_DISTLOSS_VCS_UOHM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_R_DISTLOSS_VCS_UOHM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Offset voltage (binary in microvolts) to apply to the VCS VRM distribution to the processor module. This value is applied to each processor instance. Producer: Machine Readable Workbook (via the power subsystem design per system) Consumer: FSP</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_VRM_VOFFSET_VCS_UV</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_VRM_VOFFSET_VCS_UV</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Control CME response to execution of PowerPC STOP instruction if OFF, treat STOP4 as STOP4 if ON, treat STOP4 as STOP2 Producer: Work-around tools Consumer: p9_hcode_image_build.C Platform default: OFF</description>
    <hwpfToHbAttrMap>
      <id>ATTR_STOP4_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>STOP4_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Control CME response to execution of PowerPC STOP instruction if OFF, treat STOP8 as STOP8 if ON, treat STOP8 as STOP4 Producer: Work-around tools Consumer: p9_hcode_image_build.C Platform default: OFF</description>
    <hwpfToHbAttrMap>
      <id>ATTR_STOP8_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>STOP8_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Control CME response to execution of PowerPC STOP instruction if OFF, treat STOP11 as STOP11 if ON, treat STOP11 as STOP8 Producer: Work-around tools Consumer: p9_hcode_image_build.C Platform default: OFF</description>
    <hwpfToHbAttrMap>
      <id>ATTR_STOP11_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>STOP11_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Disables Work Load Optimized Frequency (WOF) algorithms to modify frequency based on active core count and other inputs. OFF: Will enable WOF given all validity check pass. If validity checks fail, WOF will be disabled for the present IPL. ON: Will disable WOF OFF_SKIP_DD: Same as OFF but skips any validity checking of the chip design level (lab use only). Producer: Override Consumers: p9_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB) for PGPE/OCC</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_WOF_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_WOF_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Disables IVRM enablement in the system Producer: Override Consumers: p9_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB) for PGPE/OCC CME Quad Pstate Region (CQPR) for CM Quad Manager</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_IVRM_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_IVRM_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>If wof_enabled, defines the Frequency Ratio calculation performed. (THIS IS NOT SUPPORTED IN P9 GA1!).</description>
    <hwpfToHbAttrMap>
      <id>ATTR_WOF_ENABLE_FRATIO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>WOF_ENABLE_FRATIO</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>If wof_enabled, defines the Voltage Ratio calculation performed. THIS IS NOT SUPPORTED AT PRESENT. GA1 SUPPORT IS TBD).</description>
    <hwpfToHbAttrMap>
      <id>ATTR_WOF_ENABLE_VRATIO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>WOF_ENABLE_VRATIO</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>If wof_enabled AND ATTR_WOF_ENABLE_VRATIO = CALCULATED, this attribute selects the Vratio calculation type. ACTIVE_CORES: Vratio is the number of active cores to the number of good cores FULL: Vratio is Vaverage to Vclip(Fclip) where Vclip(Fclip) is the normal interpolated regulator voltage (including load line uplife @ RDP current) derated with presently measured Idd current (from the AVSBus) and the loadline.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_WOF_VRATIO_SELECT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>WOF_VRATIO_SELECT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Receive PBAX Groupid. Value that indicates this PBA's PBAX Group affinity. This is matched to pbax_groupid of the PMISC Address phase. Provided by the Machine Readable Workbook. Platform default: Nimbus systems = 0</description>
    <global />
    <hwpfToHbAttrMap>
      <id>ATTR_PBAX_GROUPID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PBAX_GROUPID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Receive PBAX Chipid. Value that indicates this PBA's PBAX Chipid within the PBAX node. Is matched to pbax_chipid of the Address phase if pbax_type=unicast. Provided by the Machine Readable Workbook. Platform default: Nimbus systems - set so value in ATTR_FABRIC_GROUP_ID</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PBAX_CHIPID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PBAX_CHIPID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>if set to 1, FAPI_ERR records are suppressed from being produced by p9_dump_stop_info.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_DUMP_STOP_INFO_SUPPRESS_ERROR_TRACE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DUMP_STOP_INFO_SUPPRESS_ERROR_TRACE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>if set to 1, p9_dump_stop_info output will be written to error logs</description>
    <hwpfToHbAttrMap>
      <id>ATTR_DUMP_STOP_INFO_ENABLE_ERRORLOG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DUMP_STOP_INFO_ENABLE_ERRORLOG</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Disables the enablement of Voltage Droop Monitors (VDM) in the system. Producer: MRW Consumers: p9_pstate_parameter_block to clear flag for CME QuadManager Hcode reaction</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_VDM_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_VDM_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Controls the enablement of Voltage Droop Monitors (VDM) to throttle the core upon an extreme droop event. Producer: Machine Readable Workbook Consumers: p9_hcode_image_build to set flag for CME QuadManager Hcode reaction</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VDM_EXTREME_THOTTLE_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VDM_EXTREME_THOTTLE_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Indicates the response of the DPLL frequency upon VDM events if ATTR_SYSTEM_VDM_DISABLE is not ON. NONE -&gt; DPLL Mode 2 DROOP_PROTECT -&gt; DPLL Mode 3 DROOP_PROTECT_OVERVOLT -&gt; DPLL Mode 3.5 DYNAMIC -&gt; DPLL Mode 4 DYNAMIC_PROTECT -&gt; DPLL Mode 5 Producer: MRWB.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_DPLL_VDM_RESPONSE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DPLL_VDM_RESPONSE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Override time (in nanoseconds) to wait after the iVRM indicates "done" in the event extra time is required. A zero value will have the hardcoded default to be used. Producer: MRWB. Consumer: p9_pstate_parameter_block -&gt; CME pstate parameter block PGPE pstate parameter block</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IVRM_STABILIZATION_DELAY_NS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IVRM_STABILIZATION_DELAY_NS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>TODO RTC 157943 -- Placeholder description This overrides the RDP to TDP Scaling Factor IQ VPD field that is used for Workload Optimized Frequency (WOF) voltage uplifting. Consumers: p9_pstate_parameter_block</description>
    <hwpfToHbAttrMap>
      <id>ATTR_TDP_RDP_CURRENT_FACTOR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>TDP_RDP_CURRENT_FACTOR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Minimum delay (in nanoseconds) between clock grid management transition steps Producer: MRWB from clock team Consumers: p9_build_pstate_datablock -&gt; CME Quad Pstate Region (CQPR) for CM Quad Manager Platform default: 0</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_RESCLK_STEP_DELAY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_RESCLK_STEP_DELAY</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Debug modes supported for CME/SGPE Scan layout in HOMER.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_RING_DBG_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_RING_DBG_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Time between invocations of the 24x7 performance collection function on GPE1. The time (in milliseconds) is derived as 2^PERF_24x7_INVOCATION_TIME_MS with 0 indicating the function is OFF. Consumer: p9_hcode_image_build.c -&gt; SGPE Header field Provided by the Machine Readable Workbook to tune the collection. Platform default: 1</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PERF_24x7_INVOCATION_TIME_MS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PERF_24x7_INVOCATION_TIME_MS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Enables the SGPE Hcode to enable the CME instruction traces into the L3 Trace array for debug. Note: all configured CMEs will be put into this mode if this attribute is ON. Consumer: p9_hcode_image_build.c -&gt; SGPE Header field Platform default: OFF</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CME_INSTRUCTION_TRACE_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CME_INSTRUCTION_TRACE_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Enables the SGPE Hcode to enable the CME instruction traces into the CHTM for debug. Note: all configured CMEs will be put into this mode if this attribute is ON. Consumer: p9_hcode_image_build.c -&gt; SGPE Header field Platform default: OFF</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CME_CHTM_TRACE_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CME_CHTM_TRACE_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>CHTM Trace Memory Configuration value goes directly into CHTM_MEM register. User is responsible to put correct data for each bit field of the register. Consumer: p9_hcode_image_build.c -&gt; SGPE Header field Platform default: 0</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CME_CHTM_TRACE_MEMORY_CONFIG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CME_CHTM_TRACE_MEMORY_CONFIG</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0x00</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Enables the PGPE Hcode to physically perform frequency and voltage operations based on constructed parameters (eg #V VPD, system parameters, biases, WPF VFRTs. etc). If OFF, the PGPE provides an immedicate good response to all Pstate/WOF IPC operations from the OCC for firmware integration testing purposes. Consumer: p9_hcode_image_build.c -&gt; PGPE Header field Platform default: ON</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PGPE_HCODE_FUNCTION_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PGPE_HCODE_FUNCTION_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Enables pstate parameter block code to use the static #W data Consumer: p9_pstate_parameter_block.C -&gt; Platform default: OFF</description>
    <hwpfToHbAttrMap>
      <id>ATTR_POUND_W_STATIC_DATA_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>POUND_W_STATIC_DATA_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Time between invocations of auxiliary function on GPE1. The time (in milliseconds) is derived as 2^ATTR_AUX_FUNC_INVOCATION_TIME_MS with 0 indicating the function is OFF. Consumer: p9_hcode_image_build.c -&gt; SGPE Header field Provided by the Machine Readable Workbook to tune the collection. Platform default: 1</description>
    <hwpfToHbAttrMap>
      <id>ATTR_AUX_FUNC_INVOCATION_TIME_MS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>AUX_FUNC_INVOCATION_TIME_MS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x01</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Enables pstate parameter block code to use the static system vfrt data Consumer: p9_pstate_parameter_block.C -&gt; Platform default: OFF</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYS_VFRT_STATIC_DATA_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYS_VFRT_STATIC_DATA_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>SYSTEM Attribute Nest leakage percentage used to calculate the Core leakage. Will eventually be read into OCC Pstate Parameter Block so the OCC can see it for it's calculations. Valid Values: 0% thru 100% Producer: Machine Readable Workbook Consumer: OCC Firmware</description>
    <hwpfToHbAttrMap>
      <id>ATTR_NEST_LEAKAGE_PERCENT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>NEST_LEAKAGE_PERCENT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x3C</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>The powerbus frequency that should be used to locate a valid #V bucket in the processor Module VPD if the actual ATTR_FREQ_PB_MHZ value isn't present.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_PB_MHZ_POUNDV_FALLBACK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_PB_MHZ_POUNDV_FALLBACK</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>NO_FALLBACK</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Switch to enable or disable 24x7 IMA. Based on the attribute value, a field of QPMR header of HOMER is populated while building HOMER. Based on the value in that field 24x7 code, which runs on GPE1, either starts or stops Nest IMA. Producer: Initialized by Hostboot firmware based on platform support Consumers: Read by p9_hcode_image_build.C</description>
    <hwpfToHbAttrMap>
      <id>ATTR_NEST_24x7_PERF_ACCUM_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>NEST_24x7_PERF_ACCUM_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>TRUE</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>env: 1 = Awan/HWSimulator. 0 = Simics/RealHW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IS_SIMULATION</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IS_SIMULATION</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Which execution platform the HW Procedure is running on Some HWPs (e.g. special wakeup) use different registers for different platforms to avoid arbitration problems when multiple platforms do the same thing concurrently</description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXECUTION_PLATFORM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXECUTION_PLATFORM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>The manufacturing flags. This is a bitfield. Each bit is a flag and multiple flags can be set</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MNFG_FLAGS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MNFG_FLAGS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0x0000000000000000</default>
      </uint64_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Defines system specific value of DMI refclock receiver termination (FSI GP4 bits 8:9)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_DMI_REFCLOCK_RCVR_TERM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_DMI_REFCLOCK_RCVR_TERM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines system specific value of DDR refclock receiver termination (FSI GP4 bits 10:11)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_DDR_REFCLOCK_RCVR_TERM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_DDR_REFCLOCK_RCVR_TERM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Centaur DQ to DIMM connector DQ mapping. Uint8 value for each Centaur DQ (0-79). The value is the corresponding DIMM Connector DQ. Therefore if (data[2] == 60) then Centaur DQ 2 maps to DIMM DQ 60 If the logical DIMM is on a Centaur-DIMM then the value is the same as the array index because there is no DIMM connector. If the logical DIMM is an IS-DIMM then the value depends on board wiring.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_DQ_TO_DIMM_CONN_DQ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_DQ_TO_DIMM_CONN_DQ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>80</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>MBA Chiplet port this DIMM is connected to</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MBA_PORT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MBA_PORT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>MBA port DIMM number of this DIMM</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MBA_DIMM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MBA_DIMM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>VPD index for associated chip's memory buffer VPD</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_ISDIMM_MBVPD_INDEX</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_ISDIMM_MBVPD_INDEX</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Controls search boundaries for WR_VREF Ternary shmoo. Value is a delta of register ticks from nominal Default Value = 0x08 (taken from characterization values), Max value = 0x19</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MSS_VREF_CAL_DELTA_FROM_NOMINAL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MSS_VREF_CAL_DELTA_FROM_NOMINAL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x08</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>DRAM Write Vref. Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT) or mss_eff_cnfg_termination consumer: various.C and initfile firmware notes: none This is the nominal value This is for DDR3</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_EFF_DRAM_WR_VREF</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_EFF_DRAM_WR_VREF</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint32_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Centaur DQ and DQS Drive Impedance Used in various locations and comes from the MT Keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT)/mss_eff_cnfg_termination consumer: initfile,various.C files firmware notes: none This is the nominal value</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_EFF_CEN_DRV_IMP_DQ_DQS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_EFF_CEN_DRV_IMP_DQ_DQS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t>
        <default>OHM34_FFE0,OHM34_FFE0</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Centaur DQ and DQS Receiver Impedance Used in various locations and it comes from the VPD MT keyword for custom DIMMs or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD, mss_eff_cnfg_termination Consumer: initfile + C code firmware notes: none This is the nominal value</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_EFF_CEN_RCV_IMP_DQ_DQS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_EFF_CEN_RCV_IMP_DQ_DQS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Machine Readable Workbook safe mode throttle value for numerator cfg_nm_n_per_mba</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MRW_SAFEMODE_MEM_THROTTLE_NUMERATOR_PER_MBA</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MRW_SAFEMODE_MEM_THROTTLE_NUMERATOR_PER_MBA</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x00000060</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook safe mode throttle value for numerator cfg_nm_n_per_chip</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MRW_SAFEMODE_MEM_THROTTLE_NUMERATOR_PER_CHIP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MRW_SAFEMODE_MEM_THROTTLE_NUMERATOR_PER_CHIP</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x00000020</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>At a system level, this attribute controls if interleaving is required, requested or never. The MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MRW_MBA_CACHELINE_INTERLEAVE_MODE_CONTROL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MRW_MBA_CACHELINE_INTERLEAVE_MODE_CONTROL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x02</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of on or off. Determines if prefetching enabled or not. See chapter 7 of the Centaur Workbook.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MSS_PREFETCH_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MSS_PREFETCH_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>ON</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of on or off. Determines if the cleaner of the L4 cache (write modified entries to memory on idle cycles) enabled or not. See chapter 7 of the Centaur Workbook.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MSS_CLEANER_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MSS_CLEANER_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>When this value is true, then mss_eff config will allow a single port to have one dimm and will allow ports to have different sizes. Used in eff_config</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MSS_ALLOW_SINGLE_PORT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MSS_ALLOW_SINGLE_PORT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>FALSE</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>DQS Swizzle type is set by the platform to describe what kind of DQS connection is being used for register acceses. Type 0 is normal, type 1 is for systems with wiring like glacier 1, type 2 is for Pallmeto. Additional types maybe defined if new boards have even different DQS swizzle features</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MSS_DQS_SWIZZLE_TYPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MSS_DQS_SWIZZLE_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>The MRW for a system should set this to TRUE for systems that must obey plug rules. Lab environments should default this to off and allow the user to override using normal methods to test.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MRW_STRICT_MBA_PLUG_RULE_CHECKING</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MRW_STRICT_MBA_PLUG_RULE_CHECKING</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Used for Custom DIMMs to not enable the reading of the dimm temperature sensor on the master i2c bus</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MRW_CDIMM_MASTER_I2C_TEMP_SENSOR_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MRW_CDIMM_MASTER_I2C_TEMP_SENSOR_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Used for Custom DIMMs to not enable the reading of the dimm temperature sensor on the spare i2c bus</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MRW_CDIMM_SPARE_I2C_TEMP_SENSOR_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MRW_CDIMM_SPARE_I2C_TEMP_SENSOR_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x01</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook Thermal Memory Power Limit</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MRW_THERMAL_MEMORY_POWER_LIMIT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MRW_THERMAL_MEMORY_POWER_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x00000d2f</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Capable power control settings. In MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MRW_POWER_CONTROL_REQUESTED</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MRW_POWER_CONTROL_REQUESTED</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Slope value used to determine the dynamic VID DDR3 VDDR adjustment for all parts. In uV/Centaur.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MSS_DDR3_VDDR_SLOPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MSS_DDR3_VDDR_SLOPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x000000FA</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Intercept value used to determine the dynamic VID DDR3 VDDR adjustment for all parts. In mV.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MSS_DDR3_VDDR_INTERCEPT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MSS_DDR3_VDDR_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x00000556</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Slope value used to determine the dynamic VID DDR3 VDDR adjustment for all parts. In uV/Centaur.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MSS_DDR4_VDDR_SLOPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MSS_DDR4_VDDR_SLOPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x000000FA</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Intercept value used to determine the dynamic VID DDR3 VDDR adjustment for all parts. In mV.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MSS_DDR4_VDDR_INTERCEPT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MSS_DDR4_VDDR_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x000004C4</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>List of Voltages that are compliant with the system. DIMMs that do not have voltages listed in their SPD as supported are errored out. Procedure defined is currently 1.2V and 1.35V only.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MSS_VOLT_COMPLIANT_DIMMS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MSS_VOLT_COMPLIANT_DIMMS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Option to control MCS prefetch retry threshold, for performance optimization. This attribute controls the number of retries in the prefetch engine. Retry threshold available ranges from 16 to 30. Note: Values outside those ranges will default to 30. In MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MRW_MCS_PREFETCH_RETRY_THRESHOLD</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MRW_MCS_PREFETCH_RETRY_THRESHOLD</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Maximum voltage limit for the dynamic VID DDR3 VDDR voltage setpoint. In mV.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MRW_DDR3_VDDR_MAX_LIMIT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MRW_DDR3_VDDR_MAX_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x00000591</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Maximum voltage limit for the dynamic VID DDR4 VDDR voltage setpoint. In mV.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MRW_DDR4_VDDR_MAX_LIMIT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MRW_DDR4_VDDR_MAX_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x000004f6</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook attribute that holds the step size of the VREF when doing a box shmoo</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MRW_WR_VREF_CHECK_VREF_STEP_SIZE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MRW_WR_VREF_CHECK_VREF_STEP_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x08</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Value to select amount of margin to be applied.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_DMI_CEN_TX_MARGIN_RATIO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_DMI_CEN_TX_MARGIN_RATIO</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Value to select amount of tx ffe postcusor to apply.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_DMI_CEN_TX_FFE_POSTCURSOR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_DMI_CEN_TX_FFE_POSTCURSOR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>System attribute. If all MCS chiplets are in an interleaving group (1=true, 0=false). - If true the SMP fabric is setup in normal mode and multiple MCSs are grouped (disallowing systems with memory only under 1 MCS (i.e. systems with a single C-DIMM)) - If false the SMP fabric is setup in checkerboard mode. Provided by the Machine Readable Workbook. This attribute is based on Machine-Type-Model (MTM) and is setup by the service processor.</description>
    <id>ALL_MCS_IN_INTERLEAVING_GROUP</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>The asynchronous nest frequency</description>
    <id>ASYNC_NEST_FREQ_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>2000</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Memory AVDD voltage domain ID. All memory buffers in the same AVDD voltage domain will share the same ID. IDs are arbitrarily assigned, used for correlation between HB + HWSV, and are generated by genHwsvMrwXml.pl</description>
    <id>AVDD_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>BMC FRU ID attribute to report the system firmware levels to the BMC.</description>
    <id>BMC_FRU_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines where to apply Brazos rx_fifo_final_l2u_dly override settings for SW299500.</description>
    <id>BRAZOS_RX_FIFO_OVERRIDE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Specifies a target's CEC degraded mode domain. For example, all DIMMs are part of the DIMM CEC degraded mode domain.</description>
    <hasStringConversion />
    <id>CDM_DOMAIN</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <enumeration>
        <id>CDM_DOMAIN</id>
      </enumeration>
    </simpleType>
  </attribute>
  <attribute>
    <description>Cec Degraded Mode Policy flags Use the CDM_POLICIES enum to decode. If the appropriate bit is 1 then the policy mode is enabled, and those type of Guard records are disabled.</description>
    <id>CDM_POLICIES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>FRU ID attribute for centaur ECID data. This fru ID is used to report the ECID data to the BMC and make it available for systems which have then centaur chips soldered to the backplane.</description>
    <id>CENTAUR_ECID_FRU_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>The address offset which each Chiplet types pervasive address space used to represent the a chiplet. 0x00 to 0x0F =&gt; For P9 all non-core and non-cache chiplets 0x10 to 0x1F =&gt; All Cache Chiplets 0x20 to 0x37 =&gt; All Core Chiplets 0x38 to 0x3F =&gt; Multicast Operation</description>
    <id>CHIPLET_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>A unit's position within the chip with respect to similar units. Note that this value is relative to the parent chip, not a parent unit. This data is from the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CHIP_UNIT_POS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CHIP_UNIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Attribute indicating the target's class</description>
    <hasStringConversion />
    <id>CLASS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <enumeration>
        <id>CLASS</id>
      </enumeration>
    </simpleType>
  </attribute>
  <attribute>
    <description>CPU Attribute</description>
    <id>CPU_ATTR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>L1 Data Cache Line Size in bytes</description>
    <id>DATA_CACHE_LINE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>L1 Data Cache Size in KB</description>
    <id>DATA_CACHE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>DCache Associative Sets</description>
    <id>DCACHE_ASSOC_SETS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>DCache Line Size in bytes</description>
    <id>DCACHE_LINE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Used to tell I2C code whether to run I2C Engine 2 Port 0 in diag mode or not 0 = Use Diag Mode 1 = Disable Diag Mode</description>
    <id>DISABLE_I2C_ENGINE2_PORT0_DIAG_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Indicates if system should consider abus logic when deconfiguring in _deconfigureAssocProc(), will be overwritten on multi-node system</description>
    <id>DO_ABUS_DECONFIG</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines a negative percentage value that is applied to the ATTR_NOMINAL_FREQ_MHZ determined from MVPD #V. It is used to explicitly raise the value of MIN_FREQ_MHZ above what is specified by MVPD #V data. On FSP systems this is sourced from the power_management def file. Value must be between 0 and -100. A value of zero indicates no override.</description>
    <id>DPO_MIN_FREQ_PERCENT</id>
    <persistency>non-volatile</persistency>
    <range>
      <max>0</max>
      <min>-100</min>
    </range>
    <readable />
    <simpleType>
      <int32_t>
        <default>0</default>
      </int32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Dummy attribute with read-only permissions</description>
    <id>DUMMY_RO</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <complexType>
      <description>Structure to define the addressing for NV controller.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master.</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit value, but then shifted 2 bits left.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit value, but then shifted 6 bits left.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x03</default>
        <description>The number of bytes a device requires to set its internal address/offset. For NV controller it's only one byte addressing with no page select (3) 0 = Zero Byte Addressing 1 = One Byte Addressing with page select 2 = Two Byte Addressing 3 = OneByte Addressing with no page select</description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x01</default>
        <description>The number of kilobytes a device can hold. 'Zero' value possible for some devices.</description>
        <name>maxMemorySizeKB</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x01</default>
        <description>The number of chips making up an eeprom device.</description>
        <name>chipCount</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x01</default>
        <description>The maximum number of bytes that can be written to a device at one time. 'Zero' value means no maximum value is expected or checked.</description>
        <name>writePageSize</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x05</default>
        <description>The amount of time in milliseconds a device requires on the completion of a write command to update its internal memory.</description>
        <name>writeCycleTime</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux will connect to. OxFF indicates no mux present or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address the NV controller on the NVDIMM</description>
    <id>EEPROM_NV_INFO</id>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <complexType>
      <description>Structure to define the addressing for an I2C slave device.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x02</default>
        <description>The number of bytes a device requires to set its internal address/offset.</description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x100</default>
        <description>The number of kilobytes a device can hold. 'Zero' value possible for some devices.</description>
        <name>maxMemorySizeKB</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x04</default>
        <description>The number of chips making up an eeprom device.</description>
        <name>chipCount</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The maximum number of bytes that can be written to a device at one time. 'Zero' value means no maximum value is expected or checked.</description>
        <name>writePageSize</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The amount of time in milliseconds a device requires on the completion of a write command to update its internal memory.</description>
        <name>writeCycleTime</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux will connect to. OxFF indicates no mux present or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address the EERPROM slaves</description>
    <id>EEPROM_SBE_BACKUP_INFO</id>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <complexType>
      <description>Structure to define the addressing for an I2C slave device.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x02</default>
        <description>The number of bytes a device requires to set its internal address/offset.</description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x100</default>
        <description>The number of kilobytes a device can hold. 'Zero' value possible for some devices.</description>
        <name>maxMemorySizeKB</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x04</default>
        <description>The number of chips making up an eeprom device.</description>
        <name>chipCount</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The maximum number of bytes that can be written to a device at one time. 'Zero' value means no maximum value is expected or checked.</description>
        <name>writePageSize</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The amount of time in milliseconds a device requires on the completion of a write command to update its internal memory.</description>
        <name>writeCycleTime</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux will connect to. OxFF indicates no mux present or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address the EERPROM slaves</description>
    <id>EEPROM_SBE_PRIMARY_INFO</id>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <complexType>
      <description>Structure to define the addressing for an I2C slave device.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x02</default>
        <description>The number of bytes a device requires to set its internal address/offset.</description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The number of kilobytes a device can hold. 'Zero' value possible for some devices.</description>
        <name>maxMemorySizeKB</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x01</default>
        <description>The number of chips making up an eeprom device.</description>
        <name>chipCount</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The maximum number of bytes that can be written to a device at one time. 'Zero' value means no maximum value is expected or checked.</description>
        <name>writePageSize</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xA</default>
        <description>The amount of time in milliseconds a device requires on the completion of a write command to update its internal memory.</description>
        <name>writeCycleTime</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux will connect to. OxFF indicates no mux present or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address the EERPROM slaves</description>
    <id>EEPROM_VPD_BACKUP_INFO</id>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <complexType>
      <description>Structure to define the addressing for an I2C slave device.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x02</default>
        <description>The number of bytes a device requires to set its internal address/offset. DDR4 DIMMs require a special EEPROM page switching mechanic denoted here by a value of 1 0 = Zero Byte Addressing 1 = One Byte Addressing with page select 2 = Two Byte Addressing 3 = OneByte Addressing with no page select</description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The number of kilobytes a device can hold. 'Zero' value possible for some devices.</description>
        <name>maxMemorySizeKB</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x01</default>
        <description>The number of chips making up an eeprom device.</description>
        <name>chipCount</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The maximum number of bytes that can be written to a device at one time. 'Zero' value means no maximum value is expected or checked.</description>
        <name>writePageSize</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xA</default>
        <description>The amount of time in milliseconds a device requires on the completion of a write command to update its internal memory.</description>
        <name>writeCycleTime</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux will connect to. OxFF indicates no mux present or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address the EEPROM slaves</description>
    <id>EEPROM_VPD_PRIMARY_INFO</id>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <description>Attribute indicating the target's engine type</description>
    <hasStringConversion />
    <id>ENGINE_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <enumeration>
        <id>ENGINE_TYPE</id>
      </enumeration>
    </simpleType>
  </attribute>
  <attribute>
    <description>Logical fabric chip ID associated with this chip. Directly drives programming of pervasive chip ID registers (PIR). Compared with ATTR_PROC_EFF_FABRIC_CHIP_ID to configure FBC XOR masking. Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_CHIP_ID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FABRIC_CHIP_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Logical fabric group ID associated with this chip. Directly drives programming of pervasive group ID registers (PIR). Compared with ATTR_PROC_EFF_FABRIC_GROUP_ID to configure FBC XOR masking. Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_GROUP_ID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FABRIC_GROUP_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <complexType>
      <description>Structure to define addressing this I2C slave device.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux will connect to. OxFF indicates no mux present or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address an I2C slave device</description>
    <id>FAPI_I2C_CONTROL_INFO</id>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L2 Column Repairs allowed in the Field. creator: platform (generated based on MRW data)</description>
    <id>FIELD_TH_P8EX_L2_COL_REPAIRS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>7</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L2 Line Deletes allowed in the Field. creator: platform (generated based on MRW data)</description>
    <id>FIELD_TH_P8EX_L2_LINE_DELETES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>6</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L3 Column Repairs allowed in the Field. creator: platform (generated based on MRW data)</description>
    <id>FIELD_TH_P8EX_L3_COL_REPAIRS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>7</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L3 Line Deletes allowed in the Field. creator: platform (generated based on MRW data)</description>
    <id>FIELD_TH_P8EX_L3_LINE_DELETES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>6</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>System attribute. The frequency of the processor refclock in MHz. Provided by the MRW.</description>
    <id>FREQ_PROC_REFCLOCK</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>FRU ID attribute used to report FRU information to the BMC for each fru in the system.</description>
    <global />
    <id>FRU_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <complexType>
      <description>FSI flags</description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Set on FSI master chips (procs) if that chip uses slaveB to attach to the acting master chip.</description>
        <name>flipPort</name>
        <type>uint16_t</type>
      </field>
      <field>
        <bits>15</bits>
        <default>0</default>
        <description>Reserved for future expansion</description>
        <name>reserved</name>
        <type>uint16_t</type>
      </field>
    </complexType>
    <description>Reserved for any special flags we might need to access FSI</description>
    <id>FSI_OPTION_FLAGS</id>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <description>Size of FSP IO Region</description>
    <id>FSP_BAR_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0x0000000100000000</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <complexType>
      <description>Structure which defines a system's HB settings. Applicable for System target only.</description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Enable / Disable continuous trace. 0b0: Continuous trace is disabled. 0b1: Continuous trace is enabled.</description>
        <name>traceContinuous</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Override trace debug selection for SCAN component. 0b0: TRACS entries for SCAN have default behavior. 0b1: TRACS entries for SCAN are enabled.</description>
        <name>traceScanDebug</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Override trace debug selection for DBG component. 0b0: TRACS entries for DBG have default behavior. 0b1: TRACS entries for DBG are enabled.</description>
        <name>traceFapiDebug</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>5</bits>
        <default>0</default>
        <description>Reserved for future use</description>
        <name>reserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Attribute which describes how the SP has configured features in Hostboot.</description>
    <id>HB_SETTINGS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <writeable />
  </attribute>
  <attribute>
    <description>Hot Plug Controller values for a specific processor. Purpose: Holds information about the hot plug controllers so that a Hardware procedure is able to turn them on and off. Data Format: up to 8 Hot Plug Controllers x 7 variables of information This data is at the processor level. The needed information and their individual sizes are as follows: (1) I2C Master processor engine (uint8_t) (2) I2C Master processor port (uint8_t) (3) Bus Speed (uint16_t value: 2 uint8_t values: MSB, LSB) (4) Slave address (uint8_t) (5) Device type (uint8_t: see SUPPORTED_HOT_PLUG enum) (6) I2C Master processor node (uint8_t) (7) I2C Master processor position (uint8_t) Thus, the information will be 8 bytes.</description>
    <id>HOT_PLUG_POWER_CONTROLLER_INFO</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>8,8</array>
      <uint8_t>
        <default>0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Designates the speed at which a given I2C bus should run. Creator: MRW Purpose: Used by FW to know the fastest possible bus speed that all of the devices on a given bus are able to use. Data Format: 4x13 array of uint16_t values. The first index indicates the engine number of the bus. The second index indicates the port number of the bus. The value in the array is the I2C bus speed used for that engine/port combination in KHz.</description>
    <id>I2C_BUS_SPEED_ARRAY</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4,13</array>
      <uint16_t>
        <default>0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <complexType>
      <description>Structure to define the addressing for an I2C mux target.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master.</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x00</default>
        <description>Port from the I2C Master device. This is a 6-bit value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x00</default>
        <description>Device address on the I2C bus. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x00</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Information used to control a specific i2c mux device, to select a particular target bus.</description>
    <id>I2C_MUX_INFO</id>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <description>MCS Inband Scom base address</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MCS_INBAND_BASE_ADDRESS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IBSCOM_MCS_BASE_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0x0003E00000000000</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>PROC Inband Scom base address</description>
    <id>IBSCOM_PROC_BASE_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0x0003E00000000000</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>ICache Assoc Sets</description>
    <id>ICACHE_ASSOC_SETS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>ICache Block Size in bytes</description>
    <id>ICACHE_BLOCK_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Icache Line Size in bytes</description>
    <id>ICACHE_LINE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>ICache Size in KB</description>
    <id>ICACHE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Size of IMT IO Region Set by FSP-based tooling</description>
    <id>IMT_BAR_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0x0000000000000000</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Base Address of In-Memory Trace Region Set by FSP-based tooling</description>
    <id>IMT_BASE_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0xFFFFFFFFFFFFFFFF</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>L2 Cache Assoc Sets</description>
    <id>L2_CACHE_ASSOC_SETS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>L2 Cache Line Size in bytes</description>
    <id>L2_CACHE_LINE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>L2 Cache Size in KB</description>
    <id>L2_CACHE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>L3 Cache Line Size in bytes</description>
    <id>L3_CACHE_LINE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>L3 Cache Size in KB</description>
    <id>L3_CACHE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Location code of the Fru target</description>
    <id>LOCATION_CODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <string>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
  </attribute>
  <attribute>
    <description>System attribute. The max chiplets per proc available in the system.</description>
    <id>MAX_CHIPLETS_PER_PROC</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>System attribute. The max DIMMs per MBA Port available in the system.</description>
    <id>MAX_DIMMS_PER_MBA_PORT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>System attribute. The max DMI units per proc available in the system.</description>
    <id>MAX_DMI_PER_PROC</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>8</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>System attribute. The max EX units per proc chip available in the system.</description>
    <id>MAX_EXS_PER_PROC_CHIP</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>System attribute. The max MBAS per membuf available in the system.</description>
    <id>MAX_MBAS_PER_MEMBUF_CHIP</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>System attribute. The max MBA ports per MBA available in the system.</description>
    <id>MAX_MBA_PORTS_PER_MBA</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines the maximum Seeprom storage size for the fully-customized SBE image permitted by the platform. For platforms (FSP/HB FW) which require the image to be constrained into a physical storage device (SEEPROM), this should reflect the maximum size of that memory (e.g., 256KB). For platforms (Cronus) which may use a customized image in a virtual envrionment with no physical storage constraints, this size may be larger than the physical SEEPROM size.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MAX_SBE_SEEPROM_SIZE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MAX_SBE_SEEPROM_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x40000</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>MBA port DIMM number of this DIMM (deprecated in favor of POS_ON_MEM_PORT)</description>
    <id>MBA_DIMM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>MBA port this DIMM is connected to (deprecated in favor of MEM_PORT)</description>
    <id>MBA_PORT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Memory port this DIMM is connected to</description>
    <id>MEM_PORT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Due to fabric limitations, we can only enable 2 links at a time during wrap testing. This attribute defines which set this ABUS link belong to. This attribute will live on the OBUS target. The value will come from MRW. When the value for this attribute matches MFG_WRAP_TEST_ABUS_LINKS_SET_ENABLE, then we leave the OBUSes configured. Otherwise, we deconfigure them.</description>
    <id>MFG_WRAP_TEST_ABUS_LINKS_SET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <enumeration>
        <default>SET_NONE</default>
        <id>MFG_WRAP_TEST_ABUS_LINKS_SET</id>
      </enumeration>
    </simpleType>
  </attribute>
  <attribute>
    <description>System attribute 8 bit rx_min_eye_height value for A bus interfaces during system manufacturing creator: platform firmware notes: Attribute value is in the Machine Readable Workbook</description>
    <id>MNFG_ABUS_MIN_EYE_HEIGHT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>System attribute 6 bit rx_min_eye_width value for A bus interfaces during system manufacturing creator: platform firmware notes: Attribute value is in the Machine Readable Workbook</description>
    <id>MNFG_ABUS_MIN_EYE_WIDTH</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>System attribute. 8 bit rx_min_eye_height value for DMI bus interfaces during system manufacturing; used for both centaur and p8 creator: platform firmware notes: Attribute value is in the Machine Readable Workbook</description>
    <id>MNFG_DMI_MIN_EYE_HEIGHT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>System attribute. 6 bit rx_min_eye_width value for DMI bus interfaces during system manufacturing; used for both centaur and p8 creator: platform firmware notes: Attribute value is in the Machine Readable Workbook</description>
    <id>MNFG_DMI_MIN_EYE_WIDTH</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the maximum number of L4 Cache CEs allowed. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_CEN_L4_CACHE_CES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Base threshold (for 2GB DRAM ) of Memory CEs allowed during IPL. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_CEN_MBA_IPL_SOFT_CE_TH_ALGO</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the maximum number of Memory RCEs allowed per Rank during runtime. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_CEN_MBA_RT_RCE_PER_RANK</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Base threshold (for 2GB DRAM ) of Memory CEs allowed during runtime. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_CEN_MBA_RT_SOFT_CE_TH_ALGO</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>With MNFG thresholds enabled, PRD will make a predictive callout when a memory intermittent MPE attention count is equal to this value. A value of 0 defaults to the max threshold of 0xff.</description>
    <id>MNFG_TH_MEMORY_IMPES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>With MNFG thresholds enabled, PRD will make a predictive callout when a memory intermittent UE attention count is equal to this value. A value of 0 defaults to the max threshold of 0xff.</description>
    <id>MNFG_TH_MEMORY_IUES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L2 Cache CEs allowed during Manufacturing. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_P8EX_L2_CACHE_CES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L2 Column Repairs allowed during Manufacturing. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_P8EX_L2_COL_REPAIRS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L2 Directory CEs allowed during Manufacturing. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_P8EX_L2_DIR_CES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L2 Line Deletes allowed during Manufacturing. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_P8EX_L2_LINE_DELETES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L3 Cache CEs allowed during Manufacturing. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_P8EX_L3_CACHE_CES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>3</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L3 Column Repairs allowed during Manufacturing. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_P8EX_L3_COL_REPAIRS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L3 Directory CEs allowed during Manufacturing. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_P8EX_L3_DIR_CES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L3 Line Deletes allowed during Manufacturing. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_P8EX_L3_LINE_DELETES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>With MNFG thresholds enabled, PRD will make a predictive callout when an RCD parity error (recovery enabled) attention count is equal to this value. A value of 0 defaults to the max threshold of 0xff.</description>
    <id>MNFG_TH_RCD_PARITY_ERRORS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>System attribute 6 bit rx_min_eye_width value for X bus interfaces during system manufacturing creator: platform firmware notes: Attribute value is in the Machine Readable Workbook</description>
    <id>MNFG_XBUS_MIN_EYE_WIDTH</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Attribute indicating the target's model</description>
    <hasStringConversion />
    <id>MODEL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <enumeration>
        <id>MODEL</id>
      </enumeration>
    </simpleType>
  </attribute>
  <attribute>
    <description>Maximum voltage limit for the dynamic VID DDR3 VDDR voltage setpoint. In mV.</description>
    <id>MRW_DDR3_VDDR_MAX_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Maximum voltage limit for the dynamic VID DDR3 VDDR voltage setpoint. In mV.</description>
    <id>MRW_DDR3_VDDR_MAX_LIMIT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Maximum voltage limit for the dynamic VID DDR4 VDDR voltage setpoint. In mV.</description>
    <id>MRW_DDR4_VDDR_MAX_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Maximum voltage limit for the dynamic VID DDR4 VDDR voltage setpoint. In mV.</description>
    <id>MRW_DDR4_VDDR_MAX_LIMIT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Machine Readable Workbook throttle value for denominator cfg_nm_m</description>
    <id>MRW_MEM_THROTTLE_DENOMINATOR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>AVDD memory programming type 0 = POWERON - domain is programmed as part of regular power on sequence, 1 = STATIC - domain needs to be programmed, no special computation needed, 2 = DYNAMIC - domain needs to be programmed, uses dynamic vid logic</description>
    <hasStringConversion />
    <id>MSS_AVDD_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Units: mV</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_AVDD_SLOPE_INTERCEPT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_CENT_AVDD_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Units: uV/Membuf</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_AVDD_SLOPE_ACTIVE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_CENT_AVDD_SLOPE_ACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Units: uV/Membuf</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_AVDD_SLOPE_INACTIVE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_CENT_AVDD_SLOPE_INACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Units: mV</description>
    <id>MSS_CENT_VCS_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Units: uV/Membuf</description>
    <id>MSS_CENT_VCS_SLOPE_ACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Units: uV/Membuf</description>
    <id>MSS_CENT_VCS_SLOPE_INACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Units: mV</description>
    <id>MSS_CENT_VDD_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Units: uV/Membuf</description>
    <id>MSS_CENT_VDD_SLOPE_ACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Units: uV/Membuf</description>
    <id>MSS_CENT_VDD_SLOPE_INACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>sets the Centaur address bits used to interleave addresses between MBA01 and MBA23. valid values are 23 through 32.</description>
    <id>MSS_MBA_ADDR_INTERLEAVE_BIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>centaur interleave mode. 1 = 256-BIT, 0 = 128-BIT.</description>
    <id>MSS_MBA_CACHELINE_INTERLEAVE_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>VCS memory programming type 0 = POWERON - domain is programmed as part of regular power on sequence, 1 = STATIC - domain needs to be programmed, no special computation needed, 2 = DYNAMIC - domain needs to be programmed, uses dynamic vid logic</description>
    <hasStringConversion />
    <id>MSS_VCS_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>VDDR memory programming type 0 = POWERON - domain is programmed as part of regular power on sequence, 1 = STATIC - domain needs to be programmed, no special computation needed, 2 = DYNAMIC - domain needs to be programmed, uses dynamic vid logic, 3 = DEFAULT - domain needs to be programmed, pgm values in sys xml file</description>
    <hasStringConversion />
    <id>MSS_VDDR_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>VDD memory programming type 0 = POWERON - domain is programmed as part of regular power on sequence, 1 = STATIC - domain needs to be programmed, no special computation needed, 2 = DYNAMIC - domain needs to be programmed, uses dynamic vid logic</description>
    <hasStringConversion />
    <id>MSS_VDD_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Units: mV</description>
    <id>MSS_VOLT_DDR3_VDDR_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Units: mV</description>
    <id>MSS_VOLT_DDR3_VDDR_INTERCEPT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Units: 1/Amps</description>
    <id>MSS_VOLT_DDR3_VDDR_SLOPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Units: 1/Amps</description>
    <id>MSS_VOLT_DDR3_VDDR_SLOPE_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Units: mV</description>
    <id>MSS_VOLT_DDR4_VDDR_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Units: mV</description>
    <id>MSS_VOLT_DDR4_VDDR_INTERCEPT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Units: 1/Amps</description>
    <id>MSS_VOLT_DDR4_VDDR_SLOPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Units: 1/Amps</description>
    <id>MSS_VOLT_DDR4_VDDR_SLOPE_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Units: mV</description>
    <id>MSS_VOLT_VPP_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Units: mV</description>
    <id>MSS_VOLT_VPP_INTERCEPT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Units: uV/DRAM</description>
    <id>MSS_VOLT_VPP_SLOPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Units: uV/DRAM</description>
    <id>MSS_VOLT_VPP_SLOPE_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>VPP memory programming type 0 = POWERON - domain is programmed as part of regular power on sequence, 1 = STATIC - domain needs to be programmed, no special computation needed, 2 = DYNAMIC - domain needs to be programmed, uses dynamic vid logic</description>
    <hasStringConversion />
    <id>MSS_VPP_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Nest VCS Voltage Rail ID. The ID is an arbitrary value and is needed as correlation token between HB and HWSV. It will be generated by the genHwsvMrwXml.pl</description>
    <id>NEST_VCS_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Nest VDDR Voltage Rail ID. The ID is an arbitrary value and is needed as correlation token between HB and HWSV. It will be generated by the genHwsvMrwXml.pl</description>
    <id>NEST_VDDR_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Nest VDD Voltage Rail ID. The ID is an arbitrary value and is needed as correlation token between HB and HWSV. It will be generated by the genHwsvMrwXml.pl</description>
    <id>NEST_VDD_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Nest VDN Voltage Rail ID. The ID is an arbitrary value and is needed as correlation token between HB and HWSV. It will be generated by the genHwsvMrwXml.pl</description>
    <id>NEST_VDN_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Nest VIO Voltage Rail ID. The ID is an arbitrary value and is needed as correlation token between HB and HWSV. It will be generated by the genHwsvMrwXml.pl</description>
    <id>NEST_VIO_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>NPU MMIO BAR base address values creator: platform consumer: proc_setup_bars firmware notes: 64-bit address representing BAR RA NOTE: BAR register covers RA 14:51 first dimension: unit number (0:3) second dimension: BAR number (0:1)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_NPU_MMIO_BAR_BASE_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>NPU_MMIO_BAR_BASE_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4,2</array>
      <uint64_t>
        <default>0</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>NPU MMIO BAR size values creator: platform consumer: proc_setup_bars firmware notes: none first dimension: unit number (0:3) second dimension: BAR number (0:1)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_NPU_MMIO_BAR_SIZE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>NPU_MMIO_BAR_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4,2</array>
      <uint64_t>
        <default>0</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <complexType>
      <description>Numeric POD type test structure</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path for testing purposes</description>
        <name>fsiPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>CHIP</default>
        <description>Class for testing purposes</description>
        <name>className</name>
        <type>CLASS</type>
      </field>
      <field>
        <default>0xAB</default>
        <description>Test uint8</description>
        <name>uint8</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xABCD</default>
        <description>Test uint16</description>
        <name>uint16</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xABCDEF01</default>
        <description>Test uint32</description>
        <name>uint32</name>
        <type>uint32_t</type>
      </field>
      <field>
        <default>0xABCDEF0123456789</default>
        <description>Test uint64</description>
        <name>uint64</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>-124</default>
        <description>Test int8</description>
        <name>int8</name>
        <type>int8_t</type>
      </field>
      <field>
        <default>-32764</default>
        <description>Test int16</description>
        <name>int16</name>
        <type>int16_t</type>
      </field>
      <field>
        <default>-2147483644</default>
        <description>Test int32</description>
        <name>int32</name>
        <type>int32_t</type>
      </field>
      <field>
        <default>-9223372036854775804</default>
        <description>Test int64</description>
        <name>int64</name>
        <type>int64_t</type>
      </field>
    </complexType>
    <description>Attribute which tests numeric POD types</description>
    <id>NUMERIC_POD_TYPE_TEST</id>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <description>Lane mask for which 8 lanes belong to this brick This is a right justified 24-bit value. Only 8 of the 24 bits will be set representing the lanes belonging to the associated brick. Provided by the MRW.</description>
    <id>OBUS_BRICK_LANE_MASK</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Attribute indicating what kind of payload is to be started.</description>
    <hasStringConversion />
    <id>PAYLOAD_KIND</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <enumeration>
        <id>PAYLOAD_KIND</id>
      </enumeration>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Base Address of PCI 32 bit Memory Space</description>
    <id>PCI_BASE_ADDRS_32</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Base Address of PCI 64 bit Memory Space</description>
    <id>PCI_BASE_ADDRS_64</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines system specific value of PCI refclock receiver termination (FSI GP4 bits 10:11)</description>
    <hasStringConversion />
    <id>PCI_REFCLOCK_RCVR_TERM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Effective PCIE IOP reversal configuration Creator: Firmware Purpose: Holds the effective PCIE IOP reversal value after taking into account any IOP bifurcations. If no IOP bifurcations present, this is just the value of the PROC_PCIE_IOP_REVERSAL_NON_BIFURCATED attribute. Data Format: x4 array of uint8_t values. The first uint8_t value is for lane set 0, the second for lane set 1 and so on. The given index in the array is a mask which specifies which bit to invert in the lane swap settings for the given PEC/lane set.</description>
    <id>PEC_PCIE_IOP_REVERSAL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Base PCIE IOP reversal configuration Creator: Firmware Purpose: Holds the PCIE IOP reversal value for cases where the IOP is bifurcated Data Format: x4 array of uint8_t values. The first uint8_t value is lane set 0, the second for lane set 2 and so on. The given index in the array is a mask which specifies which bit to invert in the lane swap settings for the given lane set</description>
    <id>PEC_PCIE_IOP_REVERSAL_BIFURCATED</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Base PCIE IOP reversal configuration Creator: Firmware Purpose: Holds the base PCIE IOP reversal value without considering IOP bifurcation. Data Format: x4 array of uint8_t values. The first uint8_t value is for lane set 0, the second for lane set 1 and so on. The given index in the array is a mask which specifies which bit to invert in the lane swap settings for the given lane set.</description>
    <id>PEC_PCIE_IOP_REVERSAL_NON_BIFURCATED</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Bifurcated PCIE IOP swap configuration value Creator: MRW Purpose: Holds the base IOP swap configuration value for the IOPs in the case where they are bifurcated. The swap value controls how PCIE lanes are recordered when the leave the IOP, to provide lane routing flexibility. Data Format: A uint8_t value. The value specifices for the hardware how to swap the PCIE lanes for the given PEC.</description>
    <id>PEC_PCIE_IOP_SWAP_BIFURCATED</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>PCIE Lane Mask bifurcated configuration Creator: MRW Purpose: Holds the PCIE lane mask assuming IOPs are bifurcated. Data Format: x4 array of uint16_t values. The first uint8_t value is lane set 0, the second for lane set 2 and so on. A lane set mask indicates which groups of lanes are assigned to an IOP. For instance, lane set 0 value of 0xFF00 and lane set 1 value of 0x00FF means the IOP is bifurcated into two x8s.</description>
    <id>PEC_PCIE_LANE_MASK_BIFURCATED</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Peer target's address of a A/X-bus connection. NULL means address 0 for no peer target. If a target instance overrides the default with the peer target's PHYS_PATH. The target compiler will convert the valid PHYS_PATH string into the runtime virtual address of the peer target instance.</description>
    <id>PEER_TARGET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <Target_t>
        <default>NULL</default>
      </Target_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Base Address of PHB Register Space</description>
    <id>PHB_BASE_ADDRS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint64_t>
        <default>0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Physical hierarchical path to the target</description>
    <id>PHYS_PATH</id>
    <mrwRequired />
    <nativeType>
      <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <description>Set to 1 by HWSV to indicate that attribute overrides exist in a PLCK IPL (not an IPL by steps). This is read by Hostboot to determine if it needs to request the attribute overrides from HWSV before starting its IPL.</description>
    <id>PLCK_IPL_ATTR_OVERRIDES_EXIST</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Position of target relative to node</description>
    <id>POSITION</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Position of this DIMM on its memory port</description>
    <id>POS_ON_MEM_PORT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Hierarchical path to the target with respect to power</description>
    <id>POWER_PATH</id>
    <nativeType>
      <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <complexType>
      <description>Structure which defines a target's primary capabilities. A target can only support at most FSI SCOM and one of the other two SCOM types. Applicable for all targets. Structure is read-only.</description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Target does not support FSI SCOM; 0b1: Target supports FSI SCOM</description>
        <name>supportsFsiScom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Target does not support XSCOM; 0b1: Target supports FSI XSCOM</description>
        <name>supportsXscom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Target does not support inband SCOM</description>
        <name>supportsInbandScom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>5</bits>
        <default>0</default>
        <description>Reserved for future use</description>
        <name>reserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Attribute which describes capabilities of a target</description>
    <id>PRIMARY_CAPABILITIES</id>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <description>PROC_CHIP Attribute If true, the chip is installed on a Dual Chip Module Provided by the Machine Readable Workbook</description>
    <id>PROC_DCM_INSTALLED</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>PCIE IOP lane configuration creator: platform consumer: p9_pcie_scominit firmware notes: These are config dependent attributes based on PCIe Lane/sideband signal routing and PCIe endpoints attached. Encoded PCIE IOP lane configuration PEC0: PHB0 CFG[0:1] SWP[0] Examples: Config #1 PEC0 Lane Config[0:1] = 0b00 PHB0 Swap bit[0] = 0 (Straight lane wiring) Config #2 PEC0 Lane Config[0:1] = 0b00 PHB0 Swap bit[0] = 1 (Reverse lane wiring) PEC1: PHB1 CFG[0:1] SWP[0] PHB2 CFG[2:3] SWP[1] Examples: Config #1 PEC1 Lane Config[0:3] = 0b0000 PHB1 Swap bit[0] = 0 (Straight lane wiring) PHB2 Swap bit[1] = 0 (Straight lane wiring) Config #2 PEC1 Lane Config[0:3] = 0b0000 PHB1 Swap bit[0] = 1 (Reverse lane wiring) PHB2 Swap bit[1] = 0 (Straight lane wiring) PEC2: CFG[0:1] = 0b00 PHB3 CFG[2:3]; SWP[0] CFG[4:5] = don't care SWP[1:2] = don't care CFG[0:1] = 0b01 PHB3 CFG[2:3]; SWP[0] PHB4 CFG[4:5]; SWP[1] PHB5 SWP[2] = don't care CFG[0:1] = 0b10 PHB3 CFG[2:3]; SWP[0] PHB4 CFG[4]; SWP[1] PHB5 CFG[5]; SWP[2] Examples: Config #1 (PEC2 Lane Config[0:5] = 0b000000) PHB3 Swap bit[0] = 0 (Straight lane wiring) PHB4 Swap bit[1] = don't care PHB5 Swap bit[2] = don't care Config #1 (PEC2 Lane Config[0:5] = 0b010000) PHB3 Swap bit[0] = 1 (Reverse lane wiring) PHB4 Swap bit[1] = 0 (Straight lane wiring) PHB5 Swap bit[2] = don't care Config #3 (PEC2 Lane Config[0:5] = 0b100000) PHB3 Swap bit[0] = 1 (Reverse lane wiring) PHB4 Swap bit[1] = 0 (Straight lane wiring) PHB5 Swap bit[2] = 1 (Reverse lane wiring)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_CONFIG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_IOP_CONFIG</id>
    <ignoreEkb />
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Indicates whether PCIE lanes terminate at a pluggable slot Creator: MRW Purpose: Used by FW to know whether the given PCIE lanes terminate at a pluggable slot or not. If this is the case, and the platform supports bifurcation, the card's VPD should be interrogated to determine whether to bifurcate the IOP or not. Data Format: x4 array of uint8_t values. The first value indicates whether lane set 0 terminates at a pluggable slot. The next three values indicate the same for lane sets 1-3. A value of 1 at a given array index indicates the lanes terminate at a pluggable slot, 0 otherwise.</description>
    <id>PROC_PCIE_IS_SLOT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>PCIE Lane Equalization values for each PHB Creator: MRW Purpose: Holds settings which are loaded into the HW to optimize the PCIE lane signal eye between the chips + PCIE Gen3 endpoints Data Format: 16 entries of 16 bytes of EQ data per PHB. Each PHB has an EQ value for each of its 16 lanes. Each value is a uint16 formatted as follows: Bit 0:3 - up_rx_hint (bit 0 reserved) Bit 4:7 - up_tx_preset Bit 8:11 - dn_rx_hint (bit 0 reserved) Bit 12:15 - dn_tx_preset</description>
    <id>PROC_PCIE_LANE_EQUALIZATION_GEN3</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>16</array>
      <uint16_t>
        <default>0x7777,0x7777,0x7777,0x7777, 0x7777,0x7777,0x7777,0x7777, 0x7777,0x7777,0x7777,0x7777, 0x7777,0x7777,0x7777,0x7777</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>PCIE Lane Equalization values for each PHB Creator: MRW Purpose: Holds settings which are loaded into the HW to optimize the PCIE lane signal eye between the chips + PCIE Gen4 endpoints Data Format: 16 entries of 16 bytes of EQ data per PHB. Each PHB has an EQ value for each of its 16 lanes. Each value is a uint16 formatted as follows: Bit 0:3 - up_rx_hint (bit 0 reserved) Bit 4:7 - up_tx_preset Bit 8:11 - dn_rx_hint (bit 0 reserved) Bit 12:15 - dn_tx_preset</description>
    <id>PROC_PCIE_LANE_EQUALIZATION_GEN4</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>16</array>
      <uint16_t>
        <default>0x7777,0x7777,0x7777,0x7777, 0x7777,0x7777,0x7777,0x7777, 0x7777,0x7777,0x7777,0x7777, 0x7777,0x7777,0x7777,0x7777</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>PCS rx loff control creator: platform consumer: p9_pcie_scominit firmware notes: The value of rx loff control for PCS. Array index: Configuration number index 0~3 for CONFIG0~3</description>
    <id>PROC_PCIE_PCS_RX_LOFF_CONTROL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of PCS rx phase rotator control creator: platform consumer: p9_pcie_scominit</description>
    <id>PROC_PCIE_PCS_RX_PHASE_ROTATOR_CNTL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of PCS rx sigdet control creator: platform consumer: p9_pcie_scominit</description>
    <id>PROC_PCIE_PCS_RX_SIGDET_CNTL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>PCS rx vga control register3 creator: platform consumer: p9_pcie_scominit firmware notes: The value of rx vga control register3. Array index: Configuration number index 0~3 for CONFIG0~3</description>
    <id>PROC_PCIE_PCS_RX_VGA_CONTRL_REGISTER3</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of PCS system control creator: platform consumer: p9_pcie_scominit firmware notes: These are config dependent attributes based on PCIe Lane/sideband signal routing and PCIe endpoints attached. There are four groups of four lanes: 0-3 (A-D), 4-7 (E-H), 8-11(I-L), and 12-15(M-P). Each lane group can be assigned to a MAC interface. The supported configurations are as follows: 1. MAC #1 = x16, MAC #2 = N/A, MAC #3 = N/A, MAC #4 = N/A : PCS_SYSTEM_CONTROL_REG = 0x0000. 2. MAC #1 = x8, MAC #2 = x8, MAC #3 = N/A, MAC #4 = N/A : PCS_SYSTEM_CONTROL_REG = 0x0050. 3. MAC #1 = x8, MAC #2 = x4, MAC #3 = x4, MAC #4 = N/A : PCS_SYSTEM_CONTROL_REG = 0x0090. All other configurations are not supported.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PCS_SYSTEM_CNTL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_PCS_SYSTEM_CNTL</id>
    <ignoreEkb />
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Value of PCS tx fifo config offset creator: platform consumer: p9_pcie_scominit</description>
    <id>PROC_PCIE_PCS_TX_FIFO_CONFIG_OFFSET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>PCIE PHB valid mask creator: platform consumer: proc_pcie_scominit firmware notes: Bit mask defining set of active/valid PHBs bit0=PHB0, bit1=PHB1, bit2=PHB2, bit3=PHB3</description>
    <id>PROC_PCIE_PHB_ACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Defines system specific value of processor refclock receiver termination (FSI GP4 bits 8:9)</description>
    <hasStringConversion />
    <id>PROC_REFCLOCK_RCVR_TERM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>The number of reconfig loops allowed due to RCD parity errors when recovery is disabled. PRD will make a predictive callout and stop issuing reconfigs due to RCD parity errors when RCD_PARITY_RECONFIG_LOOP_COUNT is greater than this value. A value of 0 indicates that no reconfig loops are allowed due to RCD parity errors.</description>
    <id>RCD_PARITY_RECONFIG_LOOPS_ALLOWED</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>1 = System has redundant clock oscillators 0 = System does not have redundant clock oscillators From the Machine Readable Workbook</description>
    <id>REDUNDANT_CLOCKS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Used to tell if a resource is critical to perform an IPL. If this attribute is set to 1 and the target is deconfigured, the IPL MUST terminate.</description>
    <id>RESOURCE_IS_CRITICAL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Size of RNG IO Region</description>
    <id>RNG_BAR_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0x000000000001000</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Base Address of RNG IO Region</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_NX_MMIO_BAR_BASE_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>RNG_BASE_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0xFFFFFFFFFFFFFFFF</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Control execution of updateProcessorSbeSeeproms() if 0, enable SBE update of processor SEEPROM if 1, disable SBE update of processor SEEPROM Consumer: sbe_update.C Default: 0</description>
    <id>SBE_UPDATE_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <complexType>
      <description>Structure which defines a system's SP functions. Applicable for System target only. Structure is read-only.</description>
      <field>
        <bits>1</bits>
        <default>1</default>
        <description>If this flag is set then mailboxEnabled MUST also be set 0b0: SP does not support for VPD, payload, ATTR sync, VDDR, TOD; 0b1: SP supports VPD, payload, ATTR sync, VDDR, TOD</description>
        <name>baseServices</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>1</default>
        <description>0b0: SP does not initialize FSI slave logic, Hostboot must; 0b1: SP does initialize FSI slave logic so Hostboot should not</description>
        <name>fsiSlaveInit</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: There is no SP mailbox support; 0b1: There is SP mailbox support</description>
        <name>mailboxEnabled</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>1</default>
        <description>0b0: SP does not initialize FSI master logic, Hostboot must; 0b1: SP does initialize FSI master logic so Hostboot should not</description>
        <name>fsiMasterInit</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>1</default>
        <description>0b0: SP does not perform hardware change detection, Hostboot must; 0b1: SP does perform hardware change detection (HCDB) so Hostboot should not</description>
        <name>hardwareChangeDetection</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>1</default>
        <description>0b0: SP does not perform Power Line Disturbance (PLD) detection, Hostboot must; 0b1: SP does perform Power Line Disturbance (PLD) detection so Hostboot should not</description>
        <name>powerLineDisturbance</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>26</bits>
        <default>0</default>
        <description>Reserved for future use</description>
        <name>reserved</name>
        <type>uint32_t</type>
      </field>
    </complexType>
    <description>Attribute which describes what the SP is or is not doing in this system</description>
    <id>SP_FUNCTIONS</id>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <description>Control CME response to execution of PowerPC STOP instruction if OFF, treat STOP5 as STOP5 if ON, treat STOP5 as STOP4 Producer: ??? Consumer: p9_hcode_image_build.C Platform default: ON</description>
    <hwpfToHbAttrMap>
      <id>ATTR_STOP5_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>STOP5_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>STOP levels supported at runtime (sent to Host via HDAT): Bit 0: STOP0 Supported - Quiesce thread only Bit 1: STOP1 Supported - P8 Nap Bit 2: STOP2 Supported - P8 Fast Sleep Bit 3: STOP3 Supported - P8 Fast Sleep using iVRMs Bit 4: STOP4 supported - P8 Deep Sleep Bit 5: STOP5 Supported - WOF-friendly "Instant on" Bit 6,7: Reserved Bit 8: STOP8 supported - Half Quad Sleep Bit 9: STOP9 supported - P8 Fast Winkle Bit 10: Reserved Bit 11: STOP11 supported - P8 Deep Winkle Bit 12-15 : Reserved Bits 16..31 - Reserved</description>
    <id>SUPPORTED_STOP_STATES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0xEC100000</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Do we support dynamically updating memory voltages? 0 = no, 1 = yes</description>
    <id>SUPPORTS_DYNAMIC_MEM_VOLT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This field is of the form "vendor,name" where the name indicates the family of the systems. The textual portion of the string has a maximum length of 63 characters to accommodate a terminating NULL. Both vendor and name fields are lower case US ASCII. No special characters other than ",", "-", and "+" as described below should be used in the string.</description>
    <id>SYSTEM_FAMILY</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <string>
        <default>ibm,p9</default>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
  </attribute>
  <attribute>
    <description>This field is of the form ?vendor,type? where the type indicates a type of system within the System Family. The textual portion of the string has a maximum length of 63 characters to accommodate a terminating NULL. Both vendor and name fields are lower case US ASCII. No special characters other than ",", "-", and "+" as described below should be used in the string. If identification of specific models within a system type is desired, "-model" should be appended to the end of the name. The "-model" portion is optional and could be used to identify the packaging, specific model numbers, etc. NOTE: No Hostboot code should ever key off of this value.</description>
    <id>SYSTEM_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <string>
        <default>ibm,miscopenpower</default>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
  </attribute>
  <attribute>
    <complexType>
      <description>Structure to define the addressing for an I2C slave device.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux will connect to. OxFF indicates no mux present or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address an I2C slave device</description>
    <id>TEMP_SENSOR_I2C_CONFIG</id>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <complexType>
      <description>Structure to define the addressing for an I2C TPM.</description>
      <field>
        <default>0x0</default>
        <description>Boolean indicating whether this TPM is available in the system</description>
        <name>tpmEnabled</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x01</default>
        <description>Port from the I2C Master device. This is a 6-bit value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xAE</default>
        <description>Device address on the I2C bus for Locality 0. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddrLocality0</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xA8</default>
        <description>Device address on the I2C bus for Locality 1. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddrLocality1</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xAA</default>
        <description>Device address on the I2C bus for Locality 2. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddrLocality2</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xA4</default>
        <description>Device address on the I2C bus for Locality 3. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddrLocality3</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xA6</default>
        <description>Device address on the I2C bus for Locality 4. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddrLocality4</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x00</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x01</default>
        <description>The number of bytes a device requires to set its internal address/offset.</description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux will connect to. OxFF indicates no mux present or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address the TPM slaves</description>
    <id>TPM_INFO</id>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <description>Setting to require(0x1) or not require(0x0) a functional TPM to boot the system.</description>
    <id>TPM_REQUIRED</id>
    <persistency>non-volatile</persistency>
    <range>
      <max>1</max>
      <min>0</min>
    </range>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Attribute indicating the target's type</description>
    <hasStringConversion />
    <id>TYPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <enumeration>
        <id>TYPE</id>
      </enumeration>
    </simpleType>
  </attribute>
  <attribute>
    <description>Memory VCS voltage domain ID. All memory buffers in the same VCS voltage domain will share the same ID. IDs are arbitrarily assigned, used for correlation between HB + HWSV, and are generated by genHwsvMrwXml.pl</description>
    <id>VCS_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Memory VDD voltage domain ID. All memory buffers in the same VDD voltage domain will share the same ID. IDs are arbitrarily assigned, used for correlation between HB + HWSV, and are generated by genHwsvMrwXml.pl</description>
    <id>VDD_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Memory VPP voltage domain ID. All memory buffers in the same VPP voltage domain will share the same ID. IDs are arbitrarily assigned, used for correlation between HB + HWSV, and are generated by genHwsvMrwXml.pl</description>
    <id>VPP_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>System control to set the power limit for Workload Optimized Frequency (WOF) algorithms. This is used to select the proper VFRT tables. Producer: TMGT Consumers: FW that selects VFRT tables</description>
    <id>WOF_POWER_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>LID id used to load tables for Workload Optimized Frequency (WOF) algorithms. Producer: TMGT Consumers: FW that selects VFRT tables</description>
    <id>WOF_TABLE_LID_NUMBER</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x81E00440</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>LX keyword VPD data for HDAT module</description>
    <id>ASCII_VPD_LX_KEYWORD</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Attribute indicating the target's chip version</description>
    <hasStringConversion />
    <id>CHIP_VER</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <enumeration>
        <id>CHIP_VER</id>
      </enumeration>
    </simpleType>
  </attribute>
  <attribute>
    <description>Attribute indicating the target's hw version</description>
    <hasStringConversion />
    <id>HW_VER</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <enumeration>
        <id>HW_VER</id>
      </enumeration>
    </simpleType>
  </attribute>
  <attribute>
    <description>Indicates if Idle Power Save is enabled. This is independent of the OPEN_POWER_PM_MODE (DPS and IPS can be enabled at the same time). Valid Values: 0 = Disabled (default), 1 = Enabled. See IPS_ENTER / IPS_EXIT attributes for IPS configuration.</description>
    <id>IPS_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>When IPS is enabled, this defines the delay time in seconds (between 10 and 600) to enter Idle Power Save.</description>
    <id>IPS_ENTER_TIME_SECONDS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>240</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>When IPS is enabled, this defines the utilization threshold as a percent (between 0 and 100) to enter Idle Power Save. This value should be less than IPS_EXIT_UTILIZATION_PERCENT.</description>
    <id>IPS_ENTER_UTILIZATION_PERCENT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>8</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>When IPS is enabled, this defines the delay time in seconds (between 10 and 600) to exit Idle Power Save.</description>
    <id>IPS_EXIT_TIME_SECONDS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>10</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>When IPS is enabled, this defines the utilization threshold as a percent (between 0 and 100) to exit Idle Power Save. This value should be greater than IPS_ENTER_UTILIZATION_PERCENT.</description>
    <id>IPS_EXIT_UTILIZATION_PERCENT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>12</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Power management mode the system should use. Valid values: 1 = Nominal (default), 5 = Static Power Save (percentage below nominal whose value is defined in OPEN_POWER_PM_MODE_FREQ_PERCENT), 6 = Dynamic Power Save - Favor Energy (DPS-FE), 10 = Dynamic Power Save - Favor Performance (DPS-FP), 11 = Fixed Frequency Override - (percentage above nominal whose value is defined in OPEN_POWER_PM_MODE_FREQ_PERCENT)</description>
    <id>OPEN_POWER_PM_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Percentage from nominal that the processors should run at when OPEN_POWER_PM_MODE is set to Static Power Save or Fixed Frequency Override (ignored on all other modes). Unit is in tenths of a percent (150 = 15.0%). Static Power Save (5): percentage to decrease frequency, Fixed Frequency Override (11): percentage to increase frequency</description>
    <id>OPEN_POWER_PM_MODE_FREQ_PERCENT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>PHYP system type value for habanero and barreleye (0x3015 and 0x3016 respectively). The value is updated in the system xml.</description>
    <id>PHYP_SYSTEM_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Hardware topology for HDAT creator:MRW consumer:HDAT firmware notes: Hardware Topology 2 Bytes Byte 1: bit 0-3: Node Id bit 4-7: Socket id inside the node bit 8-11: Proc id inside socket bit 12-15:Hub Id inside proc</description>
    <id>PROC_HW_TOPOLOGY</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Attribute indicating the target's role</description>
    <hasStringConversion />
    <id>ROLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <enumeration>
        <id>ROLE</id>
      </enumeration>
    </simpleType>
  </attribute>
  <attribute>
    <description>Attribute indicating the target's software version</description>
    <hasStringConversion />
    <id>SW_VER</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <enumeration>
        <id>SW_VER</id>
      </enumeration>
    </simpleType>
  </attribute>
  <attribute>
    <description>Brand Name of OEM systems</description>
    <id>SYSTEM_BRAND_NAME</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <string>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>ADC Channel function id. 16 channels.</description>
    <id>ADC_CHANNEL_FUNC_IDS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>16</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>ADC channel gain * 1000. 16 channels.</description>
    <id>ADC_CHANNEL_GAINS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>16</array>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>ADC Channel ground. 16 channels.</description>
    <id>ADC_CHANNEL_GNDS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>16</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>ADC channel offset * 1000. 16 channels</description>
    <id>ADC_CHANNEL_OFFSETS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>16</array>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>ADC Channel IPMI sensor numbers. 16 channels.</description>
    <id>ADC_CHANNEL_SENSOR_NUMBERS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>16</array>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Flag used to allow sending informational call-home errors as ESELS to the BMC</description>
    <id>ALLOW_CALLHOME_ESELS_TO_BMC</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>APSS GPIO PORT MODES</description>
    <id>APSS_GPIO_PORT_MODES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>APSS GPIO PORT PINS Port0 pin 0-7 Port1 pin 8-15</description>
    <id>APSS_GPIO_PORT_PINS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>16</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>The type of hardware of the BMC</description>
    <id>BMC_HW_CHIP_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <string>
        <default>ast2500</default>
        <sizeInclNull>32</sizeInclNull>
      </string>
    </simpleType>
  </attribute>
  <attribute>
    <description>The manufacturer of the BMC</description>
    <id>BMC_MANUFACTURER</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <string>
        <default>ibm</default>
        <sizeInclNull>32</sizeInclNull>
      </string>
    </simpleType>
  </attribute>
  <attribute>
    <description>max size of error log that can be sent to BMC</description>
    <id>BMC_MAX_ERROR_LOG_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>2048</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>The software type of the BMC</description>
    <id>BMC_SW_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <string>
        <default>openbmc</default>
        <sizeInclNull>32</sizeInclNull>
      </string>
    </simpleType>
  </attribute>
  <attribute>
    <complexType>
      <description>Structure to define the addessing for an I2C slave device.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0</default>
        <description>Port from the I2C Master device. This is a 6-bit value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0</default>
        <description>Device address on the I2C bus. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0</default>
        <description>Logical GPIO pin number used to enabled/disable VDDR</description>
        <name>vddrPin</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Information needed to address GPIO device</description>
    <id>GPIO_INFO</id>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <description>This attribute holds the values of the I2C address from the i2c device connections as defined in the MRW. It is parsed into a struct in i2c.C</description>
    <id>HDAT_I2C_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>32</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute holds the values of the I2C bus frequency in Hz from the i2c device connections as defined in the MRW. It is parsed into a struct in i2c.C</description>
    <id>HDAT_I2C_BUS_FREQ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>32</array>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute holds the string descriptions of the I2C devices from the i2c device connections as defined in the MRW. It is parsed into a struct in i2c.C</description>
    <id>HDAT_I2C_DEVICE_LABEL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>32</array>
      <string>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute holds the values of the I2C device purpose from the i2c device connections as defined in the MRW. It is parsed into a struct in i2c.C</description>
    <id>HDAT_I2C_DEVICE_PURPOSE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>32</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute holds the values of the I2C device type from the i2c device connections as defined in the MRW. It is parsed into a struct in i2c.C</description>
    <id>HDAT_I2C_DEVICE_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>32</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute holds the number of elements that were found under this particular target, and how many devices are stored in the arrays.</description>
    <id>HDAT_I2C_ELEMENTS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute holds the values of the I2C Engine from the i2c device connections as defined in the MRW. It is parsed into a struct in i2c.C</description>
    <id>HDAT_I2C_ENGINE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>32</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute holds the values of the I2C Master Port from the i2c device connections as defined in the MRW. It is parsed into a struct in i2c.C</description>
    <id>HDAT_I2C_MASTER_PORT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>32</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute holds the values of the I2C slave port from the i2c device connections as defined in the MRW. It is parsed into a struct in i2c.C</description>
    <id>HDAT_I2C_SLAVE_PORT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>32</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Holds the IPMI instance number for this entity.</description>
    <id>IPMI_INSTANCE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Attribute to hold 16 pairs of sensor name, sensor number pairs. A sensor name consists of one byte of general sensor type and one byte of sub-type</description>
    <id>IPMI_SENSORS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>16,2</array>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Specifies if the mpipl is supported on this platform 0 : No , 1 : Yes</description>
    <id>IS_MPIPL_SUPPORTED</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Maximum theoretical Vdd current reading in 10mA units. Used when VDD_CURRENT_OVERFLOW_WORKAROUND_ENABLE is set.</description>
    <id>MAX_VDD_CURRENT_READING</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0x0000</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Power used by components other than CPU, memory, or GPUs in Watts</description>
    <id>MISC_SYSTEM_COMPONENTS_MAX_POWER_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook safe mode throttle value for numerator cfg_nm_n_per_chip</description>
    <id>MRW_SAFEMODE_MEM_THROTTLE_NUMERATOR_PER_CHIP</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>A constant power (in watts) that the OCC is to add onto Vdd and Vdn power to represent any processor part that is not measured(i.e.Vcs,Vio) This is used by the OCC to calculate a total processor socket power.</description>
    <id>NO_APSS_PROC_POWER_VCS_VIO_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Specifies the compatible model name for Opal to key off of. This is sourced from the MRW and should be of the format 'vendor,model', e.g. 'tyan,palmetto'.</description>
    <id>OPAL_MODEL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <string>
        <default>ibm,miscopenpower</default>
        <sizeInclNull>32</sizeInclNull>
      </string>
    </simpleType>
  </attribute>
  <attribute>
    <description>DIMM temperature where an error will be generated in degrees C</description>
    <id>OPEN_POWER_DIMM_ERROR_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>DIMM read timeout in seconds</description>
    <id>OPEN_POWER_DIMM_READ_TIMEOUT_SEC</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>DIMM temperature threshold where throttling will occur in degrees C</description>
    <id>OPEN_POWER_DIMM_THROTTLE_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>GPU core temperature error threshold in degrees C</description>
    <id>OPEN_POWER_GPU_ERROR_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>GPU memory temperature error threshold in degrees C</description>
    <id>OPEN_POWER_GPU_MEM_ERROR_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>GPU memory temperature read timeout in seconds</description>
    <id>OPEN_POWER_GPU_MEM_READ_TIMEOUT_SEC</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>GPU core temperature read timeout in seconds</description>
    <id>OPEN_POWER_GPU_READ_TIMEOUT_SEC</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Memory controller temperature where an error will occur in degrees C</description>
    <id>OPEN_POWER_MEMCTRL_ERROR_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Memory controller read timeout in seconds</description>
    <id>OPEN_POWER_MEMCTRL_READ_TIMEOUT_SEC</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Memory controller temperature threshold where throttling will occur in degrees C</description>
    <id>OPEN_POWER_MEMCTRL_THROTTLE_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Minimum memory utilization percent (from 0-100) for power capping</description>
    <id>OPEN_POWER_MIN_MEM_UTILIZATION_POWER_CAP</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Minimum memory utilization percent (from 0-100) for memory throttling</description>
    <id>OPEN_POWER_MIN_MEM_UTILIZATION_THROTTLING</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Minimum hard power cap in Watts</description>
    <id>OPEN_POWER_MIN_POWER_CAP_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>N mode bulk power supply limit in Watts</description>
    <id>OPEN_POWER_N_BULK_POWER_LIMIT_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Maximum power allocated to DIMMs in Watts</description>
    <id>OPEN_POWER_N_MAX_MEM_POWER_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>N+1 bulk power limit in Watts for systems running with redundant power supplies (default)</description>
    <id>OPEN_POWER_N_PLUS_ONE_BULK_POWER_LIMIT_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>N+1 bulk power limit in Watts for High Performance Computing systems running with a non-redundant power supply policy</description>
    <id>OPEN_POWER_N_PLUS_ONE_HPC_BULK_POWER_LIMIT_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>N+1 max memory power in Watts</description>
    <id>OPEN_POWER_N_PLUS_ONE_MAX_MEM_POWER_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Processor temperature where DVFS will occur in degrees C</description>
    <id>OPEN_POWER_PROC_DVFS_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Processor temperature error threshold in degrees C</description>
    <id>OPEN_POWER_PROC_ERROR_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Processor read timeout in seconds</description>
    <id>OPEN_POWER_PROC_READ_TIMEOUT_SEC</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Weight factor (in 1/10ths) for each core DTS to calculate a core temperature.</description>
    <id>OPEN_POWER_PROC_WEIGHT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Weight factor (in 1/10ths) for each quad (cache) DTS to calculate a core temperature.</description>
    <id>OPEN_POWER_QUAD_WEIGHT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Regulator efficiency factor</description>
    <id>OPEN_POWER_REGULATOR_EFFICIENCY_FACTOR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Minimum soft power cap in Watts</description>
    <id>OPEN_POWER_SOFT_MIN_PCAP_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>If this system supports Turbo frequency mode. 0x00 = no 0x01 = yes</description>
    <id>OPEN_POWER_TURBO_MODE_SUPPORTED</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>VRM read timeout in seconds (from 0-255) Use 0 to disable VRM OT monitoring</description>
    <id>OPEN_POWER_VRM_READ_TIMEOUT_SEC</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>VRM Vdd Temperature in degrees C to invoke DVFS (clip max Pstate)</description>
    <id>OPEN_POWER_VRM_VDD_DVFS_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>VRM Vdd Temperature in degrees C that an overtemp error will be logged</description>
    <id>OPEN_POWER_VRM_VDD_ERROR_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Maximum time in seconds allowed without having a new VRM Vdd temperature before DVFS will occur</description>
    <id>OPEN_POWER_VRM_VDD_READ_TIMEOUT_SEC</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Frequency (in MHz) for 1 Watt of processor power change. Used by the power capping algorithm to determine how much to change the frequency based on power available. This is used in populating CALCULATED_MAX_SYS_POWER_EXCLUDING_GPUS</description>
    <id>PROC_MHZ_PER_WATT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>28</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>The maximum power a single procesor socket can support (in watts) This is used to populate CALCULATED_MAX_SYS_POWER_EXCLUDING_GPUS</description>
    <id>PROC_SOCKET_POWER_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>250</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Indicates if OCC should wait to report DVFS due to power/thermal until max frequency has been lowered below nominal. Default OCC will report DVFS when max frequency is lowered below turbo. DVFS is reported in poll response extended status bits and in OPAL shared memory throttle status byte. 1 = OCC report throttling only when max freq. lowered below nominal 0 = OCC report throttling when max freq. lowered below turbo</description>
    <id>REPORT_THROTTLE_BELOW_NOMINAL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Used to enable Vdd current overflow worakaround. To enable this attribute should be set to 1 and MAX_VDD_CURRENT_READING must be populated. Set to 0 to disable.</description>
    <id>VDD_CURRENT_OVERFLOW_WORKAROUND_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0x0000</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <enumerationType>
    <description>Specify the system policy to enforce synchronous mode between memory and nest. This drives the value of ATTR_MEM_IN_SYNCH_MODE. UNDETERMINED : Run synchronously if the dimm and nest freq matches ALWAYS : Require matching frequencies and deconfigure memory that does not match the nest NEVER : Do not run synchronously, even if the frequencies match</description>
    <enumerator>
      <name>UNDETERMINED</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ALWAYS</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>NEVER</name>
      <value>2</value>
    </enumerator>
    <id>REQUIRED_SYNCH_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Machine Readable Workbook Refresh Rate Desired refresh interval used in refresh register 0, MBAREF0Q_CFG_REFRESH_INTERVAL 7.8 us (SINGLE) 3.9 us (DOUBLE) 7.02 us (SINGLE_10_PERCENT_FASTER) 3.51 us (DOUBLE_10_PERCENT_FASTER)</description>
    <enumerator>
      <name>DOUBLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>SINGLE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SINGLE_10_PERCENT_FASTER</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>DOUBLE_10_PERCENT_FASTER</name>
      <value>3</value>
    </enumerator>
    <id>MSS_MRW_REFRESH_RATE_REQUEST</id>
  </enumerationType>
  <enumerationType>
    <description>Machine Readable Workbook enablement of the HWP code to adjust the VMEM regulator power limit based on number of installed DIMMs.</description>
    <enumerator>
      <name>FALSE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Used for to determine whether to apply an offset to AVDD. Supplied by MRW.</description>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <id>MSS_MRW_AVDD_OFFSET_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Used for to determine whether to apply an offset to VDD. Supplied by MRW.</description>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <id>MSS_MRW_VDD_OFFSET_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Used for to determine whether to apply an offset to VCS. Supplied by MRW.</description>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <id>MSS_MRW_VCS_OFFSET_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Used for to determine whether to apply an offset to VCS. Supplied by MRW.</description>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <id>MSS_MRW_VPP_OFFSET_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Used for to determine whether to apply an offset to VDDR. Supplied by MRW.</description>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <id>MSS_MRW_VDDR_OFFSET_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Fine refresh mode. Sets DDR4 MRS3. ZZ uses normal mode. From JEDEC DDR4 Spec 1716.78C from 07-2016 Page 47 Table 4.9.1</description>
    <enumerator>
      <name>NORMAL</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>FIXED_2X</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>FIXED_4X</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>FLY_2X</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>FLY_4X</name>
      <value>6</value>
    </enumerator>
    <id>MSS_MRW_FINE_REFRESH_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Temperature refresh range. Sets DDR4 MRS4. Should be defaulted to extended range. NORMAL for running at 85 degrees C or less, EXTENDED for 95 or less degrees C Used for calculating periodic refresh intervals JEDEC DDR4 spec 1716.78C from 07-2016 page 46 4.8.1</description>
    <enumerator>
      <name>NORMAL</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>EXTEND</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_TEMP_REFRESH_RANGE</id>
  </enumerationType>
  <enumerationType>
    <description>For resetting the phy delay values at the beginning of calling mss_draminit_training. YES means the vaules will be reset.</description>
    <enumerator>
      <name>YES</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>NO</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_RESET_DELAY_BEFORE_CAL</id>
  </enumerationType>
  <enumerationType>
    <description>Value of on or off. Determines if prefetching enabled or not.</description>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <id>MSS_MRW_PREFETCH_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Value of on or off. Determines if the cleaner of the L4 cache (write modified entries to memory on idle cycles) enabled or not. See chapter 7 of the Centaur Workbook.</description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_CLEANER_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Allows user to manually turn on and off 2N Mode. AUTO indicates to use Signal Integrity generated setting (from VPD).</description>
    <enumerator>
      <name>AUTO</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>FORCE_TO_1N_MODE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>FORCE_TO_2N_MODE</name>
      <value>2</value>
    </enumerator>
    <id>MSS_MRW_DRAM_2N_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>List of memory frequencies supported by the current system.</description>
    <enumerator>
      <name>MT1866</name>
      <value>1866</value>
    </enumerator>
    <enumerator>
      <name>MT2133</name>
      <value>2133</value>
    </enumerator>
    <enumerator>
      <name>MT2400</name>
      <value>2400</value>
    </enumerator>
    <enumerator>
      <name>MT2666</name>
      <value>2666</value>
    </enumerator>
    <id>MSS_MRW_SUPPORTED_FREQ</id>
  </enumerationType>
  <enumerationType>
    <description>Enables DRAM Write CRC</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_DRAM_WRITE_CRC</id>
  </enumerationType>
  <enumerationType>
    <description>An override switch to shut off broadcast mode Enum values: YES: broadcast mode is forced off NO: broadcast mode uses the default value</description>
    <enumerator>
      <name>NO</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>YES</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_FORCE_BCMODE_OFF</id>
  </enumerationType>
  <enumerationType>
    <description>A bitmap containing the plug rules for NVDIMM. 1 if a DIMM supports an NVDIMM being plugged in, 0 if it does not DIMM slot 0 is the left most bit The index to the bitmap is the position of the DIMM target As such, a bitmap of 0b10010000, would allow NVDIMM plugged into DIMM0 and DIMM3 Note: this attribute is a 64 bit number to account for 16 DIMM per processor if there is ever a 4 processor system</description>
    <enumerator>
      <name>NO_NVDIMM</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>NVDIMM_CAPABLE</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_NVDIMM_PLUG_RULES</id>
  </enumerationType>
  <enumerationType>
    <description>Switch that allows unsupported raw card references by providing a default raw card setting.</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_ALLOW_UNSUPPORTED_RCW</id>
  </enumerationType>
  <enumerationType>
    <description>Bitmap of DRAM widths supported by a system. A 1 indicates that the system supports a density. Enums below represent the the bit location in the attribute for a given DRAM width. Default value is 0xC -&gt; both x4/x8 supported</description>
    <enumerator>
      <name>X4</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>X8</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_SUPPORTED_DRAM_WIDTH</id>
  </enumerationType>
  <enumerationType>
    <description>True or false whether row repair is supported MRW attribute</description>
    <enumerator>
      <name>SUPPORTED</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>UNSUPPORTED</name>
      <value>0</value>
    </enumerator>
    <id>ROW_REPAIR_SUPPORTED_MRW</id>
  </enumerationType>
  <enumerationType>
    <description>The frequency of a processor's nest mesh clock, in MHz. This is the same for all chips in the system. Provided by the MRW.</description>
    <enumerator>
      <name>1600</name>
      <value>1600</value>
    </enumerator>
    <enumerator>
      <name>1866</name>
      <value>1866</value>
    </enumerator>
    <enumerator>
      <name>2000</name>
      <value>2000</value>
    </enumerator>
    <enumerator>
      <name>2133</name>
      <value>2133</value>
    </enumerator>
    <enumerator>
      <name>2400</name>
      <value>2400</value>
    </enumerator>
    <id>FREQ_PB_MHZ</id>
  </enumerationType>
  <enumerationType>
    <description>The frequency of the memory controller channel. In synchronous mode, this is equivalent to ATTR_FREQ_PB_MHZ. This may be independently set per pair of memory channels if operating in asynchronous mode, but this configuration is not anticipated. This clock drives the MCU queues, and all the associated logic that drives the inputs to the DMI and reads its outputs.</description>
    <enumerator>
      <name>2000</name>
      <value>2000</value>
    </enumerator>
    <enumerator>
      <name>2400</name>
      <value>2400</value>
    </enumerator>
    <id>FREQ_MCA_MHZ</id>
  </enumerationType>
  <enumerationType>
    <description>MRW control to permit Normal (100 MHz) or Slow (94 MHz) operation of PCIE reference clock. On Nimbus DD1 HW, Slow operation is required to achieve Gen4 operation. Provided by the MRW.</description>
    <enumerator>
      <name>NORMAL</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>SLOW</name>
      <value>0x01</value>
    </enumerator>
    <id>DD1_SLOW_PCI_REF_CLOCK</id>
  </enumerationType>
  <enumerationType>
    <description>Processor SMP topology configuration. 0 = default = 1 or 2 hop topology (PHYP image spans system) Provided by the MRW.</description>
    <enumerator>
      <name>OFF</name>
      <value>0x0</value>
    </enumerator>
    <id>PROC_FABRIC_CCSM_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Per-link optics configuration 0 = default = SMP 1 = CAPI 2.0 2 = NV 2.0 3 = OPENCAPI Provided by the MRW.</description>
    <enumerator>
      <name>SMP</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>CAPI</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>NV</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>OCAPI</name>
      <value>0x3</value>
    </enumerator>
    <id>OPTICS_CONFIG_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Indicates if current IPL is memory-preserving</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x1</value>
    </enumerator>
    <id>IS_MPIPL</id>
  </enumerationType>
  <enumerationType>
    <description>Determines the stride covered by each granule in an interleaving group. The default stride -- 128B -- is the only value intended for production FW use. All other combinations are for experimental performance evaluation. Regardless of this attribute value, groups of size 1, 3, and 6 will be forced to 128B stride based on the logic capabilities.</description>
    <enumerator>
      <name>128_B</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>256_B</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>512_B</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>1_KB</name>
      <value>0x03</value>
    </enumerator>
    <enumerator>
      <name>2_KB</name>
      <value>0x04</value>
    </enumerator>
    <enumerator>
      <name>4_KB</name>
      <value>0x05</value>
    </enumerator>
    <enumerator>
      <name>8_KB</name>
      <value>0x06</value>
    </enumerator>
    <enumerator>
      <name>16_KB</name>
      <value>0x07</value>
    </enumerator>
    <enumerator>
      <name>32_KB</name>
      <value>0x08</value>
    </enumerator>
    <id>MSS_INTERLEAVE_GRANULARITY</id>
  </enumerationType>
  <enumerationType>
    <description>REQUIRED/TRUE: HW mirroring is enabled, and all channels are required to be part of a mirrored group. REQUESTED : HW mirroring is enabled. Mirroring will be configured for groups which support it, but not all channels are required to be mirrored. FALSE : HW mirroring is disabled. Provided by the MRW.</description>
    <enumerator>
      <name>FALSE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>REQUESTED</name>
      <value>2</value>
    </enumerator>
    <id>MRW_HW_MIRRORING_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Enable early data from Memory. This also enable cp_me from L3.</description>
    <enumerator>
      <name>OFF</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x1</value>
    </enumerator>
    <id>ENABLE_MEM_EARLY_DATA_SCOM</id>
  </enumerationType>
  <enumerationType>
    <description>DMI inband BAR enable. Set by platform. Used by p9c_set_inband_addr.</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>0x1</value>
    </enumerator>
    <id>OMI_INBAND_BAR_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Source: MRW: Downstream MSB Swap and Upstream MSB Swap Usage: TX_MSBSWAP initfile setting for DMI and X buses This attribute represents whether or not a single clock group bus such as DMI and X bus was wired by the board designer using a feature called MSB Swap where lane 0 of the TX chip wires to lane n-1 on the RX chip where 'n' is the width of the bus. A basic description of this capability is that the board designer can save layers on the board wiring by crossing the wiring between the two chips in a prescribed manner. In a non-MSB Swapped bus Lane 0 on the TX chip wires to lane 0 on the RX chip, lane 1 to lane 1 and so on. If a bus is MSB Swapped then lane 0 of the TX chip wires to lane 'n-1' of the RX chip, lane 1 to lane 'n-2', etc. Random or arbitrary wiring of TX to RX lanes on different chips is NOT ALLOWED. The Master Chip of two connected chips is defined as the chip with the smaller value of (100*Node + Pos). The Slave Chip of two connected chips is defined as the chip with the larger value of (100*Node + Pos). The Downstream direction is defined as the direction from the Master chip to the Slave chip. The Upstream direction is defined as the direction from the Slave chip to the Master chip. The Downstream TX_MSBSWAP from the MRW is a uint8 value. 0x01 means the Downstream bus is wired msb to lsb etc. and 0x00 means the bus is wired normally, msb to msb, lsb to lsb (lane0 to lane0). The Upstream TX_MSBSWAP from the MRW is a uint8 value. 0x01 means the Upstream bus is wired msb to lsb etc. and 0x00 means the bus is wired normally, msb to msb, lsb to lsb (lane0 to lane0). It is up to the platform code to set up each ATTR_EI_BUS_TX_MSBSWAP value for the correct target endpoints.</description>
    <enumerator>
      <name>NO_SWAP</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ALL_SWAP</name>
      <value>0xFF</value>
    </enumerator>
    <enumerator>
      <name>GROUP_0_SWAP</name>
      <value>0x80</value>
    </enumerator>
    <enumerator>
      <name>GROUP_1_SWAP</name>
      <value>0x40</value>
    </enumerator>
    <id>EI_BUS_TX_MSBSWAP</id>
  </enumerationType>
  <enumerationType>
    <description>Summarizes the fused status of cores. This is same for all P9 chips in the system. If a core is in a fused state, attribute should read 1 else zero. It needs to be populated during ipl but before istep 15.</description>
    <enumerator>
      <name>CORE_UNFUSED</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>CORE_FUSED</name>
      <value>0x1</value>
    </enumerator>
    <id>FUSED_CORE_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Indicate if debug data should be taken pre / post linktraining.</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x1</value>
    </enumerator>
    <id>IO_DMI_PROC_DEBUG</id>
  </enumerationType>
  <enumerationType>
    <description>Indicate if manufcaturing tests should be taken pre / post linktraining.</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x1</value>
    </enumerator>
    <id>IO_O_MFG_CHK</id>
  </enumerationType>
  <enumerationType>
    <description>Indicates if the Obus channel is a board or a cable</description>
    <enumerator>
      <name>BOARD</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>CABLE</name>
      <value>0x1</value>
    </enumerator>
    <id>IO_O_CHANNEL_TYPE</id>
  </enumerationType>
  <enumerationType>
    <description>Indicate if manufacturing tests should be taken pre / post linktraining.</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x1</value>
    </enumerator>
    <id>IO_X_MFG_CHK</id>
  </enumerationType>
  <enumerationType>
    <description>Alternate settings for short Xbus channels bit 0 -- Disable RX LTE bit 1 -- Disable AC BOOST bit 2 -- Low Gain/Peaking Init Settings bit 3 -- Lower VGA Gain Target -10%</description>
    <enumerator>
      <name>DIS_RX_LTE</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>DIS_TX_AC_BOOST</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>LOWER_GAIN_PEAK_INITS</name>
      <value>0x04</value>
    </enumerator>
    <enumerator>
      <name>LOWER_VGA_GAIN_TARGET</name>
      <value>0x08</value>
    </enumerator>
    <id>IO_XBUS_CHAN_EQ</id>
  </enumerationType>
  <enumerationType>
    <description>PCIE MMIO BAR enable creator: platform consumer: p9_pcie_config firmware notes: Array index: BAR number (0:2) index 0~1 for MMIO BAR0/1 index 2 for PHB register space</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_PCIE_BAR_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>PCIE MMIO BAR size values creator: platform consumer: p9_pcie_config firmware notes: Array index: BAR number (0:2) NOTE: supported MMIO BAR0/1 sizes are from 64KB-32PB NOTE: only supported PHB register size is 16KB</description>
    <enumerator>
      <name>32_PB</name>
      <value>0x8000000000000000</value>
    </enumerator>
    <enumerator>
      <name>16_PB</name>
      <value>0xC000000000000000</value>
    </enumerator>
    <enumerator>
      <name>8_PB</name>
      <value>0xE000000000000000</value>
    </enumerator>
    <enumerator>
      <name>4_PB</name>
      <value>0xF000000000000000</value>
    </enumerator>
    <enumerator>
      <name>2_PB</name>
      <value>0xF800000000000000</value>
    </enumerator>
    <enumerator>
      <name>1_PB</name>
      <value>0xFC00000000000000</value>
    </enumerator>
    <enumerator>
      <name>512_TB</name>
      <value>0xFE00000000000000</value>
    </enumerator>
    <enumerator>
      <name>256_TB</name>
      <value>0xFF00000000000000</value>
    </enumerator>
    <enumerator>
      <name>128_TB</name>
      <value>0xFF80000000000000</value>
    </enumerator>
    <enumerator>
      <name>64_TB</name>
      <value>0xFFC0000000000000</value>
    </enumerator>
    <enumerator>
      <name>32_TB</name>
      <value>0xFFE0000000000000</value>
    </enumerator>
    <enumerator>
      <name>16_TB</name>
      <value>0xFFF0000000000000</value>
    </enumerator>
    <enumerator>
      <name>8_TB</name>
      <value>0xFFF8000000000000</value>
    </enumerator>
    <enumerator>
      <name>4_TB</name>
      <value>0xFFFC000000000000</value>
    </enumerator>
    <enumerator>
      <name>2_TB</name>
      <value>0xFFFE000000000000</value>
    </enumerator>
    <enumerator>
      <name>1_TB</name>
      <value>0xFFFF000000000000</value>
    </enumerator>
    <enumerator>
      <name>512_GB</name>
      <value>0xFFFF800000000000</value>
    </enumerator>
    <enumerator>
      <name>256_GB</name>
      <value>0xFFFFC00000000000</value>
    </enumerator>
    <enumerator>
      <name>128_GB</name>
      <value>0xFFFFE00000000000</value>
    </enumerator>
    <enumerator>
      <name>64_GB</name>
      <value>0xFFFFF00000000000</value>
    </enumerator>
    <enumerator>
      <name>32_GB</name>
      <value>0xFFFFF80000000000</value>
    </enumerator>
    <enumerator>
      <name>16_GB</name>
      <value>0xFFFFFC0000000000</value>
    </enumerator>
    <enumerator>
      <name>8_GB</name>
      <value>0xFFFFFE0000000000</value>
    </enumerator>
    <enumerator>
      <name>4_GB</name>
      <value>0xFFFFFF0000000000</value>
    </enumerator>
    <enumerator>
      <name>2_GB</name>
      <value>0xFFFFFF8000000000</value>
    </enumerator>
    <enumerator>
      <name>1_GB</name>
      <value>0xFFFFFFC000000000</value>
    </enumerator>
    <enumerator>
      <name>512_MB</name>
      <value>0xFFFFFFE000000000</value>
    </enumerator>
    <enumerator>
      <name>256_MB</name>
      <value>0xFFFFFFF000000000</value>
    </enumerator>
    <enumerator>
      <name>128_MB</name>
      <value>0xFFFFFFF800000000</value>
    </enumerator>
    <enumerator>
      <name>64_MB</name>
      <value>0xFFFFFFFC00000000</value>
    </enumerator>
    <enumerator>
      <name>32_MB</name>
      <value>0xFFFFFFFE00000000</value>
    </enumerator>
    <enumerator>
      <name>16_MB</name>
      <value>0xFFFFFFFF00000000</value>
    </enumerator>
    <enumerator>
      <name>8_MB</name>
      <value>0xFFFFFFFF80000000</value>
    </enumerator>
    <enumerator>
      <name>4_MB</name>
      <value>0xFFFFFFFFC0000000</value>
    </enumerator>
    <enumerator>
      <name>2_MB</name>
      <value>0xFFFFFFFFE0000000</value>
    </enumerator>
    <enumerator>
      <name>1_MB</name>
      <value>0xFFFFFFFFF0000000</value>
    </enumerator>
    <enumerator>
      <name>512_KB</name>
      <value>0xFFFFFFFFF8000000</value>
    </enumerator>
    <enumerator>
      <name>256_KB</name>
      <value>0xFFFFFFFFFC000000</value>
    </enumerator>
    <enumerator>
      <name>128_KB</name>
      <value>0xFFFFFFFFFE000000</value>
    </enumerator>
    <enumerator>
      <name>64_KB</name>
      <value>0xFFFFFFFFFF000000</value>
    </enumerator>
    <enumerator>
      <name>16_KB</name>
      <value>0xFFFFFFFFFFFFFFFF</value>
    </enumerator>
    <id>PROC_PCIE_BAR_SIZE</id>
  </enumerationType>
  <enumerationType>
    <description>Indicates if SBE on this chip is serving as hosboot drawer master</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_SBE_MASTER_CHIP</id>
  </enumerationType>
  <enumerationType>
    <description>Defines system specific value of processor refclock receiver termination</description>
    <enumerator>
      <name>NONE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>FIFTY_OHM</name>
      <value>1</value>
    </enumerator>
    <id>CP_REFCLOCK_RCVR_TERM</id>
  </enumerationType>
  <enumerationType>
    <description>Defines system specific value of PCI refclock receiver termination</description>
    <enumerator>
      <name>NONE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>FIFTY_OHM</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ONE_HUNDRED_OHM</name>
      <value>3</value>
    </enumerator>
    <id>IO_REFCLOCK_RCVR_TERM</id>
  </enumerationType>
  <enumerationType>
    <description>Defines which of the PSS chip selects (0 or 1) that the APSS is connected Provided by the Machine Readable Workbook. Consumer: p9_pm_pss_init</description>
    <enumerator>
      <name>NONE</name>
      <value>0xFF</value>
    </enumerator>
    <enumerator>
      <name>CS0</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>CS1</name>
      <value>0x01</value>
    </enumerator>
    <id>PM_APSS_CHIP_SELECT</id>
  </enumerationType>
  <enumerationType>
    <description>Control CME response to execution of PowerPC STOP instruction if OFF, treat STOP4 as STOP4 if ON, treat STOP4 as STOP2 Producer: Work-around tools Consumer: p9_hcode_image_build.C Platform default: OFF</description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <id>STOP4_DISABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Control CME response to execution of PowerPC STOP instruction if OFF, treat STOP5 as STOP5 if ON, treat STOP5 as STOP4 Producer: ??? Consumer: p9_hcode_image_build.C Platform default: ON</description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <id>STOP5_DISABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Control CME response to execution of PowerPC STOP instruction if OFF, treat STOP8 as STOP8 if ON, treat STOP8 as STOP4 Producer: Work-around tools Consumer: p9_hcode_image_build.C Platform default: OFF</description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <id>STOP8_DISABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Control CME response to execution of PowerPC STOP instruction if OFF, treat STOP11 as STOP11 if ON, treat STOP11 as STOP8 Producer: Work-around tools Consumer: p9_hcode_image_build.C Platform default: OFF</description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <id>STOP11_DISABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Disables Work Load Optimized Frequency (WOF) algorithms to modify frequency based on active core count and other inputs. OFF: Will enable WOF given all validity check pass. If validity checks fail, WOF will be disabled for the present IPL. ON: Will disable WOF OFF_SKIP_DD: Same as OFF but skips any validity checking of the chip design level (lab use only). Producer: Override Consumers: p9_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB) for PGPE/OCC</description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>OFF_SKIP_DD</name>
      <value>2</value>
    </enumerator>
    <id>SYSTEM_WOF_DISABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Disables IVRM enablement in the system Producer: Override Consumers: p9_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB) for PGPE/OCC CME Quad Pstate Region (CQPR) for CM Quad Manager</description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <id>SYSTEM_IVRM_DISABLE</id>
  </enumerationType>
  <enumerationType>
    <description>If wof_enabled, defines the Frequency Ratio calculation performed. (THIS IS NOT SUPPORTED IN P9 GA1!).</description>
    <enumerator>
      <name>FIXED</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>STEPPED</name>
      <value>1</value>
    </enumerator>
    <id>WOF_ENABLE_FRATIO</id>
  </enumerationType>
  <enumerationType>
    <description>If wof_enabled, defines the Voltage Ratio calculation performed. THIS IS NOT SUPPORTED AT PRESENT. GA1 SUPPORT IS TBD).</description>
    <enumerator>
      <name>FIXED</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>CALCULATED</name>
      <value>1</value>
    </enumerator>
    <id>WOF_ENABLE_VRATIO</id>
  </enumerationType>
  <enumerationType>
    <description>If wof_enabled AND ATTR_WOF_ENABLE_VRATIO = CALCULATED, this attribute selects the Vratio calculation type. ACTIVE_CORES: Vratio is the number of active cores to the number of good cores FULL: Vratio is Vaverage to Vclip(Fclip) where Vclip(Fclip) is the normal interpolated regulator voltage (including load line uplife @ RDP current) derated with presently measured Idd current (from the AVSBus) and the loadline.</description>
    <enumerator>
      <name>ACTIVE_CORES</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>FULL</name>
      <value>1</value>
    </enumerator>
    <id>WOF_VRATIO_SELECT</id>
  </enumerationType>
  <enumerationType>
    <description>Disables the enablement of Voltage Droop Monitors (VDM) in the system. Producer: MRW Consumers: p9_pstate_parameter_block to clear flag for CME QuadManager Hcode reaction</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <id>SYSTEM_VDM_DISABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Controls the enablement of Voltage Droop Monitors (VDM) to throttle the core upon an extreme droop event. Producer: Machine Readable Workbook Consumers: p9_hcode_image_build to set flag for CME QuadManager Hcode reaction</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <id>VDM_EXTREME_THOTTLE_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Indicates the response of the DPLL frequency upon VDM events if ATTR_SYSTEM_VDM_DISABLE is not ON. NONE -&gt; DPLL Mode 2 DROOP_PROTECT -&gt; DPLL Mode 3 DROOP_PROTECT_OVERVOLT -&gt; DPLL Mode 3.5 DYNAMIC -&gt; DPLL Mode 4 DYNAMIC_PROTECT -&gt; DPLL Mode 5 Producer: MRWB.</description>
    <enumerator>
      <name>DROOP_PROTECT</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>DROOP_PROTECT_OVERVOLT</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>DYNAMIC</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>DYNAMIC_PROTECT</name>
      <value>0x03</value>
    </enumerator>
    <enumerator>
      <name>NONE</name>
      <value>0x04</value>
    </enumerator>
    <id>DPLL_VDM_RESPONSE</id>
  </enumerationType>
  <enumerationType>
    <description>Debug modes supported for CME/SGPE Scan layout in HOMER.</description>
    <enumerator>
      <name>SCAN_RING_NO_DEBUG</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>SCAN_RING_TRACE_DEBUG</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>SCAN_RING_DEEP_DEBUG</name>
      <value>0x02</value>
    </enumerator>
    <id>SYSTEM_RING_DBG_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Enables the SGPE Hcode to enable the CME instruction traces into the L3 Trace array for debug. Note: all configured CMEs will be put into this mode if this attribute is ON. Consumer: p9_hcode_image_build.c -&gt; SGPE Header field Platform default: OFF</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <id>CME_INSTRUCTION_TRACE_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Enables the SGPE Hcode to enable the CME instruction traces into the CHTM for debug. Note: all configured CMEs will be put into this mode if this attribute is ON. Consumer: p9_hcode_image_build.c -&gt; SGPE Header field Platform default: OFF</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <id>CME_CHTM_TRACE_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Enables the PGPE Hcode to physically perform frequency and voltage operations based on constructed parameters (eg #V VPD, system parameters, biases, WPF VFRTs. etc). If OFF, the PGPE provides an immedicate good response to all Pstate/WOF IPC operations from the OCC for firmware integration testing purposes. Consumer: p9_hcode_image_build.c -&gt; PGPE Header field Platform default: ON</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <id>PGPE_HCODE_FUNCTION_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Enables pstate parameter block code to use the static #W data Consumer: p9_pstate_parameter_block.C -&gt; Platform default: OFF</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <id>POUND_W_STATIC_DATA_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Enables pstate parameter block code to use the static system vfrt data Consumer: p9_pstate_parameter_block.C -&gt; Platform default: OFF</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>VDN_STEP_OFF</name>
      <value>0x02</value>
    </enumerator>
    <id>SYS_VFRT_STATIC_DATA_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>The powerbus frequency that should be used to locate a valid #V bucket in the processor Module VPD if the actual ATTR_FREQ_PB_MHZ value isn't present.</description>
    <enumerator>
      <name>NO_FALLBACK</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>1600</name>
      <value>1600</value>
    </enumerator>
    <enumerator>
      <name>1866</name>
      <value>1866</value>
    </enumerator>
    <enumerator>
      <name>2000</name>
      <value>2000</value>
    </enumerator>
    <enumerator>
      <name>2133</name>
      <value>2133</value>
    </enumerator>
    <enumerator>
      <name>2400</name>
      <value>2400</value>
    </enumerator>
    <id>FREQ_PB_MHZ_POUNDV_FALLBACK</id>
  </enumerationType>
  <enumerationType>
    <description>Switch to enable or disable 24x7 IMA. Based on the attribute value, a field of QPMR header of HOMER is populated while building HOMER. Based on the value in that field 24x7 code, which runs on GPE1, either starts or stops Nest IMA. Producer: Initialized by Hostboot firmware based on platform support Consumers: Read by p9_hcode_image_build.C</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x01</value>
    </enumerator>
    <id>NEST_24x7_PERF_ACCUM_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Product name of a chip target. Provided by the MRW.</description>
    <enumerator>
      <name>NONE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>CENTAUR</name>
      <value>0x3</value>
    </enumerator>
    <enumerator>
      <name>NIMBUS</name>
      <value>0x5</value>
    </enumerator>
    <enumerator>
      <name>CUMULUS</name>
      <value>0x6</value>
    </enumerator>
    <enumerator>
      <name>AXONE</name>
      <value>0x7</value>
    </enumerator>
    <enumerator>
      <name>EXPLORER</name>
      <value>0x8</value>
    </enumerator>
    <id>NAME</id>
  </enumerationType>
  <enumerationType>
    <description>1 if the target is functional, else 0. Set by the platform.</description>
    <enumerator>
      <name>NON_FUNCTIONAL</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>FUNCTIONAL</name>
      <value>0x1</value>
    </enumerator>
    <id>FUNCTIONAL</id>
  </enumerationType>
  <enumerationType>
    <description>Which execution platform the HW Procedure is running on Some HWPs (e.g. special wakeup) use different registers for different platforms to avoid arbitration problems when multiple platforms do the same thing concurrently</description>
    <enumerator>
      <name>HOST</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>FSP</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>OCC</name>
      <value>0x03</value>
    </enumerator>
    <id>EXECUTION_PLATFORM</id>
  </enumerationType>
  <enumerationType>
    <description>The manufacturing flags. This is a bitfield. Each bit is a flag and multiple flags can be set</description>
    <enumerator>
      <name>MNFG_NO_FLAG</name>
      <value>0x0000000000000000</value>
    </enumerator>
    <enumerator>
      <name>MNFG_THRESHOLDS</name>
      <value>0x0000000000000001</value>
    </enumerator>
    <enumerator>
      <name>MNFG_TEST_ALL_SPARE_DRAM_ROWS</name>
      <value>0x0000000000000040</value>
    </enumerator>
    <enumerator>
      <name>MNFG_DISABLE_DRAM_REPAIRS</name>
      <value>0x0000000000000080</value>
    </enumerator>
    <enumerator>
      <name>MNFG_ENABLE_STANDARD_PATTERN_TEST</name>
      <value>0x0000000000000200</value>
    </enumerator>
    <enumerator>
      <name>MNFG_DISABLE_FABRIC_eREPAIR</name>
      <value>0x0000000000000800</value>
    </enumerator>
    <enumerator>
      <name>MNFG_DISABLE_MEMORY_eREPAIR</name>
      <value>0x0000000000001000</value>
    </enumerator>
    <enumerator>
      <name>MNFG_FABRIC_DEPLOY_LANE_SPARES</name>
      <value>0x0000000000002000</value>
    </enumerator>
    <enumerator>
      <name>MNFG_DMI_DEPLOY_LANE_SPARES</name>
      <value>0x0000000000004000</value>
    </enumerator>
    <id>MNFG_FLAGS</id>
  </enumerationType>
  <enumerationType>
    <description>Spare DRAM availability for all DIMMs connected to the target MBA. For each rank on a DIMM, there are 8 DQ lines to spare DRAMs. - NO_SPARE: No spare DRAMs - LOW_NIBBLE: x4 DRAMs in use, one spare DRAM connected to SP_DQ0-3 - HIGH_NIBBLE: x4 DRAMs in use, one spare DRAM connected to SP_DQ4-7 - FULL_BYTE: Either 1/ x4 DRAMs in use, two spare DRAMs connected to SP_DQ0-7 2/ x8 DRAMs in use, one spare DRAM connected to SP_DQ0-7 For C-DIMMs, this is in a VPD field : Record:VSPD, Keyword:AM</description>
    <enumerator>
      <name>NO_SPARE</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>LOW_NIBBLE</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>HIGH_NIBBLE</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>FULL_BYTE</name>
      <value>0x03</value>
    </enumerator>
    <id>CEN_VPD_DIMM_SPARE</id>
  </enumerationType>
  <enumerationType>
    <description>RCD Timing. Supplied by VPD, used by mss_eff_config.C. Each dimm will have a value. consumer: mss_eff_config</description>
    <enumerator>
      <name>1T</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>3T</name>
      <value>0x03</value>
    </enumerator>
    <id>CEN_VPD_DIMM_RCD_OUTPUT_TIMING</id>
  </enumerationType>
  <enumerationType>
    <description>The VPD Version of this DIMM. The version number can be an indication of when different DIMM keywords are valid and is loaded from the platform. The version represented here represents one of three distinct vintages of parts : unknown/error, early build CDIMMs with VZ less than 10, everything else. In other words, this attribute does NOT equate to the VZ keyword.</description>
    <enumerator>
      <name>UNKNOWN</name>
      <value>0x3030</value>
    </enumerator>
    <enumerator>
      <name>OLD_CDIMM</name>
      <value>0x3031</value>
    </enumerator>
    <enumerator>
      <name>CURRENT</name>
      <value>0x3230</value>
    </enumerator>
    <id>CEN_VPD_VERSION</id>
  </enumerationType>
  <enumerationType>
    <description>The C-DIMM ranks that have address mirroring. This data is in the Record:VSPD, Keyword:AM field in C-DIMM VPD. This attribute is only valid for C-DIMMs, an error should be returned if queried from IS-DIMMs. Note: Muliple ranks can be mirrored.</description>
    <enumerator>
      <name>RANK0_MIRRORED</name>
      <value>0x08</value>
    </enumerator>
    <enumerator>
      <name>RANK1_MIRRORED</name>
      <value>0x04</value>
    </enumerator>
    <enumerator>
      <name>RANK2_MIRRORED</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>RANK3_MIRRORED</name>
      <value>0x01</value>
    </enumerator>
    <id>CEN_VPD_DRAM_ADDRESS_MIRRORING</id>
  </enumerationType>
  <enumerationType>
    <description>DRAM Ron. Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. OHM48 is for DDR4. creator: VPD(MT)/mss_eff_cnfg_termination consumer: various.C files (no initfile) firmware notes: none This Attribute is to be interpreted as an Integer</description>
    <enumerator>
      <name>INVALID</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>OHM34</name>
      <value>34</value>
    </enumerator>
    <enumerator>
      <name>OHM40</name>
      <value>40</value>
    </enumerator>
    <enumerator>
      <name>OHM48</name>
      <value>48</value>
    </enumerator>
    <id>CEN_VPD_DRAM_RON</id>
  </enumerationType>
  <enumerationType>
    <description>DRAM Rtt_Nom. Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT),mss_eff_cnfg_termination consumer: various.C files (no initfiles) firmware notes: none This Attribute is to be interpreted as an Integer</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>OHM20</name>
      <value>20</value>
    </enumerator>
    <enumerator>
      <name>OHM30</name>
      <value>30</value>
    </enumerator>
    <enumerator>
      <name>OHM34</name>
      <value>34</value>
    </enumerator>
    <enumerator>
      <name>OHM40</name>
      <value>40</value>
    </enumerator>
    <enumerator>
      <name>OHM48</name>
      <value>48</value>
    </enumerator>
    <enumerator>
      <name>OHM60</name>
      <value>60</value>
    </enumerator>
    <enumerator>
      <name>OHM80</name>
      <value>80</value>
    </enumerator>
    <enumerator>
      <name>OHM120</name>
      <value>120</value>
    </enumerator>
    <enumerator>
      <name>OHM240</name>
      <value>240</value>
    </enumerator>
    <id>CEN_VPD_DRAM_RTT_NOM</id>
  </enumerationType>
  <enumerationType>
    <description>DRAM Rtt_WR. Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Creator: VPD(MT), mss_eff_cnfg_termination consumer: various.C files (no initfiles) firmware notes: none This Attribute is to be interpreted as an Integer</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>OHM60</name>
      <value>60</value>
    </enumerator>
    <enumerator>
      <name>OHM120</name>
      <value>120</value>
    </enumerator>
    <enumerator>
      <name>OHM240</name>
      <value>240</value>
    </enumerator>
    <enumerator>
      <name>HIGHZ</name>
      <value>1</value>
    </enumerator>
    <id>CEN_VPD_DRAM_RTT_WR</id>
  </enumerationType>
  <enumerationType>
    <description>DRAM Rtt_PARK. Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. RTT_Park value. This is for DDR4 MRS5.Each memory channel will have a value. Creator: VPD(MT), mss_eff_cnfg_termination consumer: various.C files (no initfiles) firmware notes: none This Attribute is to be interpreted as an Integer</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>60OHM</name>
      <value>60</value>
    </enumerator>
    <enumerator>
      <name>120OHM</name>
      <value>120</value>
    </enumerator>
    <enumerator>
      <name>40OHM</name>
      <value>40</value>
    </enumerator>
    <enumerator>
      <name>240OHM</name>
      <value>240</value>
    </enumerator>
    <enumerator>
      <name>48OHM</name>
      <value>48</value>
    </enumerator>
    <enumerator>
      <name>80OHM</name>
      <value>80</value>
    </enumerator>
    <enumerator>
      <name>34OHM</name>
      <value>34</value>
    </enumerator>
    <id>CEN_VPD_DRAM_RTT_PARK</id>
  </enumerationType>
  <enumerationType>
    <description>DRAM Write Vref. Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT) or mss_eff_cnfg_termination consumer: various.C and initfile firmware notes: none This is the nominal value This is for DDR3 This Attribute is to be interpreted as an Integer</description>
    <enumerator>
      <name>VDD420</name>
      <value>420</value>
    </enumerator>
    <enumerator>
      <name>VDD425</name>
      <value>425</value>
    </enumerator>
    <enumerator>
      <name>VDD430</name>
      <value>430</value>
    </enumerator>
    <enumerator>
      <name>VDD435</name>
      <value>435</value>
    </enumerator>
    <enumerator>
      <name>VDD440</name>
      <value>440</value>
    </enumerator>
    <enumerator>
      <name>VDD445</name>
      <value>445</value>
    </enumerator>
    <enumerator>
      <name>VDD450</name>
      <value>450</value>
    </enumerator>
    <enumerator>
      <name>VDD455</name>
      <value>455</value>
    </enumerator>
    <enumerator>
      <name>VDD460</name>
      <value>460</value>
    </enumerator>
    <enumerator>
      <name>VDD465</name>
      <value>465</value>
    </enumerator>
    <enumerator>
      <name>VDD470</name>
      <value>470</value>
    </enumerator>
    <enumerator>
      <name>VDD475</name>
      <value>475</value>
    </enumerator>
    <enumerator>
      <name>VDD480</name>
      <value>480</value>
    </enumerator>
    <enumerator>
      <name>VDD485</name>
      <value>485</value>
    </enumerator>
    <enumerator>
      <name>VDD490</name>
      <value>490</value>
    </enumerator>
    <enumerator>
      <name>VDD495</name>
      <value>495</value>
    </enumerator>
    <enumerator>
      <name>VDD500</name>
      <value>500</value>
    </enumerator>
    <enumerator>
      <name>VDD505</name>
      <value>505</value>
    </enumerator>
    <enumerator>
      <name>VDD510</name>
      <value>510</value>
    </enumerator>
    <enumerator>
      <name>VDD515</name>
      <value>515</value>
    </enumerator>
    <enumerator>
      <name>VDD520</name>
      <value>520</value>
    </enumerator>
    <enumerator>
      <name>VDD525</name>
      <value>525</value>
    </enumerator>
    <enumerator>
      <name>VDD530</name>
      <value>530</value>
    </enumerator>
    <enumerator>
      <name>VDD535</name>
      <value>535</value>
    </enumerator>
    <enumerator>
      <name>VDD540</name>
      <value>540</value>
    </enumerator>
    <enumerator>
      <name>VDD545</name>
      <value>545</value>
    </enumerator>
    <enumerator>
      <name>VDD550</name>
      <value>550</value>
    </enumerator>
    <enumerator>
      <name>VDD555</name>
      <value>555</value>
    </enumerator>
    <enumerator>
      <name>VDD560</name>
      <value>560</value>
    </enumerator>
    <enumerator>
      <name>VDD565</name>
      <value>565</value>
    </enumerator>
    <enumerator>
      <name>VDD570</name>
      <value>570</value>
    </enumerator>
    <enumerator>
      <name>VDD575</name>
      <value>575</value>
    </enumerator>
    <id>CEN_VPD_DRAM_WR_VREF</id>
  </enumerationType>
  <enumerationType>
    <description>Centaur DQ and DQS Drive Impedance Used in various locations and comes from the MT Keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT)/mss_eff_cnfg_termination consumer: initfile,various.C files firmware notes: none This is the nominal value This Attribute is to be interpreted as an Integer</description>
    <enumerator>
      <name>OHM24_FFE0</name>
      <value>0x0A</value>
    </enumerator>
    <enumerator>
      <name>OHM30_FFE0</name>
      <value>0x08</value>
    </enumerator>
    <enumerator>
      <name>OHM30_FFE480</name>
      <value>0x48</value>
    </enumerator>
    <enumerator>
      <name>OHM30_FFE240</name>
      <value>0x38</value>
    </enumerator>
    <enumerator>
      <name>OHM30_FFE160</name>
      <value>0x28</value>
    </enumerator>
    <enumerator>
      <name>OHM30_FFE120</name>
      <value>0x18</value>
    </enumerator>
    <enumerator>
      <name>OHM34_FFE0</name>
      <value>0x07</value>
    </enumerator>
    <enumerator>
      <name>OHM34_FFE480</name>
      <value>0x47</value>
    </enumerator>
    <enumerator>
      <name>OHM34_FFE240</name>
      <value>0x37</value>
    </enumerator>
    <enumerator>
      <name>OHM34_FFE160</name>
      <value>0x27</value>
    </enumerator>
    <enumerator>
      <name>OHM34_FFE120</name>
      <value>0x17</value>
    </enumerator>
    <enumerator>
      <name>OHM40_FFE0</name>
      <value>0x06</value>
    </enumerator>
    <enumerator>
      <name>OHM40_FFE480</name>
      <value>0x46</value>
    </enumerator>
    <enumerator>
      <name>OHM40_FFE240</name>
      <value>0x36</value>
    </enumerator>
    <enumerator>
      <name>OHM40_FFE160</name>
      <value>0x26</value>
    </enumerator>
    <enumerator>
      <name>OHM40_FFE120</name>
      <value>0x16</value>
    </enumerator>
    <id>CEN_VPD_DRV_IMP_DQ_DQS</id>
  </enumerationType>
  <enumerationType>
    <description>Centaur Address Drive Impedance Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: mss_eff_cnfg_termination consumer: initfile and various.C firmware notes: none This is the nominal value This Attribute is to be interpreted as an Integer</description>
    <enumerator>
      <name>OHM15</name>
      <value>15</value>
    </enumerator>
    <enumerator>
      <name>OHM20</name>
      <value>20</value>
    </enumerator>
    <enumerator>
      <name>OHM30</name>
      <value>30</value>
    </enumerator>
    <enumerator>
      <name>OHM40</name>
      <value>40</value>
    </enumerator>
    <id>CEN_VPD_DRV_IMP_ADDR</id>
  </enumerationType>
  <enumerationType>
    <description>Centaur Control Drive Impedance Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT)/mss_eff_cnfg_termination consumer: initfile,various .C firmware notes: none This is the nominal value This Attribute is to be interpreted as an Integer</description>
    <enumerator>
      <name>OHM15</name>
      <value>15</value>
    </enumerator>
    <enumerator>
      <name>OHM20</name>
      <value>20</value>
    </enumerator>
    <enumerator>
      <name>OHM30</name>
      <value>30</value>
    </enumerator>
    <enumerator>
      <name>OHM40</name>
      <value>40</value>
    </enumerator>
    <id>CEN_VPD_DRV_IMP_CNTL</id>
  </enumerationType>
  <enumerationType>
    <description>Centaur Clock Drive Impedance Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT),mss_eff_cnfg_termination consumer: initfiles,various firmware notes: none This is the nominal value This Attribute is to be interpreted as an Integer</description>
    <enumerator>
      <name>OHM15</name>
      <value>15</value>
    </enumerator>
    <enumerator>
      <name>OHM20</name>
      <value>20</value>
    </enumerator>
    <enumerator>
      <name>OHM30</name>
      <value>30</value>
    </enumerator>
    <enumerator>
      <name>OHM40</name>
      <value>40</value>
    </enumerator>
    <id>CEN_VPD_DRV_IMP_CLK</id>
  </enumerationType>
  <enumerationType>
    <description>Centaur Spare Clock Drive Impedance Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT) , mss_eff_cnfg_termination consumer: initfiles, various.C firmware notes: none This is the nominal value This Attribute is to be interpreted as an Integer</description>
    <enumerator>
      <name>OHM15</name>
      <value>15</value>
    </enumerator>
    <enumerator>
      <name>OHM20</name>
      <value>20</value>
    </enumerator>
    <enumerator>
      <name>OHM30</name>
      <value>30</value>
    </enumerator>
    <enumerator>
      <name>OHM40</name>
      <value>40</value>
    </enumerator>
    <id>CEN_VPD_DRV_IMP_SPCKE</id>
  </enumerationType>
  <enumerationType>
    <description>Centaur DQ and DQS Receiver Impedance Used in various locations and it comes from the VPD MT keyword for custom DIMMs or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD, mss_eff_cnfg_termination Consumer: initfile + C code firmware notes: none This is the nominal value This Attribute is to be interpreted as an Integer</description>
    <enumerator>
      <name>OHM15</name>
      <value>15</value>
    </enumerator>
    <enumerator>
      <name>OHM20</name>
      <value>20</value>
    </enumerator>
    <enumerator>
      <name>OHM30</name>
      <value>30</value>
    </enumerator>
    <enumerator>
      <name>OHM40</name>
      <value>40</value>
    </enumerator>
    <enumerator>
      <name>OHM48</name>
      <value>48</value>
    </enumerator>
    <enumerator>
      <name>OHM60</name>
      <value>60</value>
    </enumerator>
    <enumerator>
      <name>OHM80</name>
      <value>80</value>
    </enumerator>
    <enumerator>
      <name>OHM120</name>
      <value>120</value>
    </enumerator>
    <enumerator>
      <name>OHM160</name>
      <value>160</value>
    </enumerator>
    <enumerator>
      <name>OHM240</name>
      <value>240</value>
    </enumerator>
    <id>CEN_VPD_RCV_IMP_DQ_DQS</id>
  </enumerationType>
  <enumerationType>
    <description>Centaur DQ and DQS Slew Rate Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Slowest slew rate is 0, incrementing by one. The lower the number the slower the slew rate the higher the faster. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT), mss_eff_cnfg_termination consumer: initfiles,various.C firmware notes: none This is the nominal value This Attribute is to be interpreted as an Integer except MAX</description>
    <enumerator>
      <name>SLEW_3V_NS</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>SLEW_4V_NS</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>SLEW_5V_NS</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>SLEW_6V_NS</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>SLEW_MAXV_NS</name>
      <value>7</value>
    </enumerator>
    <id>CEN_VPD_SLEW_RATE_DQ_DQS</id>
  </enumerationType>
  <enumerationType>
    <description>Centaur Address Slew Rate Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Slowest slew rate is 0, incrementing by one. The lower the number the slower the slew rate the higher the faster. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT),mss_eff_cnfg_termination consumer: initfile,various .C files firmware notes: none This is the nominal value This Attribute is to be interpreted as an Integer except Max</description>
    <enumerator>
      <name>SLEW_3V_NS</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>SLEW_4V_NS</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>SLEW_5V_NS</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>SLEW_6V_NS</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>SLEW_MAXV_NS</name>
      <value>7</value>
    </enumerator>
    <id>CEN_VPD_SLEW_RATE_ADDR</id>
  </enumerationType>
  <enumerationType>
    <description>Centaur Clock Slew Rate Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Slowest slew rate is 0, incrementing by one. The lower the number the slower the slew rate the higher the faster. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT)mss_eff_cnfg_termination consumer: initfile,various.C files firmware notes: none This is the nominal value This Attribute is to be interpreted as an Integer except max</description>
    <enumerator>
      <name>SLEW_3V_NS</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>SLEW_4V_NS</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>SLEW_5V_NS</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>SLEW_6V_NS</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>SLEW_MAXV_NS</name>
      <value>7</value>
    </enumerator>
    <id>CEN_VPD_SLEW_RATE_CLK</id>
  </enumerationType>
  <enumerationType>
    <description>Centaur Spare Clock Slew Rate Used in various locations and comes from the MT keyword or is computed in mss_eff_cnfg_termination. Slowest slew rate is 0, incrementing by one. The lower the number the slower the slew rate the higher the faster. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT) or mss_eff_cnfg_termination consumer: initfile,various.C firmware notes: none This is the nominal value This Attribute is to be interpreted as an Integer except max</description>
    <enumerator>
      <name>SLEW_3V_NS</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>SLEW_4V_NS</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>SLEW_5V_NS</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>SLEW_6V_NS</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>SLEW_MAXV_NS</name>
      <value>7</value>
    </enumerator>
    <id>CEN_VPD_SLEW_RATE_SPCKE</id>
  </enumerationType>
  <enumerationType>
    <description>Centaur Control Slew Rate Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Slowest slew rate is 0, incrementing by one. The lower the number the slower the slew rate the higher the faster. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT),mss_eff_cnfg_termination consumer:initfile, various .C files firmware notes: none This is the nominal value This Attribute is to be interpreted as an Integer except for max</description>
    <enumerator>
      <name>SLEW_3V_NS</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>SLEW_4V_NS</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>SLEW_5V_NS</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>SLEW_6V_NS</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>SLEW_MAXV_NS</name>
      <value>7</value>
    </enumerator>
    <id>CEN_VPD_SLEW_RATE_CNTL</id>
  </enumerationType>
  <enumerationType>
    <description>Centaur Read Vref. Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Creator: VPD(MT) or mss_eff_cnfg_termination consumer: various.C and initfiles firmware notes: none This is the nominal value This Attribute is to be interpreted as an Integer</description>
    <enumerator>
      <name>VDD40375</name>
      <value>40375</value>
    </enumerator>
    <enumerator>
      <name>VDD41750</name>
      <value>41750</value>
    </enumerator>
    <enumerator>
      <name>VDD43125</name>
      <value>43125</value>
    </enumerator>
    <enumerator>
      <name>VDD44500</name>
      <value>44500</value>
    </enumerator>
    <enumerator>
      <name>VDD45875</name>
      <value>45875</value>
    </enumerator>
    <enumerator>
      <name>VDD47250</name>
      <value>47250</value>
    </enumerator>
    <enumerator>
      <name>VDD48625</name>
      <value>48625</value>
    </enumerator>
    <enumerator>
      <name>VDD50000</name>
      <value>50000</value>
    </enumerator>
    <enumerator>
      <name>VDD51375</name>
      <value>51375</value>
    </enumerator>
    <enumerator>
      <name>VDD52750</name>
      <value>52750</value>
    </enumerator>
    <enumerator>
      <name>VDD54125</name>
      <value>54125</value>
    </enumerator>
    <enumerator>
      <name>VDD55500</name>
      <value>55500</value>
    </enumerator>
    <enumerator>
      <name>VDD56875</name>
      <value>56875</value>
    </enumerator>
    <enumerator>
      <name>VDD58250</name>
      <value>58250</value>
    </enumerator>
    <enumerator>
      <name>VDD59625</name>
      <value>59625</value>
    </enumerator>
    <enumerator>
      <name>VDD61000</name>
      <value>61000</value>
    </enumerator>
    <enumerator>
      <name>VDD60375</name>
      <value>60375</value>
    </enumerator>
    <enumerator>
      <name>VDD61750</name>
      <value>61750</value>
    </enumerator>
    <enumerator>
      <name>VDD63125</name>
      <value>63125</value>
    </enumerator>
    <enumerator>
      <name>VDD64500</name>
      <value>64500</value>
    </enumerator>
    <enumerator>
      <name>VDD65875</name>
      <value>65875</value>
    </enumerator>
    <enumerator>
      <name>VDD67250</name>
      <value>67250</value>
    </enumerator>
    <enumerator>
      <name>VDD68625</name>
      <value>68625</value>
    </enumerator>
    <enumerator>
      <name>VDD70000</name>
      <value>70000</value>
    </enumerator>
    <enumerator>
      <name>VDD71375</name>
      <value>71375</value>
    </enumerator>
    <enumerator>
      <name>VDD72750</name>
      <value>72750</value>
    </enumerator>
    <enumerator>
      <name>VDD74125</name>
      <value>74125</value>
    </enumerator>
    <enumerator>
      <name>VDD75500</name>
      <value>75500</value>
    </enumerator>
    <enumerator>
      <name>VDD76875</name>
      <value>76875</value>
    </enumerator>
    <enumerator>
      <name>VDD78250</name>
      <value>78250</value>
    </enumerator>
    <enumerator>
      <name>VDD79625</name>
      <value>79625</value>
    </enumerator>
    <enumerator>
      <name>VDD81000</name>
      <value>81000</value>
    </enumerator>
    <id>CEN_VPD_RD_VREF</id>
  </enumerationType>
  <enumerationType>
    <description>Describes if this MBA is in 2N address mode. The DIMM attributes associated with this MBA describes if this mode is needed for SI. Come from the VPD and consumed in the mba_def.initfile.</description>
    <enumerator>
      <name>FALSE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>1</value>
    </enumerator>
    <id>CEN_VPD_DRAM_2N_MODE_ENABLED</id>
  </enumerationType>
  <enumerationType>
    <description>Capable power control settings.</description>
    <enumerator>
      <name>NONE</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>SLOWEXIT_CAPABLE</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>FASTEXIT_CAPABLE</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>FASTSLOW_CAPABLE</name>
      <value>0x03</value>
    </enumerator>
    <id>CEN_VPD_POWER_CONTROL_CAPABLE</id>
  </enumerationType>
  <enumerationType>
    <description>RCD IBT. Used in mss_dram_init and is computed in mss_eff_cnfg. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Each dimm will have a value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes: none</description>
    <enumerator>
      <name>IBT_OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>IBT_100</name>
      <value>100</value>
    </enumerator>
    <enumerator>
      <name>IBT_150</name>
      <value>150</value>
    </enumerator>
    <enumerator>
      <name>IBT_200</name>
      <value>200</value>
    </enumerator>
    <enumerator>
      <name>IBT_300</name>
      <value>300</value>
    </enumerator>
    <id>CEN_VPD_DIMM_RCD_IBT</id>
  </enumerationType>
  <enumerationType>
    <description>DRAM Write Vref. Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT) or mss_eff_cnfg_termination consumer: various.C and initfile firmware notes: none This is the nominal value This is for DDR3</description>
    <enumerator>
      <name>VDD420</name>
      <value>420</value>
    </enumerator>
    <enumerator>
      <name>VDD425</name>
      <value>425</value>
    </enumerator>
    <enumerator>
      <name>VDD430</name>
      <value>430</value>
    </enumerator>
    <enumerator>
      <name>VDD435</name>
      <value>435</value>
    </enumerator>
    <enumerator>
      <name>VDD440</name>
      <value>440</value>
    </enumerator>
    <enumerator>
      <name>VDD445</name>
      <value>445</value>
    </enumerator>
    <enumerator>
      <name>VDD450</name>
      <value>450</value>
    </enumerator>
    <enumerator>
      <name>VDD455</name>
      <value>455</value>
    </enumerator>
    <enumerator>
      <name>VDD460</name>
      <value>460</value>
    </enumerator>
    <enumerator>
      <name>VDD465</name>
      <value>465</value>
    </enumerator>
    <enumerator>
      <name>VDD470</name>
      <value>470</value>
    </enumerator>
    <enumerator>
      <name>VDD475</name>
      <value>475</value>
    </enumerator>
    <enumerator>
      <name>VDD480</name>
      <value>480</value>
    </enumerator>
    <enumerator>
      <name>VDD485</name>
      <value>485</value>
    </enumerator>
    <enumerator>
      <name>VDD490</name>
      <value>490</value>
    </enumerator>
    <enumerator>
      <name>VDD495</name>
      <value>495</value>
    </enumerator>
    <enumerator>
      <name>VDD500</name>
      <value>500</value>
    </enumerator>
    <enumerator>
      <name>VDD505</name>
      <value>505</value>
    </enumerator>
    <enumerator>
      <name>VDD510</name>
      <value>510</value>
    </enumerator>
    <enumerator>
      <name>VDD515</name>
      <value>515</value>
    </enumerator>
    <enumerator>
      <name>VDD520</name>
      <value>520</value>
    </enumerator>
    <enumerator>
      <name>VDD525</name>
      <value>525</value>
    </enumerator>
    <enumerator>
      <name>VDD530</name>
      <value>530</value>
    </enumerator>
    <enumerator>
      <name>VDD535</name>
      <value>535</value>
    </enumerator>
    <enumerator>
      <name>VDD540</name>
      <value>540</value>
    </enumerator>
    <enumerator>
      <name>VDD545</name>
      <value>545</value>
    </enumerator>
    <enumerator>
      <name>VDD550</name>
      <value>550</value>
    </enumerator>
    <enumerator>
      <name>VDD555</name>
      <value>555</value>
    </enumerator>
    <enumerator>
      <name>VDD560</name>
      <value>560</value>
    </enumerator>
    <enumerator>
      <name>VDD565</name>
      <value>565</value>
    </enumerator>
    <enumerator>
      <name>VDD570</name>
      <value>570</value>
    </enumerator>
    <enumerator>
      <name>VDD575</name>
      <value>575</value>
    </enumerator>
    <id>CEN_EFF_DRAM_WR_VREF</id>
  </enumerationType>
  <enumerationType>
    <description>Centaur DQ and DQS Drive Impedance Used in various locations and comes from the MT Keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT)/mss_eff_cnfg_termination consumer: initfile,various.C files firmware notes: none This is the nominal value</description>
    <enumerator>
      <name>OHM24_FFE0</name>
      <value>0x0A</value>
    </enumerator>
    <enumerator>
      <name>OHM30_FFE0</name>
      <value>0x08</value>
    </enumerator>
    <enumerator>
      <name>OHM30_FFE480</name>
      <value>0x48</value>
    </enumerator>
    <enumerator>
      <name>OHM30_FFE240</name>
      <value>0x38</value>
    </enumerator>
    <enumerator>
      <name>OHM30_FFE160</name>
      <value>0x28</value>
    </enumerator>
    <enumerator>
      <name>OHM30_FFE120</name>
      <value>0x18</value>
    </enumerator>
    <enumerator>
      <name>OHM34_FFE0</name>
      <value>0x07</value>
    </enumerator>
    <enumerator>
      <name>OHM34_FFE480</name>
      <value>0x47</value>
    </enumerator>
    <enumerator>
      <name>OHM34_FFE240</name>
      <value>0x37</value>
    </enumerator>
    <enumerator>
      <name>OHM34_FFE160</name>
      <value>0x27</value>
    </enumerator>
    <enumerator>
      <name>OHM34_FFE120</name>
      <value>0x17</value>
    </enumerator>
    <enumerator>
      <name>OHM40_FFE0</name>
      <value>0x06</value>
    </enumerator>
    <enumerator>
      <name>OHM40_FFE480</name>
      <value>0x46</value>
    </enumerator>
    <enumerator>
      <name>OHM40_FFE240</name>
      <value>0x36</value>
    </enumerator>
    <enumerator>
      <name>OHM40_FFE160</name>
      <value>0x26</value>
    </enumerator>
    <enumerator>
      <name>OHM40_FFE120</name>
      <value>0x16</value>
    </enumerator>
    <id>CEN_EFF_CEN_DRV_IMP_DQ_DQS</id>
  </enumerationType>
  <enumerationType>
    <description>Centaur DQ and DQS Receiver Impedance Used in various locations and it comes from the VPD MT keyword for custom DIMMs or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD, mss_eff_cnfg_termination Consumer: initfile + C code firmware notes: none This is the nominal value</description>
    <enumerator>
      <name>OHM15</name>
      <value>15</value>
    </enumerator>
    <enumerator>
      <name>OHM20</name>
      <value>20</value>
    </enumerator>
    <enumerator>
      <name>OHM30</name>
      <value>30</value>
    </enumerator>
    <enumerator>
      <name>OHM40</name>
      <value>40</value>
    </enumerator>
    <enumerator>
      <name>OHM48</name>
      <value>48</value>
    </enumerator>
    <enumerator>
      <name>OHM60</name>
      <value>60</value>
    </enumerator>
    <enumerator>
      <name>OHM80</name>
      <value>80</value>
    </enumerator>
    <enumerator>
      <name>OHM120</name>
      <value>120</value>
    </enumerator>
    <enumerator>
      <name>OHM160</name>
      <value>160</value>
    </enumerator>
    <enumerator>
      <name>OHM240</name>
      <value>240</value>
    </enumerator>
    <id>CEN_EFF_CEN_RCV_IMP_DQ_DQS</id>
  </enumerationType>
  <enumerationType>
    <description>At a system level, this attribute controls if interleaving is required, requested or never. The MRW.</description>
    <enumerator>
      <name>NEVER</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>REQUIRED</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>REQUESTED</name>
      <value>2</value>
    </enumerator>
    <id>CEN_MRW_MBA_CACHELINE_INTERLEAVE_MODE_CONTROL</id>
  </enumerationType>
  <enumerationType>
    <description>Value of on or off. Determines if prefetching enabled or not. See chapter 7 of the Centaur Workbook.</description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <id>CEN_MSS_PREFETCH_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Value of on or off. Determines if the cleaner of the L4 cache (write modified entries to memory on idle cycles) enabled or not. See chapter 7 of the Centaur Workbook.</description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <id>CEN_MSS_CLEANER_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>When this value is true, then mss_eff config will allow a single port to have one dimm and will allow ports to have different sizes. Used in eff_config</description>
    <enumerator>
      <name>FALSE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>1</value>
    </enumerator>
    <id>CEN_MSS_ALLOW_SINGLE_PORT</id>
  </enumerationType>
  <enumerationType>
    <description>DQS Swizzle type is set by the platform to describe what kind of DQS connection is being used for register acceses. Type 0 is normal, type 1 is for systems with wiring like glacier 1, type 2 is for Pallmeto. Additional types maybe defined if new boards have even different DQS swizzle features</description>
    <enumerator>
      <name>NORMAL_TYPE_0</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>GLACIER_TYPE_1</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ISDIMM_TYPE_2</name>
      <value>2</value>
    </enumerator>
    <id>CEN_MSS_DQS_SWIZZLE_TYPE</id>
  </enumerationType>
  <enumerationType>
    <description>The MRW for a system should set this to TRUE for systems that must obey plug rules. Lab environments should default this to off and allow the user to override using normal methods to test.</description>
    <enumerator>
      <name>FALSE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>1</value>
    </enumerator>
    <id>CEN_MRW_STRICT_MBA_PLUG_RULE_CHECKING</id>
  </enumerationType>
  <enumerationType>
    <description>Used for Custom DIMMs to not enable the reading of the dimm temperature sensor on the master i2c bus</description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <id>CEN_MRW_CDIMM_MASTER_I2C_TEMP_SENSOR_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Used for Custom DIMMs to not enable the reading of the dimm temperature sensor on the spare i2c bus</description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <id>CEN_MRW_CDIMM_SPARE_I2C_TEMP_SENSOR_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Capable power control settings. In MRW.</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>SLOWEXIT</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>FASTEXIT</name>
      <value>0x02</value>
    </enumerator>
    <id>CEN_MRW_POWER_CONTROL_REQUESTED</id>
  </enumerationType>
  <enumerationType>
    <description>List of Voltages that are compliant with the system. DIMMs that do not have voltages listed in their SPD as supported are errored out. Procedure defined is currently 1.2V and 1.35V only.</description>
    <enumerator>
      <name>PROCEDURE_DEFINED</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ALL_VOLTAGES</name>
      <value>0x01</value>
    </enumerator>
    <id>CEN_MSS_VOLT_COMPLIANT_DIMMS</id>
  </enumerationType>
  <enumerationType>
    <default>NONE</default>
    <description>Enumeration specifying a target's CEC degraded mode domain</description>
    <enumerator>
      <name>NONE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>CPU</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>DIMM</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>FABRIC</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>MEM</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>IO</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>NODE</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>CLOCK</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>PSI</name>
      <value>8</value>
    </enumerator>
    <enumerator>
      <name>FSP</name>
      <value>9</value>
    </enumerator>
    <enumerator>
      <name>ALL</name>
      <value>10</value>
    </enumerator>
    <id>CDM_DOMAIN</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration of CDM_POLICIES flags</description>
    <enumerator>
      <description>MFG_Guard policy: Used in MFG only to prevent and disable the following: . Storing or creation of new Guard records from Diagno`stic or other faults through error logs. This is all domains, CEC processor/memory, VPD, FSP, etc. . Storing or creation of Manual Guard record from user. NOTE: this does not stop FCO. . Using an already stored System or Manual Guard record from deconfiguring resources. This is all domains, CEC processor/memory, VPD, FSP, etc.</description>
      <name>MANUFACTURING_DISABLED</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <description>Predictive_Guard policy: Used in Field or development to prevent and disable the following: . Storing or creation of new Guard records from diagnostics or other faults through error logs with the error_type of Predictive. . Using an already stored System Guard record with error_type of Predictive from deconfiguring resources.</description>
      <name>PREDICTIVE_DISABLED</name>
      <value>0x02</value>
    </enumerator>
    <id>CDM_POLICIES</id>
  </enumerationType>
  <enumerationType>
    <default>NA</default>
    <description>Enumeration indicating the target's class</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>CARD</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ENC</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>CHIP</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>UNIT</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>DEV</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>SYS</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>LOGICAL_CARD</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>BATTERY</name>
      <value>8</value>
    </enumerator>
    <enumerator>
      <name>LED</name>
      <value>9</value>
    </enumerator>
    <enumerator>
      <name>SP</name>
      <value>10</value>
    </enumerator>
    <enumerator>
      <name>MAX</name>
      <value>11</value>
    </enumerator>
    <id>CLASS</id>
  </enumerationType>
  <enumerationType>
    <default>NA</default>
    <description>Enumeration indicating the target's engine type</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ENGINE_IIC</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ENGINE_SCOM</name>
      <value>2</value>
    </enumerator>
    <id>ENGINE_TYPE</id>
  </enumerationType>
  <enumerationType>
    <description>Pulled from the MRW, this describes the device purpose to the HDAT. This is for I2C devices only.</description>
    <enumerator>
      <name>CABLE_CARD_PRES</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>PCI_HOTPLUG_PGOOD</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>PCI_HOTPLUG_CONTROL</name>
      <value>0x3</value>
    </enumerator>
    <enumerator>
      <name>TPM</name>
      <value>0x4</value>
    </enumerator>
    <enumerator>
      <name>MODULE_VPD</name>
      <value>0x5</value>
    </enumerator>
    <enumerator>
      <name>DIMM_SPD</name>
      <value>0x6</value>
    </enumerator>
    <enumerator>
      <name>PROC_MODULE_VPD</name>
      <value>0x7</value>
    </enumerator>
    <enumerator>
      <name>SBE_SEEPROM</name>
      <value>0x8</value>
    </enumerator>
    <enumerator>
      <name>PLANAR_VPD</name>
      <value>0x9</value>
    </enumerator>
    <enumerator>
      <name>NVLINK_CABLE_TOPOLOGY_VERIFICATION</name>
      <value>0xA</value>
    </enumerator>
    <enumerator>
      <name>NVLINK</name>
      <value>0xB</value>
    </enumerator>
    <enumerator>
      <name>NVLINK_CABLE_MICRO_RESET</name>
      <value>0xB</value>
    </enumerator>
    <enumerator>
      <name>I2C_ASSOC_WITH_NVLINK_CABLE</name>
      <value>0xC</value>
    </enumerator>
    <enumerator>
      <name>WINDOW_OPEN</name>
      <value>0xD</value>
    </enumerator>
    <enumerator>
      <name>PHYSICAL_PRESENCE</name>
      <value>0xE</value>
    </enumerator>
    <enumerator>
      <name>MEX_FPGA</name>
      <value>0xF</value>
    </enumerator>
    <enumerator>
      <name>UNKNOWN</name>
      <value>0xFF</value>
    </enumerator>
    <id>HDAT_I2C_DEVICE_PURPOSE</id>
  </enumerationType>
  <enumerationType>
    <description>Pulled from the MRW, this describes the device type to the HDAT. This is for I2C devices only.</description>
    <enumerator>
      <name>9551</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>955X</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel28c128</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>NUVOTON_TPM</name>
      <value>0x3</value>
    </enumerator>
    <enumerator>
      <name>MEX_FPGA</name>
      <value>0x4</value>
    </enumerator>
    <enumerator>
      <name>UCX90XX</name>
      <value>0x5</value>
    </enumerator>
    <enumerator>
      <name>NVLINK</name>
      <value>0x6</value>
    </enumerator>
    <enumerator>
      <name>9552</name>
      <value>0x6</value>
    </enumerator>
    <enumerator>
      <name>9553</name>
      <value>0x7</value>
    </enumerator>
    <enumerator>
      <name>9554</name>
      <value>0x8</value>
    </enumerator>
    <enumerator>
      <name>9555</name>
      <value>0x9</value>
    </enumerator>
    <enumerator>
      <name>SMP_or_OpenCAPI_Cable</name>
      <value>0xA</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel28c256</name>
      <value>0xB</value>
    </enumerator>
    <enumerator>
      <name>UNKNOWN</name>
      <value>0xFF</value>
    </enumerator>
    <id>HDAT_I2C_DEVICE_TYPE</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration indicating the services that are concerned with target changes (ie, via HCDB change). The values can be combined using a bitwise 'OR'.</description>
    <enumerator>
      <name>GARD</name>
      <value>0x00000001</value>
    </enumerator>
    <enumerator>
      <name>MEMDIAG</name>
      <value>0x00000002</value>
    </enumerator>
    <enumerator>
      <name>PSIDIAG</name>
      <value>0x00000004</value>
    </enumerator>
    <enumerator>
      <name>DIAG_MASK</name>
      <value>0x00000006</value>
    </enumerator>
    <enumerator>
      <name>HOSTSVC_HBEL</name>
      <value>0x00000008</value>
    </enumerator>
    <enumerator>
      <name>RESRC_RECOV</name>
      <value>0x00000010</value>
    </enumerator>
    <enumerator>
      <name>GARD_APPLIED</name>
      <value>0x00000020</value>
    </enumerator>
    <id>HWAS_CHANGED_BIT</id>
  </enumerationType>
  <enumerationType>
    <description>Enum for MFG_WRAP_TEST_ABUS_LINKS_SET</description>
    <enumerator>
      <name>SET_NONE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>SET_1</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>SET_2</name>
      <value>0x2</value>
    </enumerator>
    <id>MFG_WRAP_TEST_ABUS_LINKS_SET</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration indicating the mnfg flags that are set by the user. The values can be combined using a bitwise 'OR'. The values will need to be kept in sync with the FAPI enumerator values. Also the enumeration type is used by the ATTR_MNFG_FLAGS attribute. Should note that the MNFG_FLAG values are of type uint32_t</description>
    <enumerator>
      <name>THRESHOLDS</name>
      <value>0x00000001</value>
    </enumerator>
    <enumerator>
      <name>AVP_ENABLE</name>
      <value>0x00000002</value>
    </enumerator>
    <enumerator>
      <name>HDAT_AVP_ENABLE</name>
      <value>0x00000004</value>
    </enumerator>
    <enumerator>
      <name>SRC_TERM</name>
      <value>0x00000008</value>
    </enumerator>
    <enumerator>
      <name>IPL_MEMORY_CE_CHECKING</name>
      <value>0x00000010</value>
    </enumerator>
    <enumerator>
      <name>FAST_BACKGROUND_SCRUB</name>
      <value>0x00000020</value>
    </enumerator>
    <enumerator>
      <name>TEST_DRAM_REPAIRS</name>
      <value>0x00000040</value>
    </enumerator>
    <enumerator>
      <name>DISABLE_DRAM_REPAIRS</name>
      <value>0x00000080</value>
    </enumerator>
    <enumerator>
      <name>ENABLE_EXHAUSTIVE_PATTERN_TEST</name>
      <value>0x00000100</value>
    </enumerator>
    <enumerator>
      <name>ENABLE_STANDARD_PATTERN_TEST</name>
      <value>0x00000200</value>
    </enumerator>
    <enumerator>
      <name>ENABLE_MINIMUM_PATTERN_TEST</name>
      <value>0x00000400</value>
    </enumerator>
    <enumerator>
      <name>DISABLE_FABRIC_eREPAIR</name>
      <value>0x00000800</value>
    </enumerator>
    <enumerator>
      <name>DISABLE_MEMORY_eREPAIR</name>
      <value>0x00001000</value>
    </enumerator>
    <enumerator>
      <name>FABRIC_DEPLOY_LANE_SPARES</name>
      <value>0x00002000</value>
    </enumerator>
    <enumerator>
      <name>DMI_DEPLOY_LANE_SPARES</name>
      <value>0x00004000</value>
    </enumerator>
    <enumerator>
      <name>PSI_DIAGNOSTIC</name>
      <value>0x00008000</value>
    </enumerator>
    <enumerator>
      <name>BRAZOS_WRAP_CONFIG</name>
      <value>0x00010000</value>
    </enumerator>
    <enumerator>
      <name>FSP_UPDATE_SBE_IMAGE</name>
      <value>0x00020000</value>
    </enumerator>
    <enumerator>
      <name>UPDATE_BOTH_SIDES_OF_SBE</name>
      <value>0x00040000</value>
    </enumerator>
    <enumerator>
      <name>IMMEDIATE_HALT</name>
      <value>0x00080000</value>
    </enumerator>
    <id>MNFG_FLAG</id>
  </enumerationType>
  <enumerationType>
    <default>NA</default>
    <description>Enumeration indicating the target's model</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>RESERVED</name>
      <value>16</value>
    </enumerator>
    <enumerator>
      <name>VENICE</name>
    </enumerator>
    <enumerator>
      <name>MURANO</name>
    </enumerator>
    <enumerator>
      <name>NAPLES</name>
    </enumerator>
    <enumerator>
      <name>NIMBUS</name>
    </enumerator>
    <enumerator>
      <name>CUMULUS</name>
    </enumerator>
    <enumerator>
      <name>AXONE</name>
    </enumerator>
    <enumerator>
      <name>CENTAUR</name>
      <value>48</value>
    </enumerator>
    <enumerator>
      <name>EXPLORER</name>
    </enumerator>
    <enumerator>
      <name>JEDEC</name>
      <value>80</value>
    </enumerator>
    <enumerator>
      <name>CDIMM</name>
    </enumerator>
    <enumerator>
      <name>POWER8</name>
      <value>112</value>
    </enumerator>
    <enumerator>
      <name>POWER9</name>
      <value>144</value>
    </enumerator>
    <enumerator>
      <name>CECTPM</name>
    </enumerator>
    <enumerator>
      <name>BMC</name>
    </enumerator>
    <enumerator>
      <name>AST2500</name>
    </enumerator>
    <enumerator>
      <name>PCA9847</name>
    </enumerator>
    <id>MODEL</id>
  </enumerationType>
  <enumerationType>
    <default>NONE</default>
    <description>Memory power control settings for IDLE powersave mode Used by OCC when entering idle power-save mode</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>POWER_DOWN</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>PD_AND_STR</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>PD_AND_STR_CLK_STOP</name>
      <value>0x03</value>
    </enumerator>
    <id>MSS_MRW_IDLE_POWER_CONTROL_REQUESTED</id>
  </enumerationType>
  <enumerationType>
    <default>OFF</default>
    <description>Memory power control settings programmed during IPL Used by OCC when exiting idle power-save mode</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>POWER_DOWN</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>PD_AND_STR</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>PD_AND_STR_CLK_STOP</name>
      <value>0x03</value>
    </enumerator>
    <id>MSS_MRW_POWER_CONTROL_REQUESTED</id>
  </enumerationType>
  <enumerationType>
    <description>Used in MR4 A3 Temperature refresh mode Should be defaulted to disable</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_TEMP_REFRESH_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration indicating the multi scome buffer size. The values can be combined using a bitwise 'OR'. The values will need to be kept in sync with the FAPI enumerator values. Also the enumeration type is used by the ATTR_MULTI_SCOM_BUFFER_MAX_SIZE. Should note that the MULTI_SCOM_BUFFER_MAX_SIZE values are of type uint32_t</description>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_1KB</name>
      <value>0x00000400</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_2KB</name>
      <value>0x00000800</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_4KB</name>
      <value>0x00001000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_8KB</name>
      <value>0x00002000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_16KB</name>
      <value>0x00004000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_32KB</name>
      <value>0x00008000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_64KB</name>
      <value>0x00010000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_128KB</name>
      <value>0x00020000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_256KB</name>
      <value>0x00040000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_512KB</name>
      <value>0x00080000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_1MB</name>
      <value>0x00100000</value>
    </enumerator>
    <id>MULTI_SCOM_BUFFER_MAX_SIZE_BIT</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration indicating the BAR size used with ATTR_PROC_NPU_MMIO_BAR_SIZE</description>
    <enumerator>
      <name>2_MB</name>
      <value>0x0000000000200000</value>
    </enumerator>
    <enumerator>
      <name>1_MB</name>
      <value>0x0000000000100000</value>
    </enumerator>
    <enumerator>
      <name>512_KB</name>
      <value>0x0000000000080000</value>
    </enumerator>
    <enumerator>
      <name>256_KB</name>
      <value>0x0000000000040000</value>
    </enumerator>
    <enumerator>
      <name>128_KB</name>
      <value>0x0000000000020000</value>
    </enumerator>
    <enumerator>
      <name>64_KB</name>
      <value>0x0000000000010000</value>
    </enumerator>
    <id>NPU_MMIO_BAR_SIZE</id>
  </enumerationType>
  <enumerationType>
    <default>UNKNOWN</default>
    <description>Enumeration indicating what kind of payload is to be started</description>
    <enumerator>
      <name>UNKNOWN</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>PHYP</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SAPPHIRE</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>NONE</name>
      <value>3</value>
    </enumerator>
    <id>PAYLOAD_KIND</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration indicating the OFF setting for the core and cache chiplet VCS PFET controllers</description>
    <enumerator>
      <name>NOOFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT1TO7OFF</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT2TO7OFF</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT3TO7OFF</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT4TO7OFF</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT5TO7OFF</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT6TO7OFF</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT7TO7OFF</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>ALLOFF</name>
      <value>8</value>
    </enumerator>
    <id>PFET_VCS_VOFF_SEL</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration indicating the OFF setting for the core and cache chiplet DD PFET controllers</description>
    <enumerator>
      <name>NOOFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT1TO7OFF</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT2TO7OFF</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT3TO7OFF</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT4TO7OFF</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT5TO7OFF</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT6TO7OFF</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT7TO7OFF</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>ALLOFF</name>
      <value>8</value>
    </enumerator>
    <id>PFET_VDD_VOFF_SEL</id>
  </enumerationType>
  <enumerationType>
    <description>Processor epsilon table type. Used to calculate the processor nest epsilon register values. Provided by the MRW.</description>
    <enumerator>
      <name>EPS_TYPE_LE</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>EPS_TYPE_HE</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>EPS_TYPE_HE_F8</name>
      <value>0x03</value>
    </enumerator>
    <id>PROC_EPS_TABLE_TYPE</id>
  </enumerationType>
  <enumerationType>
    <description>Processor SMP A bus width. Provided by the MRW.</description>
    <enumerator>
      <name>2_BYTE</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>4_BYTE</name>
      <value>0x02</value>
    </enumerator>
    <id>PROC_FABRIC_A_BUS_WIDTH</id>
  </enumerationType>
  <enumerationType>
    <description>Processor CAPI attachement protocol mode. 0 = default = no: SMPA CAPI attachement 1 = yes: SMPA CAPI attachement Provided by the MRW.</description>
    <enumerator>
      <name>OFF</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_FABRIC_CAPI_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Processor SMP Fabric broadcast scope configuration. CHIP_IS_NODE = MODE1 = default CHIP_IS_GROUP = MODE2 Provided by the MRW.</description>
    <enumerator>
      <name>CHIP_IS_NODE</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>CHIP_IS_GROUP</name>
      <value>0x02</value>
    </enumerator>
    <id>PROC_FABRIC_PUMP_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Processor SMP optics mode. 0 = default = Optics_is_X_bus 1 = Optics_is_A_bus Provided by the MRW.</description>
    <enumerator>
      <name>OPTICS_IS_X_BUS</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>OPTICS_IS_A_BUS</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_FABRIC_SMP_OPTICS_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Processor SMP X bus width. Provided by the MRW.</description>
    <enumerator>
      <name>2_BYTE</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>4_BYTE</name>
      <value>0x02</value>
    </enumerator>
    <id>PROC_FABRIC_X_BUS_WIDTH</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration indicating which _PBIEX_ASYNC_SEL should be use</description>
    <enumerator>
      <name>SEL0</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>SEL1</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SEL2</name>
      <value>2</value>
    </enumerator>
    <id>PROC_PBIEX_ASYNC_SEL</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration indicating which chip should be used as the PROC_SELECT_BOOT_MASTER</description>
    <enumerator>
      <name>PRIMARY</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SECONDARY</name>
      <value>2</value>
    </enumerator>
    <id>PROC_SELECT_BOOT_MASTER</id>
  </enumerationType>
  <enumerationType>
    <default>NA</default>
    <description>Enumeration indication which Hot Plug Controllers are supported by the current system.</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>MAX5961</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>PCA9551</name>
      <value>0x02</value>
    </enumerator>
    <id>SUPPORTED_HOT_PLUG</id>
  </enumerationType>
  <enumerationType>
    <default>NA</default>
    <description>Enumeration indicating the target's type</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>SYS</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>NODE</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>DIMM</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>MEMBUF</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>PROC</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>EX</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>CORE</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>L2</name>
      <value>8</value>
    </enumerator>
    <enumerator>
      <name>L3</name>
      <value>9</value>
    </enumerator>
    <enumerator>
      <name>L4</name>
      <value>10</value>
    </enumerator>
    <enumerator>
      <name>MCS</name>
      <value>11</value>
    </enumerator>
    <enumerator>
      <name>MBA</name>
      <value>13</value>
    </enumerator>
    <enumerator>
      <name>XBUS</name>
      <value>14</value>
    </enumerator>
    <enumerator>
      <name>ABUS</name>
      <value>15</value>
    </enumerator>
    <enumerator>
      <name>PCI</name>
      <value>16</value>
    </enumerator>
    <enumerator>
      <name>DPSS</name>
      <value>17</value>
    </enumerator>
    <enumerator>
      <name>APSS</name>
      <value>18</value>
    </enumerator>
    <enumerator>
      <name>OCC</name>
      <value>19</value>
    </enumerator>
    <enumerator>
      <name>PSI</name>
      <value>20</value>
    </enumerator>
    <enumerator>
      <name>FSP</name>
      <value>21</value>
    </enumerator>
    <enumerator>
      <name>PNOR</name>
      <value>22</value>
    </enumerator>
    <enumerator>
      <name>OSC</name>
      <value>23</value>
    </enumerator>
    <enumerator>
      <name>TODCLK</name>
      <value>24</value>
    </enumerator>
    <enumerator>
      <name>CONTROL_NODE</name>
      <value>25</value>
    </enumerator>
    <enumerator>
      <name>OSCREFCLK</name>
      <value>26</value>
    </enumerator>
    <enumerator>
      <name>OSCPCICLK</name>
      <value>27</value>
    </enumerator>
    <enumerator>
      <name>REFCLKENDPT</name>
      <value>28</value>
    </enumerator>
    <enumerator>
      <name>PCICLKENDPT</name>
      <value>29</value>
    </enumerator>
    <enumerator>
      <name>NX</name>
      <value>30</value>
    </enumerator>
    <enumerator>
      <name>PORE</name>
      <value>31</value>
    </enumerator>
    <enumerator>
      <name>PCIESWITCH</name>
      <value>32</value>
    </enumerator>
    <enumerator>
      <name>CAPP</name>
      <value>33</value>
    </enumerator>
    <enumerator>
      <name>FSI</name>
      <value>34</value>
    </enumerator>
    <enumerator>
      <name>EQ</name>
      <value>35</value>
    </enumerator>
    <enumerator>
      <name>MCA</name>
      <value>36</value>
    </enumerator>
    <enumerator>
      <name>MCBIST</name>
      <value>37</value>
    </enumerator>
    <enumerator>
      <name>MI</name>
      <value>38</value>
    </enumerator>
    <enumerator>
      <name>DMI</name>
      <value>39</value>
    </enumerator>
    <enumerator>
      <name>OBUS</name>
      <value>40</value>
    </enumerator>
    <enumerator>
      <name>SBE</name>
      <value>42</value>
    </enumerator>
    <enumerator>
      <name>PPE</name>
      <value>43</value>
    </enumerator>
    <enumerator>
      <name>PERV</name>
      <value>44</value>
    </enumerator>
    <enumerator>
      <name>PEC</name>
      <value>45</value>
    </enumerator>
    <enumerator>
      <name>PHB</name>
      <value>46</value>
    </enumerator>
    <enumerator>
      <name>SYSREFCLKENDPT</name>
      <value>47</value>
    </enumerator>
    <enumerator>
      <name>MFREFCLKENDPT</name>
      <value>48</value>
    </enumerator>
    <enumerator>
      <name>TPM</name>
      <value>49</value>
    </enumerator>
    <enumerator>
      <name>SP</name>
      <value>50</value>
    </enumerator>
    <enumerator>
      <name>UART</name>
      <value>51</value>
    </enumerator>
    <enumerator>
      <name>PS</name>
      <value>52</value>
    </enumerator>
    <enumerator>
      <name>FAN</name>
      <value>53</value>
    </enumerator>
    <enumerator>
      <name>VRM</name>
      <value>54</value>
    </enumerator>
    <enumerator>
      <name>USB</name>
      <value>55</value>
    </enumerator>
    <enumerator>
      <name>ETH</name>
      <value>56</value>
    </enumerator>
    <enumerator>
      <name>PANEL</name>
      <value>57</value>
    </enumerator>
    <enumerator>
      <name>BMC</name>
      <value>58</value>
    </enumerator>
    <enumerator>
      <name>FLASH</name>
      <value>59</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM</name>
      <value>60</value>
    </enumerator>
    <enumerator>
      <name>TMP</name>
      <value>61</value>
    </enumerator>
    <enumerator>
      <name>GPIO_EXPANDER</name>
      <value>62</value>
    </enumerator>
    <enumerator>
      <name>POWER_SEQUENCER</name>
      <value>63</value>
    </enumerator>
    <enumerator>
      <name>RTC</name>
      <value>64</value>
    </enumerator>
    <enumerator>
      <name>FANCTLR</name>
      <value>65</value>
    </enumerator>
    <enumerator>
      <name>OBUS_BRICK</name>
      <value>66</value>
    </enumerator>
    <enumerator>
      <name>NPU</name>
      <value>67</value>
    </enumerator>
    <enumerator>
      <name>MC</name>
      <value>68</value>
    </enumerator>
    <enumerator>
      <name>TEST_FAIL</name>
      <value>69</value>
    </enumerator>
    <enumerator>
      <name>MFREFCLK</name>
      <value>70</value>
    </enumerator>
    <enumerator>
      <name>SMPGROUP</name>
      <value>71</value>
    </enumerator>
    <enumerator>
      <name>OMI</name>
      <value>72</value>
    </enumerator>
    <enumerator>
      <name>MCC</name>
      <value>73</value>
    </enumerator>
    <enumerator>
      <name>OMIC</name>
      <value>74</value>
    </enumerator>
    <enumerator>
      <name>OCMB_CHIP</name>
      <value>75</value>
    </enumerator>
    <enumerator>
      <name>MEM_PORT</name>
      <value>76</value>
    </enumerator>
    <enumerator>
      <name>I2C_MUX</name>
      <value>77</value>
    </enumerator>
    <enumerator>
      <name>LAST_IN_RANGE</name>
      <value>78</value>
    </enumerator>
    <id>TYPE</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration for Voltage Drop Monitor enable</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <id>VDM_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration to select WOF Power Limit</description>
    <enumerator>
      <name>NOMINAL</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TURBO</name>
      <value>1</value>
    </enumerator>
    <id>WOF_POWER_LIMIT</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration defining the offsets into the IPMI_SENSORS array.</description>
    <enumerator>
      <name>NAME_OFFSET</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>NUMBER_OFFSET</name>
      <value>0x01</value>
    </enumerator>
    <id>IPMI_SENSOR_ARRAY</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration indicating the IPMI sensor name, which will be used by hostboot when determining the sensor number to return. The sensor name consists of one byte of sensor type plus one byte of sub-type, to differentiate similar sensors under the same target. Our implementaion uses the IPMI defined entity ID as the sub-type.</description>
    <enumerator>
      <name>PROC_TEMP</name>
      <value>0x0103</value>
    </enumerator>
    <enumerator>
      <name>DIMM_TEMP</name>
      <value>0x0120</value>
    </enumerator>
    <enumerator>
      <name>CORE_TEMP</name>
      <value>0x01D0</value>
    </enumerator>
    <enumerator>
      <name>STATE</name>
      <value>0x0500</value>
    </enumerator>
    <enumerator>
      <name>MEMBUF_TEMP</name>
      <value>0x01D1</value>
    </enumerator>
    <enumerator>
      <name>GPU_TEMP</name>
      <value>0x01D8</value>
    </enumerator>
    <enumerator>
      <name>GPU_MEM_TEMP</name>
      <value>0x01D9</value>
    </enumerator>
    <enumerator>
      <name>VRM_VDD_TEMP</name>
      <value>0x01DA</value>
    </enumerator>
    <enumerator>
      <name>GPU_STATE</name>
      <value>0x17D8</value>
    </enumerator>
    <enumerator>
      <name>PROC_STATE</name>
      <value>0x0703</value>
    </enumerator>
    <enumerator>
      <name>CORE_STATE</name>
      <value>0x07D0</value>
    </enumerator>
    <enumerator>
      <name>HOST_AUTO_REBOOT_CONTROL</name>
      <value>0x0921</value>
    </enumerator>
    <enumerator>
      <name>DIMM_STATE</name>
      <value>0x0C20</value>
    </enumerator>
    <enumerator>
      <name>HB_VOLATILE</name>
      <value>0x0C21</value>
    </enumerator>
    <enumerator>
      <name>MEMBUF_STATE</name>
      <value>0x0CD1</value>
    </enumerator>
    <enumerator>
      <name>FW_BOOT_PROGRESS</name>
      <value>0x0F22</value>
    </enumerator>
    <enumerator>
      <name>SYSTEM_EVENT</name>
      <value>0x1201</value>
    </enumerator>
    <enumerator>
      <name>OS_BOOT</name>
      <value>0x1F23</value>
    </enumerator>
    <enumerator>
      <name>HOST_STATUS</name>
      <value>0x2223</value>
    </enumerator>
    <enumerator>
      <name>OCC_ACTIVE</name>
      <value>0x07D2</value>
    </enumerator>
    <enumerator>
      <name>CORE_FREQ</name>
      <value>0xC1D0</value>
    </enumerator>
    <enumerator>
      <name>APSS_CHANNEL</name>
      <value>0xC2D7</value>
    </enumerator>
    <enumerator>
      <name>PCI_ACTIVE</name>
      <value>0xC423</value>
    </enumerator>
    <enumerator>
      <name>REBOOT_COUNT</name>
      <value>0xC322</value>
    </enumerator>
    <enumerator>
      <name>FAULT</name>
      <value>0xC700</value>
    </enumerator>
    <enumerator>
      <name>BACKPLANE_FAULT</name>
      <value>0xC707</value>
    </enumerator>
    <enumerator>
      <name>REF_CLOCK_FAULT</name>
      <value>0xC7D4</value>
    </enumerator>
    <enumerator>
      <name>PCI_CLOCK_FAULT</name>
      <value>0xC7D5</value>
    </enumerator>
    <enumerator>
      <name>TOD_CLOCK_FAULT</name>
      <value>0xC7D6</value>
    </enumerator>
    <enumerator>
      <name>APSS_FAULT</name>
      <value>0xC7D7</value>
    </enumerator>
    <enumerator>
      <name>VRM_VDD_FAULT</name>
      <value>0xC707</value>
    </enumerator>
    <enumerator>
      <name>DERATING_FACTOR</name>
      <value>0xC815</value>
    </enumerator>
    <enumerator>
      <name>REDUNDANT_PS_POLICY</name>
      <value>0xCA22</value>
    </enumerator>
    <enumerator>
      <name>TURBO_ALLOWED</name>
      <value>0xCB03</value>
    </enumerator>
    <enumerator>
      <name>TPM_REQUIRED</name>
      <value>0xCC03</value>
    </enumerator>
    <enumerator>
      <name>PCI_BIFURCATED</name>
      <value>0xCD03</value>
    </enumerator>
    <id>SENSOR_NAME</id>
  </enumerationType>
  <enumerationType>
    <default>DD10</default>
    <description>Enumeration indicating the chip version</description>
    <enumerator>
      <name>DD10</name>
      <value>0x10</value>
    </enumerator>
    <enumerator>
      <name>DD11</name>
      <value>0x11</value>
    </enumerator>
    <enumerator>
      <name>DD20</name>
      <value>0x20</value>
    </enumerator>
    <enumerator>
      <name>DD21</name>
      <value>0x21</value>
    </enumerator>
    <id>CHIP_VER</id>
  </enumerationType>
  <enumerationType>
    <default>BMC_HW_VER</default>
    <description>Enumeration indicating the chip HW version</description>
    <enumerator>
      <name>FSP_HW_VER</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>BMC_HW_VER</name>
      <value>0x3</value>
    </enumerator>
    <id>HW_VER</id>
  </enumerationType>
  <enumerationType>
    <default>PRIMARY</default>
    <description>Enumeration indicating the master's FSI type</description>
    <enumerator>
      <name>PRIMARY</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>BACKUP</name>
      <value>0</value>
    </enumerator>
    <id>ROLE</id>
  </enumerationType>
  <enumerationType>
    <default>BMC_SW_VER</default>
    <description>Enumeration indicating the SW version</description>
    <enumerator>
      <name>FSP_SW_VER</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>BMC_SW_VER</name>
      <value>0x2</value>
    </enumerator>
    <id>SW_VER</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration indicating the IPMI entity ID, these values are defined in the IPMI specification. These values will be used in place of target type when events are sent to the BMC.</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>OTHER</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>PROCESSOR</name>
      <value>0x03</value>
    </enumerator>
    <enumerator>
      <name>SYSTEM_BOARD</name>
      <value>0x07</value>
    </enumerator>
    <enumerator>
      <name>POWER_MGMT</name>
      <value>0x15</value>
    </enumerator>
    <enumerator>
      <name>CHASSIS</name>
      <value>0x17</value>
    </enumerator>
    <enumerator>
      <name>MEMORY_DEVICE</name>
      <value>0x20</value>
    </enumerator>
    <enumerator>
      <name>SYS_MGMT_SOFTWARE</name>
      <value>0x21</value>
    </enumerator>
    <enumerator>
      <name>BIOS</name>
      <value>0x22</value>
    </enumerator>
    <enumerator>
      <name>OS</name>
      <value>0x23</value>
    </enumerator>
    <enumerator>
      <name>CORE</name>
      <value>0xD0</value>
    </enumerator>
    <enumerator>
      <name>MEMBUF</name>
      <value>0xD1</value>
    </enumerator>
    <enumerator>
      <name>OCC</name>
      <value>0xD2</value>
    </enumerator>
    <enumerator>
      <name>REF_CLOCK</name>
      <value>0xD4</value>
    </enumerator>
    <enumerator>
      <name>PCI_CLOCK</name>
      <value>0xD5</value>
    </enumerator>
    <enumerator>
      <name>TOD_CLOCK</name>
      <value>0xD6</value>
    </enumerator>
    <enumerator>
      <name>APSS</name>
      <value>0xD7</value>
    </enumerator>
    <enumerator>
      <name>GPU_CORE</name>
      <value>0xD8</value>
    </enumerator>
    <enumerator>
      <name>GPU_MEMORY</name>
      <value>0xD9</value>
    </enumerator>
    <id>ENTITY_ID</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration defining the offsets into the GPU_SENSORS array.</description>
    <enumerator>
      <name>FUNC_OFFSET</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>FUNC_ID_OFFSET</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>TEMP_OFFSET</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>TEMP_ID_OFFSET</name>
      <value>0x03</value>
    </enumerator>
    <enumerator>
      <name>MEM_TEMP_OFFSET</name>
      <value>0x04</value>
    </enumerator>
    <enumerator>
      <name>MEM_TEMP_ID_OFFSET</name>
      <value>0x05</value>
    </enumerator>
    <enumerator>
      <name>OBUS_CFG_OFFSET</name>
      <value>0x06</value>
    </enumerator>
    <id>GPU_SENSOR_ARRAY</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration indicating the IPMI sensor type, these values are defined in the IPMI specification. These values will be used when sending sensor reading events to the BMC.</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TEMPERATURE</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>PROCESSOR</name>
      <value>0x07</value>
    </enumerator>
    <enumerator>
      <name>POWER_UNIT</name>
      <value>0x09</value>
    </enumerator>
    <enumerator>
      <name>MEMORY</name>
      <value>0x0c</value>
    </enumerator>
    <enumerator>
      <name>SYS_FW_PROGRESS</name>
      <value>0x0F</value>
    </enumerator>
    <enumerator>
      <name>SYS_EVENT</name>
      <value>0x12</value>
    </enumerator>
    <enumerator>
      <name>ADDIN_CARD</name>
      <value>0x17</value>
    </enumerator>
    <enumerator>
      <name>OS_BOOT</name>
      <value>0x1F</value>
    </enumerator>
    <enumerator>
      <name>APCI_POWER_STATE</name>
      <value>0x22</value>
    </enumerator>
    <enumerator>
      <name>FREQ</name>
      <value>0xC1</value>
    </enumerator>
    <enumerator>
      <name>POWER</name>
      <value>0xC2</value>
    </enumerator>
    <enumerator>
      <name>BOOT_COUNT</name>
      <value>0xC3</value>
    </enumerator>
    <enumerator>
      <name>PCI_LINK_PRES</name>
      <value>0xC4</value>
    </enumerator>
    <enumerator>
      <name>PWR_LIMIT_ACTIVE</name>
      <value>0xC4</value>
    </enumerator>
    <enumerator>
      <name>FAULT</name>
      <value>0xC7</value>
    </enumerator>
    <id>SENSOR_TYPE</id>
  </enumerationType>
</attributes>
