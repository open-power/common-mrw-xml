<attributes>
  <attribute>
    <description>The frequency of the processor refclock in kHz. Provided by the Machine Readable Workbook. This can be overridden to adjust the refclock frequency.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_PROC_REFCLOCK_KHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_PROC_REFCLOCK_KHZ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>The frequency of the memory refclock in MHz. Provided by the Machine Readable Workbook. This is read by the set_ref_clock HWP to find out the desired frequency. This can be overridden to adjust the refclock frequency.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_MEM_REFCLOCK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_MEM_REFCLOCK</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Maximum frequency (in MHz) that this system can run the DIMMs at. There are 5 possible values determined by the dimm configuration. For configurations which have mixed rank configurations, the lowest frequency based on ranks of either DIMM is chosen. For example if there was a 1R and a 2R DIMM installed, and 1R dual drop was a lower max freq than 2R dual drop, then the 1R max freq would be the max allowed. [0]=One rank, single drop [1]=Two rank, single drop [2]=Four rank, single drop [3]=One rank, dual drop [4]=Two rank, dual drop A value of zero would indicate an unsupported configuration. Note: Do not use this attribute to limit configurations, it is not checked during plug rules. If you have an unsupported configuration, use the value 0 as the maximum freq.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MAX_ALLOWED_DIMM_FREQ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MAX_ALLOWED_DIMM_FREQ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>5</array>
      <uint32_t>
        <default>2400,2400,2400,2400,2400</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Specify the system policy to enforce synchronous mode between memory and nest. This drives the value of ATTR_MEM_IN_SYNCH_MODE. UNDETERMINED : Run synchronously if the dimm and nest freq matches ALWAYS : Require matching frequencies and deconfigure memory that does not match the nest NEVER : Do not run synchronously, even if the frequencies match</description>
    <hwpfToHbAttrMap>
      <id>ATTR_REQUIRED_SYNCH_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>REQUIRED_SYNCH_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Bad DQ bitmap from a controller point of view. The data is a 10 byte bitmap for each of 4 possible ranks. The bad DQ data is stored in NVRAM, and it is stored in a special format translated to a DIMM Connector point of view. All of these details are hidden from the user of this attribute.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_BAD_DQ_BITMAP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>BAD_DQ_BITMAP</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4,10</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Machine Readable Workbook safe mode throttle value for numerator cfg_nm_n_per_port Set to below optimum value/ rate. On a per port (MCA) basis Also used for emergency mode throttle MBA_FARB4Q_EMERGENCY_N Used to thermally protect the system in all supported environmental conditions when OCC is not functional Consumer: thermal_init, initfile</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>32</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook Thermal Memory Power Limit Used to calculate throttles to be at or under the power limit Per DIMM basis KEY (0-19): In order DIMM_SIZE = bits 0-3, DIMM_GEN = 4-5, DIMM_TYPE = 6-7, DIMM_WIDTH = 8-9, DIMM_DENSITY = 10-12, DIMM_STACK_TYPE = 13-14, DRAM_MFGID = 15-16, DIMMS_PER_PORT = 17-18, Bits 19-32: Not used VALUE (bits 32-63) in cW: VMEM+VPP thermal power limit per DIMM = 32-63 Consumers: eff_config_thermal and bulk_pwr_throttles</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_THERMAL_MEMORY_POWER_LIMIT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_THERMAL_MEMORY_POWER_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>10</array>
      <uint64_t>
        <default>0xffffe000000006a4,0,0,0,0,0,0,0,0,0</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook Power Curve Intercept for DIMM Used to get the VDDR and VDDR+VPP power curve for each DIMM Decoded and used to set ATTR_MSS_TOTAL_PWR_INTERCEPT Key Value pair KEY (0-19): In order DIMM_SIZE = bits 0-3, DIMM_GEN = 4-5, DIMM_TYPE = 6-7, DIMM_WIDTH = 8-9, DIMM_DENSITY = 10-12, DIMM_STACK_TYPE = 13-14, DRAM_MFGID = 15-16, DIMMS_PER_PORT = 17-18, Bits 19-32: Not used VALUE (bits 32-63) in cW: VMEM power curve = 32-47 VMEM+VPP power curve = 48-63 Consumers: eff_config_thermal</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_PWR_INTERCEPT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_PWR_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>100</array>
      <uint64_t>
        <default>0xffffe00002CC03AE,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook Power Curve Slope for DIMM Used to get the VDDR and VDDR+VPP power curve for each DIMM Decoded and used to set ATTR_MSS_TOTAL_PWR_INTERCEPT Key Value pair KEY (0-19): In order DIMM_SIZE = bits 0-3, DIMM_GEN = 4-5, DIMM_TYPE = 6-7, DIMM_WIDTH = 8-9, DIMM_DENSITY = 10-12, DIMM_STACK_TYPE = 13-14, DRAM_MFGID = 15-16, DIMMS_PER_PORT = 17-18, Bits 19-32: Not used VALUE (bits 32-63) in cW: VMEM power curve = 32-47 VMEM+VPP power curve = 48-63 Consumers: eff_config_thermal</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_PWR_SLOPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_PWR_SLOPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>100</array>
      <uint64_t>
        <default>0xffffe00003FD0546,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0, 0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook Refresh Rate Desired refresh interval used in refresh register 0, MBAREF0Q_CFG_REFRESH_INTERVAL 7.8 us (SINGLE) 3.9 us (DOUBLE) 7.02 us (SINGLE_10_PERCENT_FASTER) 3.51 us (DOUBLE_10_PERCENT_FASTER)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_REFRESH_RATE_REQUEST</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_REFRESH_RATE_REQUEST</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook DIMM power curve percent uplift for this system at max utilization. Value should be 0 for ISDIMMs</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook DIMM power curve percent uplift for this system at idle utilization. Value should be 0 for ISDIMMs</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook for the number of M DRAM clocks. One approach to curbing DRAM power usage is by throttling traffic through a programmable N commands over M window.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_MEM_M_DRAM_CLOCKS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_MEM_M_DRAM_CLOCKS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x00000200</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook value for maximum dram data bus utilization in centi percent (c%). Used to determine memory throttle values. Max databus utilization on a per port basis Default to 90%</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_MAX_DRAM_DATABUS_UTIL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_MAX_DRAM_DATABUS_UTIL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x00002328</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Option to control MCS prefetch retry threshold, for performance optimization. This attribute controls the number of retries in the prefetch engine. Retry threshold available ranges from 16 to 30. Note: Values outside those ranges will default to 30. In MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_MCS_PREFETCH_RETRY_THRESHOLD</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_MCS_PREFETCH_RETRY_THRESHOLD</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Memory power control settings programmed during IPL Used by OCC when exiting idle power-save mode</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_POWER_CONTROL_REQUESTED</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_POWER_CONTROL_REQUESTED</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>OFF</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Memory power control settings for IDLE powersave mode Used by OCC when entering idle power-save mode</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_IDLE_POWER_CONTROL_REQUESTED</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_IDLE_POWER_CONTROL_REQUESTED</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>OFF</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook enablement of the HWP code to adjust the VMEM regulator power limit based on number of installed DIMMs.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook VMEM regulator power limit per CDIMM assuming a full configuration. Units in cW Used for Cumulus Consumed in mss_eff_config_thermal</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR3</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR3</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook VMEM regulator power limit per DIMM assuming a full configuration. Units in cW Consumed in mss_eff_config_thermal</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR4</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR4</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x000006A4</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook value for the maximum possible number of dimms that can be installed under any of the VMEM regulators. Consumed in eff_config_thermal to calculate mem_watt_target</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Used for to determine whether to apply an offset to AVDD. Supplied by MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_AVDD_OFFSET_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_AVDD_OFFSET_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Used for to determine whether to apply an offset to VDD. Supplied by MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_VDD_OFFSET_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_VDD_OFFSET_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Used for to determine whether to apply an offset to VCS. Supplied by MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_VCS_OFFSET_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_VCS_OFFSET_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Used for to determine whether to apply an offset to VCS. Supplied by MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_VPP_OFFSET_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_VPP_OFFSET_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Used for to determine whether to apply an offset to VDDR. Supplied by MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_VDDR_OFFSET_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_VDDR_OFFSET_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Fine refresh mode. Sets DDR4 MRS3. ZZ uses normal mode. From JEDEC DDR4 Spec 1716.78C from 07-2016 Page 47 Table 4.9.1</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_FINE_REFRESH_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_FINE_REFRESH_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>NORMAL</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Temperature refresh range. Sets DDR4 MRS4. Should be defaulted to extended range. NORMAL for running at 85 degrees C or less, EXTENDED for 95 or less degrees C Used for calculating periodic refresh intervals JEDEC DDR4 spec 1716.78C from 07-2016 page 46 4.8.1</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_TEMP_REFRESH_RANGE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_TEMP_REFRESH_RANGE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>For resetting the phy delay values at the beginning of calling mss_draminit_training. YES means the vaules will be reset.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_RESET_DELAY_BEFORE_CAL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_RESET_DELAY_BEFORE_CAL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>YES</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of on or off. Determines if prefetching enabled or not.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_PREFETCH_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_PREFETCH_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of on or off. Determines if the cleaner of the L4 cache (write modified entries to memory on idle cycles) enabled or not. See chapter 7 of the Centaur Workbook.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_CLEANER_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_CLEANER_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>OFF</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Describes the settings for periodic calibration for all ports: Reading left to right. (DEFAULT: 0xD90C -&gt; Byte 0(11011001), Byte 1(00001100)) For each bit: OFF = 0, ON = 1. Setting to 0 indicates to disable periodic memcal. Byte 0: 0: ZCAL 1: SYSCK_ALIGN 2: RDCENTERING 3: RDLCK_ALIGN 4: DQS_ALIGN 5: RDCLK_UPDATE 6: PER_DUTYCYCLE 7: PERCAL_PWR_DIS Byte 1: 0: PERCAL_REPEAT 1: PERCAL_REPEAT 2: PERCAL_REPEAT 3: SINGLE_BIT_MPR 4: MBA_CFG_0 5: MBA_CFG_1 6: SPARE 7: SPARE</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_PERIODIC_MEMCAL_MODE_OPTIONS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_PERIODIC_MEMCAL_MODE_OPTIONS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0xD90C</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Describes the settings for periodic ZQ calibration for all ports: Reading left to right. For each bit: OFF = 0, ON = 1. Setting to 0 indicates to disable periodic zqcal. Byte 0: 0: ZQCAL All others reserved for future use</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_PERIODIC_ZQCAL_MODE_OPTIONS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_PERIODIC_ZQCAL_MODE_OPTIONS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0x8000</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Allows user to manually turn on and off 2N Mode. AUTO indicates to use Signal Integrity generated setting (from VPD).</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_DRAM_2N_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_DRAM_2N_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>AUTO</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>List of memory frequencies supported by the current system.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_SUPPORTED_FREQ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_SUPPORTED_FREQ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint32_t>
        <default>1866,2133,2400,2667</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Each MCA value is a 64-bit vector, where each byte represents an unsupported rank configuration. Each nibble in the byte represents the total count of ranks (master and slave) on each DIMM. The left-most nibble represents slot 0 and the right represents 1.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_UNSUPPORTED_RANK_CONFIG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_UNSUPPORTED_RANK_CONFIG</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint64_t>
        <default>0</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Enables DRAM Write CRC</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_DRAM_WRITE_CRC</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_DRAM_WRITE_CRC</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Used in MR4 A3 Temperature refresh mode Should be defaulted to disable</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_TEMP_REFRESH_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_MRW_TEMP_REFRESH_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>The frequency of a processor's nest mesh clock, in MHz. This is the same for all chips in the system. Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_PB_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_PB_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>The frequency of a processor's Obus mesh clocks, in MHz. Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_O_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_O_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint32_t>
        <default>1611</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>The frequency of a processor's Abus, in MHz. This is the same for all chips in the system. Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_A_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_A_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x1900</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>The frequency of a processor's Xbus mesh clocks, in MHz. This is the same for all chips in the system.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_X_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_X_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>2000</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Frequency (in MHz) to move to if the Power Management function fails. This is the same for all cores in the system. Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PM_SAFE_FREQUENCY_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PM_SAFE_FREQUENCY_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Voltage (in mV) to move to if the Power Management function fails. Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PM_SAFE_VOLTAGE_MV</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PM_SAFE_VOLTAGE_MV</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>The frequency of a processor's PCI-e bus in MHz. This is the same for all PCI-e busses in the system. Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_PCIE_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_PCIE_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>MRW control to permit Normal (100 MHz) or Slow (94 MHz) operation of PCIE reference clock. On Nimbus DD1 HW, Slow operation is required to achieve Gen4 operation. Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_DD1_SLOW_PCI_REF_CLOCK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DD1_SLOW_PCI_REF_CLOCK</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x01</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Processor SMP A bus width. Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_A_BUS_WIDTH</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_A_BUS_WIDTH</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>4_BYTE</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Processor SMP X bus width. Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_X_BUS_WIDTH</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_X_BUS_WIDTH</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>4_BYTE</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Processor SMP Fabric broadcast scope configuration. CHIP_IS_NODE = MODE1 = default CHIP_IS_GROUP = MODE2 Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_PUMP_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_PUMP_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Processor SMP topology configuration. 0 = default = 1 or 2 hop topology (PHYP image spans system) Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_CCSM_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_CCSM_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Per-link optics configuration 0 = default = SMP 1 = CAPI 2.0 2 = NV 2.0 3 = OPENCAPI Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_OPTICS_CONFIG_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>OPTICS_CONFIG_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>NV</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Processor SMP optics mode. 0 = default = Optics_is_X_bus 1 = Optics_is_A_bus Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_SMP_OPTICS_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_SMP_OPTICS_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>OPTICS_IS_X_BUS</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Processor CAPI attachement protocol mode. 0 = default = no: SMPA CAPI attachement 1 = yes: SMPA CAPI attachement Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_CAPI_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_CAPI_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>OFF</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Logical fabric system ID associated with this chip. Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_SYSTEM_ID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FABRIC_SYSTEM_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Processor epsilon table type. Used to calculate the processor nest epsilon register values. Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_EPS_TABLE_TYPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_EPS_TABLE_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>XSCOM BAR base address offset creator: platform consumer: p9_sbe_scominit firmware notes: Defines 16GB range (size implied) mapped for XSCOM usage Attribute holds offset (relative to chip MMIO origin) to program into chip address range field of BAR -- RA bits 22:29 (excludes system/memory select/group/chip fields)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_XSCOM_BAR_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_XSCOM_BAR_BASE_ADDR_OFFSET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>LPC BAR base address offset creator: platform consumer: p9_sbe_scominit firmware notes: Defines 4GB range (size implied) mapped for LPC usage Attribute holds offset (relative to chip MMIO origin) to program into chip address range field of BAR -- RA bits 22:31 (excludes system/memory select/group/chip fields)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_LPC_BAR_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_LPC_BAR_BASE_ADDR_OFFSET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Define placement policy/scheme for non-mirrored/mirrored memory layout NORMAL = non-mirrored start: 0, mirrored start: 1024TB FLIPPED = mirrored start: 0, non-mirrored start: 512TB Set by platform. Used by mss_eff_grouping.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MEM_MIRROR_PLACEMENT_POLICY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MEM_MIRROR_PLACEMENT_POLICY</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Used in the setting of groups. It is a bit vector. If the value BITWISE_AND 0x01 = 0x01 then groups of 1 are enabled, if the value BITWISE_AND 0x02 = 0x02, then groups of 2 are possible, if the value BITWISE_AND 0x04 = 0x04, then group of 3 are possible, if the value BITWISE_AND 0x08 = 0x08, then groups of 4 are possible, if the value BITWISE_AND 0x20 = 0x20, then groups of 6 are possible, if the value BITWISE_AND 0x80 = 0x80, then groups of 8 are possible. If no groups can formed according to this input, then an error will be thrown. Provided by the MRW</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_INTERLEAVE_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_INTERLEAVE_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0xAF</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Determines the stride covered by each granule in an interleaving group. The default stride -- 128B -- is the only value intended for production FW use. All other combinations are for experimental performance evaluation. Regardless of this attribute value, groups of size 1, 3, and 6 will be forced to 128B stride based on the logic capabilities.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_INTERLEAVE_GRANULARITY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_INTERLEAVE_GRANULARITY</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>TRUE : HW mirroring is enabled. FALSE : HW mirroring is disabled. Provided by the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MRW_HW_MIRRORING_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MRW_HW_MIRRORING_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Source: MRW: Downstream MSB Swap and Upstream MSB Swap Usage: TX_MSBSWAP initfile setting for DMI and X buses This attribute represents whether or not a single clock group bus such as DMI and X bus was wired by the board designer using a feature called MSB Swap where lane 0 of the TX chip wires to lane n-1 on the RX chip where 'n' is the width of the bus. A basic description of this capability is that the board designer can save layers on the board wiring by crossing the wiring between the two chips in a prescribed manner. In a non-MSB Swapped bus Lane 0 on the TX chip wires to lane 0 on the RX chip, lane 1 to lane 1 and so on. If a bus is MSB Swapped then lane 0 of the TX chip wires to lane 'n-1' of the RX chip, lane 1 to lane 'n-2', etc. Random or arbitrary wiring of TX to RX lanes on different chips is NOT ALLOWED. The Master Chip of two connected chips is defined as the chip with the smaller value of (100*Node + Pos). The Slave Chip of two connected chips is defined as the chip with the larger value of (100*Node + Pos). The Downstream direction is defined as the direction from the Master chip to the Slave chip. The Upstream direction is defined as the direction from the Slave chip to the Master chip. The Downstream TX_MSBSWAP from the MRW is a uint8 value. 0x01 means the Downstream bus is wired msb to lsb etc. and 0x00 means the bus is wired normally, msb to msb, lsb to lsb (lane0 to lane0). The Upstream TX_MSBSWAP from the MRW is a uint8 value. 0x01 means the Upstream bus is wired msb to lsb etc. and 0x00 means the bus is wired normally, msb to msb, lsb to lsb (lane0 to lane0). It is up to the platform code to set up each ATTR_EI_BUS_TX_MSBSWAP value for the correct target endpoints.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_EI_BUS_TX_MSBSWAP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EI_BUS_TX_MSBSWAP</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Indicate if debug data should be taken pre / post linktraining.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_O_DEBUG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_O_DEBUG</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Indicate if manufcaturing tests should be taken pre / post linktraining.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_O_MFG_CHK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_O_MFG_CHK</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Minimum eye width to allow passing through manufacturing.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_O_MFG_MIN_EYE_WIDTH</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_O_MFG_MIN_EYE_WIDTH</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Value to select amount of margin to be applied.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_OBUS_TX_MARGIN_RATIO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_OBUS_TX_MARGIN_RATIO</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Value to select amount of tx ffe precusor to apply.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_OBUS_TX_FFE_PRECURSOR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_OBUS_TX_FFE_PRECURSOR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Value to select amount of tx ffe postcusor to apply.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_OBUS_TX_FFE_POSTCURSOR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_OBUS_TX_FFE_POSTCURSOR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Indicate if debug data should be taken pre / post linktraining.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_X_DEBUG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_X_DEBUG</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Indicate if manufacturing tests should be taken pre / post linktraining.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_X_MFG_CHK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_X_MFG_CHK</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Minimum eye width to allow passing through manufacturing.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_X_MFG_MIN_EYE_WIDTH</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_X_MFG_MIN_EYE_WIDTH</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Value to select amount of margin to be applied.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_XBUS_TX_MARGIN_RATIO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_XBUS_TX_MARGIN_RATIO</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Value to select amount of tx ffe precusor to apply.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_XBUS_TX_FFE_PRECURSOR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_XBUS_TX_FFE_PRECURSOR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>6</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>PCIE MMIO BAR enable creator: platform consumer: p9_pcie_config firmware notes: Array index: BAR number (0:2) index 0~1 for MMIO BAR0/1 index 2 for PHB register space</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_BAR_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_BAR_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>3</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>PCIE MMIO0 BAR base address offset creator: platform consumer: p9_setup_bars firmware notes: Attribute holds offset (relative to chip MMIO origin) to program into chip address range field of BAR -- RA bits 8:47 (excludes system/memory select/group/chip fields) Array index: PHB number (0:5)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_MMIO_BAR0_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_MMIO_BAR0_BASE_ADDR_OFFSET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>6</array>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>PCIE MMIO1 BAR base address offset creator: platform consumer: p9_setup_bars firmware notes: Attribute holds offset (relative to chip MMIO origin) to program into chip address range field of BAR -- RA bits 8:47 (excludes system/memory select/group/chip fields) Array index: PHB number (0:5)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_MMIO_BAR1_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_MMIO_BAR1_BASE_ADDR_OFFSET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>6</array>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>PCIE PHB register space BAR base address offset creator: platform consumer: p9_setup_bars firmware notes: Attribute holds offset (relative to chip MMIO origin) to program into chip address range field of BAR -- RA bits 8:49 (excludes system/memory select/group/chip fields) Array index: PHB number (0:5)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_REGISTER_BAR_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_REGISTER_BAR_BASE_ADDR_OFFSET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>6</array>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>PCIE MMIO BAR size values creator: platform consumer: p9_pcie_config firmware notes: Array index: BAR number (0:2) NOTE: supported MMIO BAR0/1 sizes are from 64KB-32PB NOTE: only supported PHB register size is 16KB</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_BAR_SIZE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_BAR_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>3</array>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>PCS rx cdr gains creator: platform consumer: p9_pcie_scominit firmware notes: This is a MRW seting. The value of rx cdr gains for PCS. Array index: Configuration number index 0~3 for CONFIG0~3</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PCS_RX_CDR_GAIN</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_PCS_RX_CDR_GAIN</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>PCS rx vga peak init value creator: platform consumer: p9_pcie_scominit firmware notes: This is a MRW setting. The value of rx vga peak init for PCS. Array index: Configuration number index 0~3 for CONFIG0~3 lane 0~15 for each PCIE Lane</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PCS_RX_PK_INIT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_PCS_RX_PK_INIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4,16</array>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>PCS rx vga gain init value creator: platform consumer: p9_pcie_scominit firmware notes: This is a MRW setting. The value of rx vga gain init for PCS. Array index: Configuration number index 0~3 for CONFIG0~3 lane 0~15 for each PCIE Lane</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PCS_RX_INIT_GAIN</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_PCS_RX_INIT_GAIN</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4,16</array>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>PCS rx sigdet lvl value creator: platform consumer: p9_pcie_scominit firmware notes: This is a MRW setting. The value of rx sigdet lvl for PCS. Array index: Configuration number index 0~3 for CONFIG0~3</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PCS_RX_SIGDET_LVL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_PCS_RX_SIGDET_LVL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint8_t>
        <default>0x0B</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of PCS RX ROT CNTL CDR lookahead creator: platform consumer: p9_pcie_scominit firmware notes: This is a MRW setting. 0 for disable (default) 1 for enable Used for spread spectrum enablement.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PCS_RX_ROT_CDR_LOOKAHEAD</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_PCS_RX_ROT_CDR_LOOKAHEAD</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of PCS RX ROT CNTL CDR ssc creator: platform consumer: p9_pcie_scominit firmware notes: This is a MRW setting. 0 for disable (default) 1 for enable Used for Spread Spectrum enablement.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PCS_RX_ROT_CDR_SSC</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_PCS_RX_ROT_CDR_SSC</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of PCS RX ROT rstfw latch creator: platform consumer: p9_pcie_scominit firmware notes: This is a common setting that can be overwritten by code logic. 0 normal, flywheel is enabled (default) 1 assert reset to the phase rotator flywheel (disable the flywheel)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PCS_RX_ROT_RST_FW</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_PCS_RX_ROT_RST_FW</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of PCS pclck control plla creator: platform consumer: p9_pcie_scominit firmware notes: This is a common setting that can be overwritten by code logic.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PCS_PCLCK_CNTL_PLLA</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_PCS_PCLCK_CNTL_PLLA</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of PCS pclck control pllb creator: platform consumer: p9_pcie_scominit firmware notes: This is a common setting that can be overwritten by code logic.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PCS_PCLCK_CNTL_PLLB</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_PCS_PCLCK_CNTL_PLLB</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of PCS tx dclck rotator override creator: platform consumer: p9_pcie_scominit firmware notes: This is a common setting that can be overwritten by code logic.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PCS_TX_DCLCK_ROT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_PCS_TX_DCLCK_ROT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of PCS tx pcie receiver detect control register 1 creator: platform consumer: p9_pcie_scominit firmware notes: This is a common setting that can be overwritten by code logic.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PCS_TX_PCIE_RECV_DETECT_CNTL_REG1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_PCS_TX_PCIE_RECV_DETECT_CNTL_REG1</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of PCS tx pcie receiver detect control register 2 creator: platform consumer: p9_pcie_scominit firmware notes: This is a common setting that can be overwritten by code logic.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PCS_TX_PCIE_RECV_DETECT_CNTL_REG2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_PCS_TX_PCIE_RECV_DETECT_CNTL_REG2</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of PCS tx power sequence enable creator: platform consumer: p9_pcie_scominit firmware notes: This is a common setting that can be overwritten by code logic.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PCS_TX_POWER_SEQ_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_PCS_TX_POWER_SEQ_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of PCS rx vga control register 1 creator: platform consumer: p9_pcie_scominit firmware notes: This is a common setting that can be overwritten by code logic.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PCS_RX_VGA_CNTL_REG1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_PCS_RX_VGA_CNTL_REG1</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of PCS rx vga control register 2 creator: platform consumer: p9_pcie_scominit firmware notes: This is a common setting that can be overwritten by code logic.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PCS_RX_VGA_CNTL_REG2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_PCS_RX_VGA_CNTL_REG2</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of PCS m1-m4 control creator: platform consumer: p9_pcie_scominit This is a common setting that can be overwritten by code logic. Array index: 0 -&gt; M1 1 -&gt; M2 2 -&gt; M3 3 -&gt; M4</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PCS_M_CNTL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_PCS_M_CNTL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>FSP BAR enable creator: platform consumer: p9_setup_bars firmware notes: none</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FSP_BAR_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FSP_BAR_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>FSP BAR creator: platform consumer: p9_setup_bars firmware notes: Defines range mapped for FSP MMIO Attribute holds offset (relative to chip MMIO origin) to program into chip address range field of BAR -- RA bits 22:43</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FSP_BAR_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FSP_BAR_BASE_ADDR_OFFSET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0x0000030100000000</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>FSP BAR size value creator: platform consumer: p9_setup_bars firmware notes: none</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FSP_BAR_SIZE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FSP_BAR_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0xFFFFFC00FFFFFFFF</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>FSP MMIO mask size value creator: platform consumer: p9_setup_bars firmware notes: AND mask applied to RA 32:35 when transmitting address to FSP NOTE: RA 8:31 are always replaced with zero</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FSP_MMIO_MASK_SIZE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_FSP_MMIO_MASK_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0x0010000000000000</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>NPU PHY0 (stack0) BAR enable creator: platform consumer: p9_setup_bars firmware notes: none</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_NPU_PHY0_BAR_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_NPU_PHY0_BAR_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>NPU PHY0 (stack0) BAR creator: platform consumer: p9_setup_bars firmware notes: Defines 2MB range (size implied) mapped to PHY0 registers Attribute holds offset (relative to chip MMIO origin) to program into chip address range field of BAR -- RA bits 22:42 (excludes system/memory select/group/chip fields)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_NPU_PHY0_BAR_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_NPU_PHY0_BAR_BASE_ADDR_OFFSET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0x0000030201200000</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>NPU PHY1 (stack1) BAR enable creator: platform consumer: p9_setup_bars firmware notes: none</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_NPU_PHY1_BAR_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_NPU_PHY1_BAR_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>NPU PHY1 (stack1) BAR creator: platform consumer: p9_setup_bars firmware notes: Defines 2MB range (size implied) mapped to PHY1 registers Attribute holds offset (relative to chip MMIO origin) to program into chip address range field of BAR -- RA bits 22:42 (excludes system/memory select/group/chip fields)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_NPU_PHY1_BAR_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_NPU_PHY1_BAR_BASE_ADDR_OFFSET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0x0000030201400000</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>NPU MMIO (stack2) BAR creator: platform consumer: p9_setup_bars firmware notes: Defines 16MB range mapped to all NPU registers Attribute holds offset (relative to chip MMIO origin) to program into chip address range field of BAR -- RA bits 22:39 (excludes system/memory select/group/chip fields)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_NPU_MMIO_BAR_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_NPU_MMIO_BAR_BASE_ADDR_OFFSET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0x0000030200000000</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>NPU MMIO (stack2) BAR enable creator: platform consumer: p9_setup_bars firmware notes: none</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_NPU_MMIO_BAR_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_NPU_MMIO_BAR_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>PSI Bridge BAR enable creator: platform consumer: p9_setup_bars firmware notes: none</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PSI_BRIDGE_BAR_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PSI_BRIDGE_BAR_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>PSI Bridge BAR base address offset creator: platform consumer: p9_setup_bars firmware notes: Defines 1MB range (size implied) mapped for PSI host-bridge Attribute holds offset (relative to chip MMIO origin) to program into chip address range field of BAR -- RA bits 22:43 (excludes system/memory select/group/chip fields)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PSI_BRIDGE_BAR_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PSI_BRIDGE_BAR_BASE_ADDR_OFFSET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0x0000030203000000</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>NX RNG BAR enable creator: platform consumer: p9_rng_init_phase2 firmware notes: none</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_NX_RNG_BAR_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_NX_RNG_BAR_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>NX RNG BAR creator: platform consumer: p9_rng_init_phase2 firmware notes: Defines 8KB range (size implied) mapped for NX RNG function Attributes holds offset (relative to chip MMIO origin) to program into chip address range field of BAR -- RA bits 22:51 (excludes system/memory select/group/chip fields)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_NX_RNG_BAR_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_NX_RNG_BAR_BASE_ADDR_OFFSET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0x00000302031D0000</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Enable optional post of interrupt when both NX RNG noise sources have failed creator: platform consumer: p9_rng_init_phase2 firmware notes: none</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_NX_RNG_FAILED_INT_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_NX_RNG_FAILED_INT_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Address used to post interrupt when both NX RNG noise sources have failed creator: platform consumer: p9_rng_init_phase2 firmware notes: 64-bit address representing RA NOTE: register covers RA 8:51</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_NX_RNG_FAILED_INT_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_NX_RNG_FAILED_INT_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>INT CQ PC BAR enable creator: platform consumer: p9_setup_bars firmware notes: none</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_INT_CQ_PC_BAR_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_INT_CQ_PC_BAR_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>INT CQ PC BAR base address offset creator: platform consumer: p9_setup_bars firmware notes: Attribute holds offset (relative to chip MMIO origin) to program into chip address range field of BAR (excludes system/memsel/group/chip fields)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_INT_CQ_PC_BAR_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_INT_CQ_PC_BAR_BASE_ADDR_OFFSET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>INT CQ PC BAR base address offset mask creator: platform consumer: p9_setup_bars firmware notes: Attribute holds offset mask (relative to chip MMIO origin) to program into chip address range field of BAR mask (excludes system/memsel/group/chip fields) Value defines which bits of VC_BAR are used during address compares</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_INT_CQ_PC_BAR_BASE_ADDR_OFFSET_MASK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_INT_CQ_PC_BAR_BASE_ADDR_OFFSET_MASK</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>INT CQ VC BAR enable creator: platform consumer: p9_setup_bars firmware notes: none</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_INT_CQ_VC_BAR_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_INT_CQ_VC_BAR_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>INT CQ VC BAR base address offset creator: platform consumer: p9_setup_bars firmware notes: Attribute holds offset (relative to chip MMIO origin) to program into chip address range field of BAR (excludes system/memsel/group/chip fields)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_INT_CQ_VC_BAR_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_INT_CQ_VC_BAR_BASE_ADDR_OFFSET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>INT CQ VC BAR base address offset mask creator: platform consumer: p9_setup_bars firmware notes: Attribute holds offset mask (relative to chip MMIO origin) to program into chip address range field of BAR mask (excludes system/memsel/group/chip fields) Value defines which bits of VC_BAR are used during address compares</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_INT_CQ_VC_BAR_BASE_ADDR_OFFSET_MASK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_INT_CQ_VC_BAR_BASE_ADDR_OFFSET_MASK</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>INT CQ TM1 BAR enable creator: platform consumer: p9_setup_bars firmware notes: none</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_INT_CQ_TM1_BAR_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_INT_CQ_TM1_BAR_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>INT CQ TM1 BAR base address offset creator: platform consumer: p9_setup_bars firmware notes: Attribute holds offset (relative to chip MMIO origin) to program into chip address range field of BAR (excludes system/memsel/group/chip fields)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_INT_CQ_TM1_BAR_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_INT_CQ_TM1_BAR_BASE_ADDR_OFFSET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>INT CQ TM1 BAR page size creator: platform consumer: p9_setup_bars firmware notes: none</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_INT_CQ_TM1_BAR_PAGE_SIZE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_INT_CQ_TM1_BAR_PAGE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>INT CQ IC BAR enable creator: platform consumer: p9_setup_bars firmware notes: none</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_INT_CQ_IC_BAR_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_INT_CQ_IC_BAR_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>INT CQ IC BAR base address offset creator: platform consumer: p9_setup_bars firmware notes: Attribute holds offset (relative to chip MMIO origin) to program into chip address range field of BAR (excludes system/memsel/group/chip fields)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_INT_CQ_IC_BAR_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_INT_CQ_IC_BAR_BASE_ADDR_OFFSET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>INT CQ IC (Interrupt Controller) BAR page size creator: platform consumer: p9_setup_bars firmware notes: none</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_INT_CQ_IC_BAR_PAGE_SIZE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_INT_CQ_IC_BAR_PAGE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>The minimum number of valid ECs that is required to be used when customizing an SBE image. The customization will fail if it cannot create an image with at least this many ECs.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SBE_IMAGE_MINIMUM_VALID_ECS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SBE_IMAGE_MINIMUM_VALID_ECS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>setup clock mux settings</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCK_PLL_MUX</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CLOCK_PLL_MUX</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Clock Mux#0 settings</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CLOCK_PLL_MUX0</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CLOCK_PLL_MUX0</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Ref clock I2C bus divider consumed by code running out of OTPROM</description>
    <hwpfToHbAttrMap>
      <id>ATTR_I2C_BUS_DIV_REF</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>I2C_BUS_DIV_REF</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0x0003</default>
      </uint16_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Capturing EQ Gard value</description>
    <hwpfToHbAttrMap>
      <id>ATTR_EQ_GARD</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EQ_GARD</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Capturing EC Gard Value</description>
    <hwpfToHbAttrMap>
      <id>ATTR_EC_GARD</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EC_GARD</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Indicates that SBE should go directly to runtime functionality</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SBE_RUNTIME_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SBE_RUNTIME_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Indicates whether we are connected to FSP or not</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IS_SP_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IS_SP_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Indicates whether SBE should collect FFDC</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SBE_FFDC_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SBE_FFDC_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Indicates that the SBE should send back internal FFDC on any chipOp failure response</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SBE_INTERNAL_FFDC_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SBE_INTERNAL_FFDC_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Select Nest I2C and pll setting from one of the supported frequencies</description>
    <hwpfToHbAttrMap>
      <id>ATTR_NEST_PLL_BUCKET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>NEST_PLL_BUCKET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x05</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>EQ boot frequency multiplier The equation for this setting is BOOT_FREQ(MHz)/(REFCLK/DPLL_DIVIDER) where the DPLL DIVIDER is planned for being set to 8. The value needs to be loaded right justified. The value's right most 11 bits (becoming 0:10) is written as bits 17:27 of PPM DPLL freq ctrl register. Bits 0:7 become DPLL.MULT_INTG(0:7) and bits 8:10 are DPLL.MULT_FRAC(0:2). As an example: 3000MHz / (133MHz/8) = 3000 / 16.667 = ~180 =&gt; 0xB4</description>
    <hwpfToHbAttrMap>
      <id>ATTR_BOOT_FREQ_MULT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>BOOT_FREQ_MULT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>150</default>
      </uint16_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>HWP/Init "risk level" enabled. Used by HB to pass to HB driven HWPs</description>
    <hwpfToHbAttrMap>
      <id>ATTR_RISK_LEVEL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>RISK_LEVEL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>BootLoader HWP flag to not place 12K exception vectors. This flag is only applicable when security is disabled.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_DISABLE_HBBL_VECTORS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DISABLE_HBBL_VECTORS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Set with Primary SEEPROM</description>
    <hwpfToHbAttrMap>
      <id>ATTR_BACKUP_SEEPROM_SELECT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>BACKUP_SEEPROM_SELECT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Switch to using a flag to indicate SEEPROM side SBE</description>
    <hwpfToHbAttrMap>
      <id>ATTR_BOOT_FLAGS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>BOOT_FLAGS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>EQ boot frequency</description>
    <hwpfToHbAttrMap>
      <id>ATTR_BOOT_FREQ_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>BOOT_FREQ_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>2400</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>FIXME - NEEDS DESCRIPTION</description>
    <hwpfToHbAttrMap>
      <id>ATTR_BRANCH_PIBMEM_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>BRANCH_PIBMEM_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>I2C Bus speed based on nest freq, ref clock</description>
    <hwpfToHbAttrMap>
      <id>ATTR_I2C_BUS_DIV_NEST</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>I2C_BUS_DIV_NEST</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>FIXME - NEEDS DESCRIPTION</description>
    <hwpfToHbAttrMap>
      <id>ATTR_LEN_OF_SEEPROM_DATA</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>LEN_OF_SEEPROM_DATA</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>FIXME - NEEDS DESCRIPTION</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MB_BIT_RATE_DIVISOR_PLL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MB_BIT_RATE_DIVISOR_PLL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>FIXME - NEEDS DESCRIPTION</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MB_BIT_RATE_DIVISOR_REFCLK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MB_BIT_RATE_DIVISOR_REFCLK</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>133</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Ring image for pb_bndy_dmipll ring creator: platform firmware notes:</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PB_BNDY_DMIPLL_DATA</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PB_BNDY_DMIPLL_DATA</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Ring image for pb_bndy_dmipll ring for DC cal creator: platform firmware notes:</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PB_BNDY_DMIPLL_FOR_DCCAL_DATA</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PB_BNDY_DMIPLL_FOR_DCCAL_DATA</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Ring image for perv_bndy_pll ring containing filter plls and xb_pll,nest_pll creator: platform firmware notes:</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PERV_BNDY_PLL_DATA</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PERV_BNDY_PLL_DATA</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Indicates if SBE on this chip is serving as hosboot drawer master</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_SBE_MASTER_CHIP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_SBE_MASTER_CHIP</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>FIXME - NEEDS DESCRIPTION</description>
    <hwpfToHbAttrMap>
      <id>ATTR_START_PIBMEM_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>START_PIBMEM_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>FIXME - NEEDS DESCRIPTION</description>
    <hwpfToHbAttrMap>
      <id>ATTR_START_SEEPROM_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>START_SEEPROM_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>FIXME - NEEDS DESCRIPTION</description>
    <hwpfToHbAttrMap>
      <id>ATTR_WAIT_N0</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>WAIT_N0</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>FIXME - NEEDS DESCRIPTION</description>
    <hwpfToHbAttrMap>
      <id>ATTR_WAIT_N1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>WAIT_N1</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>FIXME - NEEDS DESCRIPTION</description>
    <hwpfToHbAttrMap>
      <id>ATTR_WAIT_N2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>WAIT_N2</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>FIXME - NEEDS DESCRIPTION</description>
    <hwpfToHbAttrMap>
      <id>ATTR_WAIT_N3</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>WAIT_N3</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Indicate that p9_sbe_select_ex should force selection to ALL good EX chiplets having good cores even if only a single EX chiplet mode is executed.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYS_FORCE_ALL_CORES</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYS_FORCE_ALL_CORES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Indicates the master boot core chiplet selected by p9_sbe_select_ex.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MASTER_CORE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MASTER_CORE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Indicates the EX targert associated with the master boot core selected by p9_sbe_select_ex.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MASTER_EX</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MASTER_EX</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Holds the state of Security Access Bit (SAB)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SECURITY_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SECURITY_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>To disable force pfet off control from fuse status</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PFET_OFF_CONTROLS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PFET_OFF_CONTROLS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Holds Obus ratio value 0b00 Normal speed. 0b01 Half speed.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_OBUS_RATIO_VALUE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>OBUS_RATIO_VALUE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Pibmem repair attribute 0</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PIBMEM_REPAIR0</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PIBMEM_REPAIR0</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Pibmem repair attribute 1</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PIBMEM_REPAIR1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PIBMEM_REPAIR1</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Pibmem repair attribute 2</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PIBMEM_REPAIR2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PIBMEM_REPAIR2</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>To skip the locking sequence and check for lock of CP filter PLL</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CP_FILTER_BYPASS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CP_FILTER_BYPASS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>To skip the locking sequence and check for lock of SS filter PLL</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SS_FILTER_BYPASS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SS_FILTER_BYPASS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>To skip the locking sequence and check for lock of IO filter PLL</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_FILTER_BYPASS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_FILTER_BYPASS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Skip locking sequence and check for lock of DPLL</description>
    <hwpfToHbAttrMap>
      <id>ATTR_DPLL_BYPASS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DPLL_BYPASS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Skip the locking sequence and check for lock of NEST/MEM/XBUS/OBUS/PCI PLLs</description>
    <hwpfToHbAttrMap>
      <id>ATTR_NEST_MEM_X_O_PCI_BYPASS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>NEST_MEM_X_O_PCI_BYPASS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>System Configurtion information - 1 indicates a chip present</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SBE_SYS_CONFIG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SBE_SYS_CONFIG</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0x0</default>
      </uint64_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Defines system specific value of processor refclock receiver termination</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CP_REFCLOCK_RCVR_TERM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CP_REFCLOCK_RCVR_TERM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines system specific value of PCI refclock receiver termination</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_REFCLOCK_RCVR_TERM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_REFCLOCK_RCVR_TERM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Sector buffer strength</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SECTOR_BUFFER_STRENGTH</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SECTOR_BUFFER_STRENGTH</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>enable the pulse mode</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PULSE_MODE_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PULSE_MODE_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>value for pulse mode</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PULSE_MODE_VALUE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PULSE_MODE_VALUE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Step size (binary in microvolts) to take upon external VRM voltage transitions. The value set here must take into account where internal VRMs are enabled or not as, when they are enabled, the step size must account for the tracking (eg PFET strength recalculation) for the step. Consumer: p9_pstate_parameter_block -&gt; Pstate Parameter Block (PSPB) for PGPE Provided by the Machine Readable Workbook after system characterization.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXTERNAL_VRM_STEPSIZE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXTERNAL_VRM_STEPSIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x00</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Step delay (binary in microseconds) after a voltage change Consumer: p9_pstate_parameter_block -&gt; Pstate Parameter Block (PSPB) for PGPE Provided by the Machine Readable Workbook after system characterization.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXTERNAL_VRM_STEPDELAY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXTERNAL_VRM_STEPDELAY</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Delay (binary in nanoseconds) from the time the VRM receives the write voltage command until the voltage actually moves. This value is used for both increasing and decreasing transitions as part of the overall voltage transition time calculation. Firmware provides a default value of 8000ns (eg 8us)) if this attribute is zero. Note: the smallest possible delay is limited to 1ns. Consumer: p9_pstate_parameter_block -&gt; Pstate Parameter Block (PSPB) for PGPE Provided by the Machine Readable Workbook after system characterization.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXTERNAL_VRM_TRANSITION_START_NS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXTERNAL_VRM_TRANSITION_START_NS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x00</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Transition rate (binary in microVolts per microsecond) of the VRM for an increasing voltage transition. This is used as part of the overall voltage transition time calculation Firmware provides a default value of 10000 uV/us (eg 10mV/us) if this attribute is zero. Note: the fastest possible rate is limited to 1uV/us. Consumer: p9_pstate_parameter_block -&gt; Pstate Parameter Block (PSPB) for PGPE Provided by the Machine Readable Workbook after system characterization.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXTERNAL_VRM_TRANSITION_RATE_INC_UV_PER_US</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXTERNAL_VRM_TRANSITION_RATE_INC_UV_PER_US</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x00</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Transition rate (binary in microVolts per microsecond) of the VRM for an decreasing voltage transition. This is used as part of the overall voltage transition time calculation Firmware provides a default value of 10000 uV/us (eg 10mV/us) if this attribute is zero. Note: the fastest possible rate is limited to 1uV/us. Consumer: p9_pstate_parameter_block -&gt; Pstate Parameter Block (PSPB) for PGPE Provided by the Machine Readable Workbook after system characterization.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXTERNAL_VRM_TRANSITION_RATE_DEC_UV_PER_US</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXTERNAL_VRM_TRANSITION_RATE_DEC_UV_PER_US</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x00</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Time (binary in nanoseconds) to allow the voltage rail to stabilize before considering the transition to be fully complete. This value is used for both increasing and decreasing transitions as part of the overall voltage transition time calculation. Firmware provides a default value of 5000ns (5us) if this attribute is zero. Note: the smallest delay is limited to 1ns. Consumer: p9_pstate_parameter_block -&gt; Pstate Parameter Block (PSPB) for PGPE Provided by the Machine Readable Workbook after system characterization.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXTERNAL_VRM_TRANSITION_STABILIZATION_TIME_NS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXTERNAL_VRM_TRANSITION_STABILIZATION_TIME_NS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x00</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>AVSBus Clock Frequency (binary in KHz) Consumer: p9_ocb_init.C Overridden by the Machine Readable Workbook. If default of 0 is read, HWP will set AVSBus frequency to 1MHz.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_AVSBUS_FREQUENCY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>AVSBUS_FREQUENCY</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines the AVSBus (0 or 1) which has the core VDD rail VRM Producer: Machine Readable Workbook Consumers: p9_set_evid; p9_set_voltage (tool); p9_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB) for PGPE *MOST* systems use Bus 0 for VDD. If this is not the case, the value must be appropriately set by the platform (eg MRWB or equivalent</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VDD_AVSBUS_BUSNUM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VDD_AVSBUS_BUSNUM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines the AVSBus (0 or 1) which has the chip VDN rail VRM Producer: Machine Readable Workbook Consumers: p9_set_evid; p9_set_voltage (tool); p9_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB) for PGPE *MOST* systems use Bus 1 for VDD. If this is not the case, the value must be appropriately set by the platform (eg MRWB or equivalent)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VDN_AVSBUS_BUSNUM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VDN_AVSBUS_BUSNUM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines the AVSBus (0 or 1) which has the chip VCS rail VRM Producer: Machine Readable Workbook Consumers: p9_set_evid; p9_set_voltage (tool); p9_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB) for PGPE For systems where VCS is not connected via AVSBus, set to 0xFF.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VCS_AVSBUS_BUSNUM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VCS_AVSBUS_BUSNUM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines the AVSBus rail selector number (0 - 15) for the VDD VRM on the bus defined by ATTR_AVSBUS_VDD_BUSNUM. Producer: Machine Readable Workbook Consumers: p9_set_evid; p9_set_voltage (tool); p9_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB) for PGPE *MOST* systems use Rail 0 for VDD for the bus on which they are connected. If this is not the case, the value must be appropriately set by the platform (eg MRWB or equivalent)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VDD_AVSBUS_RAIL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VDD_AVSBUS_RAIL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines the AVSBus rail selector number (0 - 15) for the VDN VRM on the bus defined by ATTR_AVSBUS_VDN_BUSNUM. Producer: Machine Readable Workbook Consumers: p9_set_avsbus_voltage (tool); p9_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB) for PGPE *MOST* systems use Rail 0 for VDN for the bus on which they are connected. If this is not the case, the value must be appropriately set by the platform (eg MRWB or equivalent)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VDN_AVSBUS_RAIL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VDN_AVSBUS_RAIL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines the AVSBus rail selector number (0 - 15) for the VCS VRM on the bus defined by ATTR_AVSBUS_VCS_BUSNUM. Producer: Machine Readable Workbook Consumers: p9_set_avsbus_voltage (tool); p9_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB) for PGPE</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VCS_AVSBUS_RAIL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VCS_AVSBUS_RAIL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines the I2C bus number (0 - 15) that has the VCS VRM. Producer: Machine Readable Workbook Consumers: p9_set_evid; p9_set_voltage (tool)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VCS_I2C_BUSNUM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VCS_I2C_BUSNUM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines the I2C rail selector number (0 - 15) for the VCS VRM on the bus defined by ATTR_VCS_I2C_BUSNUM. Producer: Machine Readable Workbook Consumers: p9_set_evid; p9_set_voltage (tool)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VCS_I2C_RAIL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VCS_I2C_RAIL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>SPIPSS Clock Frequency (binary in KHz) Valid range: 500KHz to 2500KHz Consumer: p9_pss_init Overridden by the Machine Readable Workbook. If default of 0 is read, HWP will set SPIPSS frequency to 10MHz.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SPIPSS_FREQUENCY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SPIPSS_FREQUENCY</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines which of the PSS chip selects (0 or 1) that the APSS is connected Provided by the Machine Readable Workbook. Consumer: p9_pm_pss_init</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PM_APSS_CHIP_SELECT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PM_APSS_CHIP_SELECT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Impedance (binary microOhms) of the load line from a processor VDD VRM to the Processor Module pins. This value is applied to each processor instance. Producer: Machine Readable Workbook (per the power subsystem design) Consumers: p9_pstate_parameter_block</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_R_LOADLINE_VDD_UOHM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_R_LOADLINE_VDD_UOHM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Impedance (binary in microOhms) of the VDD distribution loss sense point to the circuit. This value is applied to each processor instance. Producer: Machine Readable Workbook (per the power subsystem design) Consumers: p9_pstate_parameter_block</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_R_DISTLOSS_VDD_UOHM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_R_DISTLOSS_VDD_UOHM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Offset voltage (binary in microvolts) to apply to the VDD VRM distribution to the processor module. This value is applied to each processor instance. Note: no loadline may be present in the system; thus, a value of 0 is legal. Producer: Machine Readable Workbook (per the power subsystem design) Consumers: p9_pstate_parameter_block</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_VRM_VOFFSET_VDD_UV</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_VRM_VOFFSET_VDD_UV</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Impedance (binary microOhms) of the load line from a processor VDN VRM to the Processor Module pins. This value is applied to each processor instance. Note: no loadline may be present in the system; thus, a value of 0 is legal. Producer: Machine Readable Workbook (per the power subsystem design) Consumers: p9_pstate_parameter_block</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_R_LOADLINE_VDN_UOHM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_R_LOADLINE_VDN_UOHM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Impedance (binary in microOhms) of the VDN distribution loss sense point to the circuit. This value is applied to each processor instance. Producer: Machine Readable Workbook (per the power subsystem design) Consumers: p9_pstate_parameter_block</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_R_DISTLOSS_VDN_UOHM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_R_DISTLOSS_VDN_UOHM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Offset voltage (binary in microvolts) to apply to the VDN VRM distribution to the processor module. This value is applied to each processor instance. Producer: Machine Readable Workbook (per the power subsystem design) Consumers: p9_pstate_parameter_block</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_VRM_VOFFSET_VDN_UV</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_VRM_VOFFSET_VDN_UV</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Impedance (binary microOhms) of the load line from a processor VCS VRM to the Processor Module pins. This value is applied to each processor instance. Note: no loadline may be present in the system; thus, a value of 0 is legal. Producer: Machine Readable Workbook (per the power subsystem design) Consumers: p9_pstate_parameter_block</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_R_LOADLINE_VCS_UOHM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_R_LOADLINE_VCS_UOHM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Impedance (binary in microOhms) of the VCS distribution loss sense point to the circuit. This value is applied to each processor instance. Producer: Machine Readable Workbook (via the power subsystem design per system) Consumer: p9_pstate_parameter_block</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_R_DISTLOSS_VCS_UOHM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_R_DISTLOSS_VCS_UOHM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Offset voltage (binary in microvolts) to apply to the VCS VRM distribution to the processor module. This value is applied to each processor instance. Producer: Machine Readable Workbook (via the power subsystem design per system) Consumer: FSP</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_VRM_VOFFSET_VCS_UV</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_VRM_VOFFSET_VCS_UV</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>UltraTurbo Frequency Bias - % of bias (signed twos complement in 0.5 percent steps) used in calculating the frequency associated with a Pstate - both Global and Local. Producer: Attribute Overrides by Lab/Mfg Characterization Team Consumer: p9_pstate_parameter_block</description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_BIAS_ULTRATURBO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_BIAS_ULTRATURBO</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <int8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Turbo Frequency Bias - % of bias (signed twos complement in 0.5 percent steps) used in calculating the frequency associated with a Pstate - both Global and Local. Producer: Attribute Overrides by Lab/Mfg Characterization Team Consumer: p9_pstate_parameter_block</description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_BIAS_TURBO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_BIAS_TURBO</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <int8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Nominal Frequency Bias - % of bias (signed twos complement in 0.5 percent steps) used in calculating the frequency associated with a Pstate - both Global and Local. Producer: Attribute Overrides by Lab/Mfg Characterization Team Consumer: p9_pstate_parameter_block</description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_BIAS_NOMINAL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_BIAS_NOMINAL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <int8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>PowerSave Frequency Bias - % of bias (signed twos complement in 0.5 percent steps) used in calculating the frequency associated with a Pstate - both Global and Local. Producer: Attribute Overrides by Lab/Mfg Characterization Team Consumer: p9_pstate_parameter_block</description>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_BIAS_POWERSAVE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FREQ_BIAS_POWERSAVE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <int8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>UltraTurbo VDD Voltage Bias - % of bias (signed twos complement in 0.5 percent steps) that is applied to the UltraTurbo VPD point used in calculating the Global Pstate values. Producer: Attribute Overrides by Lab/Mfg Characterization Team Consumer: p9_pstate_parameter_block</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VOLTAGE_EXT_VDD_BIAS_ULTRATURBO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VOLTAGE_EXT_VDD_BIAS_ULTRATURBO</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <int8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Turbo VDD Voltage Bias - % of bias (signed twos complement in 0.5 percent steps) that is applied to the UltraTurbo VPD point used in calculating the Global Pstate values. Producer: Attribute Overrides by Lab/Mfg Characterization Team Consumer: p9_pstate_parameter_block</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VOLTAGE_EXT_VDD_BIAS_TURBO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VOLTAGE_EXT_VDD_BIAS_TURBO</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <int8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Nominal VDD Voltage Bias - % of bias (signed twos complement in 0.5 percent steps) that is applied to the UltraTurbo VPD point used in calculating the Global Pstate values. Producer: Attribute Overrides by Lab/Mfg Characterization Team Consumer: p9_pstate_parameter_block</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VOLTAGE_EXT_VDD_BIAS_NOMINAL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VOLTAGE_EXT_VDD_BIAS_NOMINAL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <int8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>PowerSave VDD Voltage Bias - % of bias (signed twos complement in 0.5 percent steps) that is applied to the UltraTurbo VPD point used in calculating the Global Pstate values. Producer: Attribute Overrides by Lab/Mfg Characterization Team Consumer: p9_pstate_parameter_block</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VOLTAGE_EXT_VDD_BIAS_POWERSAVE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VOLTAGE_EXT_VDD_BIAS_POWERSAVE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <int8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>VCS Voltage Bias - % of bias (signed twos complement in 0.5 percent steps) that is applied to the VCS value stored in the UltraTurbo VPD point for setting the VCS rail. Producer: Attribute Overrides by Lab/Mfg Characterization Team Consumer: p9_pstate_parameter_block Platform default: 0</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VOLTAGE_EXT_VCS_BIAS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VOLTAGE_EXT_VCS_BIAS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <int8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>VDN Voltage Bias - % of bias (signed twos complement in 0.5 percent steps) that is applied to the VDN value stored in the VPD for setting the VDN rail. Producer: Attribute Overrides by Lab/Mfg Characterization Team Consumer: p9_pstate_parameter_block Platform default: 0</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VOLTAGE_EXT_VDN_BIAS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VOLTAGE_EXT_VDN_BIAS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <int8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>TODO (RTC 136996) NEED TO LOOK AT PERCENTAGE IMPLEMENTATION IN CME CODE AS WELL AS THE IVRM VOLTAGE CALCULATION PROCESS UltraTurbo Internal VDD Voltage Bias - % of bias (signed twos complement in 0.5 percent steps) that is applied to the voltage computed (Vout) as part of the Local Pstate. Note: the Vin Effective that models the Vin to the PFETs (i.e accounting for system parameter losses) may include biassing based on ATTR_VOLTAGE_VDD_BIAS_ULTRATURBO. Producer: Attribute Overrides by Lab/Mfg Characterization Team Consumer: p9_pstate_parameter_block Platform default: 0</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VOLTAGE_INT_VDD_BIAS_ULTRATURBO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VOLTAGE_INT_VDD_BIAS_ULTRATURBO</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <int8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>TODO (RTC 136996) NEED TO LOOK AT PERCENTAGE IMPLEMENTATION IN CME CODE AS WELL AS THE IVRM VOLTAGE CALCULATION PROCESS TURBO Internal VDD Voltage Bias - % of bias (signed twos complement in 0.5 percent steps) that is applied to the voltage computed (Vout) as part of the Local Pstate. Note: the Vin Effective that models the Vin to the PFETs (i.e accounting for system parameter losses) may include biassing based on ATTR_VOLTAGE_VDD_BIAS_TURBO. Producer: Attribute Overrides by Lab/Mfg Characterization Team Consumer: p9_pstate_parameter_block Platform default: 0</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VOLTAGE_INT_VDD_BIAS_TURBO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VOLTAGE_INT_VDD_BIAS_TURBO</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <int8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>TODO (RTC 136996) NEED TO LOOK AT PERCENTAGE IMPLEMENTATION IN CME CODE AS WELL AS THE IVRM VOLTAGE CALCULATION PROCESS Nominal Internal VDD Voltage Bias - % of bias (signed twos complement in 0.5 percent steps) that is applied to the voltage computed (Vout) as part of the Local Pstate. Note: the Vin Effective that models the Vin to the PFETs (i.e accounting for system parameter losses) may include biassing based on ATTR_VOLTAGE_VDD_BIAS_NOMINAL. Producer: Attribute Overrides by Lab/Mfg Characterization Team Consumer: p9_pstate_parameter_block Platform default: 0</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VOLTAGE_INT_VDD_BIAS_NOMINAL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VOLTAGE_INT_VDD_BIAS_NOMINAL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <int8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>TODO (RTC 136996) NEED TO LOOK AT PERCENTAGE IMPLEMENTATION IN CME CODE AS WELL AS THE IVRM VOLTAGE CALCULATION PROCESS PowerSave Internal VDD Voltage Bias - % of bias (signed twos complement in 0.5 percent steps) that is applied to the voltage computed (Vout) as part of the Local Pstate. Note: the Vin Effective that models the Vin to the PFETs (i.e accounting for system parameter losses) may include biassing based on ATTR_VOLTAGE_VDD_BIAS_POWERSAVE. Producer: Attribute Overrides by Lab/Mfg Characterization Team Consumer: p9_pstate_parameter_block Platform default: 0</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VOLTAGE_INT_VDD_BIAS_POWERSAVE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VOLTAGE_INT_VDD_BIAS_POWERSAVE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <int8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Control CME response to execution of PowerPC STOP instruction if OFF, treat STOP4 as STOP4 if ON, treat STOP4 as STOP2 Producer: Work-around tools Consumer: p9_hcode_image_build.C Platform default: OFF</description>
    <hwpfToHbAttrMap>
      <id>ATTR_STOP4_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>STOP4_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Control CME response to execution of PowerPC STOP instruction if OFF, treat STOP8 as STOP8 if ON, treat STOP8 as STOP4 Producer: Work-around tools Consumer: p9_hcode_image_build.C Platform default: OFF</description>
    <hwpfToHbAttrMap>
      <id>ATTR_STOP8_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>STOP8_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Control CME response to execution of PowerPC STOP instruction if OFF, treat STOP11 as STOP11 if ON, treat STOP11 as STOP8 Producer: Work-around tools Consumer: p9_hcode_image_build.C Platform default: OFF</description>
    <hwpfToHbAttrMap>
      <id>ATTR_STOP11_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>STOP11_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Disables Work Load Optimized Frequency (WOF) algorithms to modify frequency based on active core count and other inputs. OFF: Will enable WOF given all validity check pass. If validity checks fail, WOF will be disabled for the present IPL. ON: Will disable WOF OFF_SKIP_DD: Same as OFF but skips any validity checking of the chip design level (lab use only). Producer: Override Consumers: p9_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB) for PGPE/OCC</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_WOF_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_WOF_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Disables IVRM enablement in the system Producer: Override Consumers: p9_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB) for PGPE/OCC CME Quad Pstate Region (CQPR) for CM Quad Manager</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_IVRM_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_IVRM_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>If wof_enabled, defines the Frequency Ratio calculation performed. (THIS IS NOT SUPPORTED IN P9 GA1!).</description>
    <hwpfToHbAttrMap>
      <id>ATTR_WOF_ENABLE_FRATIO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>WOF_ENABLE_FRATIO</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>If wof_enabled, defines the Voltage Ratio calculation performed. THIS IS NOT SUPPORTED AT PRESENT. GA1 SUPPORT IS TBD).</description>
    <hwpfToHbAttrMap>
      <id>ATTR_WOF_ENABLE_VRATIO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>WOF_ENABLE_VRATIO</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>If wof_enabled AND ATTR_WOF_ENABLE_VRATIO = CALCULATED, this attribute selects the Vratio calculation type. ACTIVE_CORES: Vratio is the number of active cores to the number of good cores FULL: Vratio is Vaverage to Vclip(Fclip) where Vclip(Fclip) is the normal interpolated regulator voltage (including load line uplife @ RDP current) derated with presently measured Idd current (from the AVSBus) and the loadline.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_WOF_VRATIO_SELECT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>WOF_VRATIO_SELECT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Receive PBAX Groupid. Value that indicates this PBA's PBAX Group affinity. This is matched to pbax_groupid of the PMISC Address phase. Provided by the Machine Readable Workbook. Platform default: Nimbus systems = 0</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PBAX_GROUPID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PBAX_GROUPID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Receive PBAX Chipid. Value that indicates this PBA's PBAX Chipid within the PBAX node. Is matched to pbax_chipid of the Address phase if pbax_type=unicast. Provided by the Machine Readable Workbook. Platform default: Nimbus systems - set so value in ATTR_FABRIC_GROUP_ID</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PBAX_CHIPID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PBAX_CHIPID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Receive PBAX Broadcast Group. Vector that is indexed when decoded PMISC pbax_type=broadcast with the decoded PMISC pbax_chipid value. If the bit in this vector at the decoded bit location is a 1, then this receive engine will participate in the broadcast operation. Override attribute. Platform value of 0 indiates the OCC firmware will perform this function.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PBAX_BRDCST_ID_VECTOR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PBAX_BRDCST_ID_VECTOR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>1 if override of poundv bucket num is available. 0 if override is unavailable.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_POUNDV_BUCKET_NUM_OVERRIDE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>POUNDV_BUCKET_NUM_OVERRIDE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Attribute in place to allow override of which POUNDV bucket to use to set power management data. 1 = Bucket A 2 = Bucket B 3 = Bucket C 4 = Bucket D 5 = Bucket E 6 = Bucket F</description>
    <hwpfToHbAttrMap>
      <id>ATTR_POUNDV_BUCKET_NUM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>POUNDV_BUCKET_NUM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>if set to 1, FAPI_ERR records are suppressed from being produced by p9_dump_stop_info.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_DUMP_STOP_INFO_SUPPRESS_ERROR_TRACE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DUMP_STOP_INFO_SUPPRESS_ERROR_TRACE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>if set to 1, p9_dump_stop_info output will be written to error logs</description>
    <hwpfToHbAttrMap>
      <id>ATTR_DUMP_STOP_INFO_ENABLE_ERRORLOG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DUMP_STOP_INFO_ENABLE_ERRORLOG</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Voltage Droop Monitor (VDM) Small Threshold Select Value per VPD point The enum indicates a negative value below the VDM setting that will trigger a small droop event. Array of 5 entries: 0 = PowerSave, 1 = Nominal; 2 = Turbo; 3 = UltraTurbo; 4 = Enable If index 4 is non-zero, the other entries are considered valid. Producer: Override</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VDM_DROOP_SMALL_OVERRIDE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VDM_DROOP_SMALL_OVERRIDE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>5</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Voltage Droop Monitor (VDM) Large Threshold Select Value per VPD point The enum indicates a negative value below the VDM setting that will trigger a large droop event. Array of 5 entries: 0 = PowerSave, 1 = Nominal; 2 = Turbo; 3 = UltraTurbo; 4 = Enable If index 4 is non-zero, the other entries are considered valid. Producer: Override</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VDM_DROOP_LARGE_OVERRIDE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VDM_DROOP_LARGE_OVERRIDE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>5</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Voltage Droop Monitor (VDM) Extreme Threshold Select Value per VPD point. The enum indicates a negative value below the VDM setting that will trigger an extreme droop event. Array of 5 entries: 0 = PowerSave, 1 = Nominal; 2 = Turbo; 3 = UltraTurbo; 4 = Enable If index 4 is non-zero, the other entries are considered valid. Producer: Override</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VDM_DROOP_EXTREME_OVERRIDE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VDM_DROOP_EXTREME_OVERRIDE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>5</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Voltage Droop Monitor (VDM) OverVoltage Threshold Select Value per VPD point. The enum indicates a positive value above the VDM setting that will indicate an overvolt droop condition. Array of 5 entries: 0 = PowerSave, 1 = Nominal; 2 = Turbo; 3 = UltraTurbo; 4 = Enable If index 4 is non-zero, the other entries are considered valid. Producer: Override</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VDM_OVERVOLT_OVERRIDE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VDM_OVERVOLT_OVERRIDE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>5</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>DPLL response override of the respective #W VPD content for a Voltage Droop Monitor (VDM) Small Frequency Drop (eg Normal to Small). Values are in 1/32ths with legal values being of N being less than or equal to 8. Array of 5 entries: 0 = PowerSave, 1 = Nominal; 2 = Turbo; 3 = UltraTurbo; 4 = Enable If index 4 is non-zero, the other entries are considered valid. Producer: Override</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VDM_SMALL_FREQ_DROP_N_S_OVERRIDE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VDM_SMALL_FREQ_DROP_N_S_OVERRIDE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>5</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>DPLL response override of the respective #W VPD content for a Voltage Droop Monitor (VDM) Large Frequency Drop (eg Normal to Large). Values are in 1/32ths with legal values being of N being less than or equal to 8. Array of 5 entries: 0 = PowerSave, 1 = Nominal; 2 = Turbo; 3 = UltraTurbo; 4 = Enable If index 4 is non-zero, the other entries are considered valid. Producer: Override</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VDM_LARGE_FREQ_DROP_N_L_OVERRIDE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VDM_LARGE_FREQ_DROP_N_L_OVERRIDE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>5</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>DPLL response override of the respective #W VPD content for returning from a Large Frequency Droop value to the Small value. Values are in 1/32ths with legal values being of N being less than or equal to 8. Array of 5 entries: 0 = PowerSave, 1 = Nominal; 2 = Turbo; 3 = UltraTurbo; 4 = Enable If index 4 is non-zero, the other entries are considered valid. Producer: Override</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VDM_FREQ_RETURN_L_S_OVERRIDE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VDM_FREQ_RETURN_L_S_OVERRIDE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>5</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>DPLL response override of the respective #W VPD content for returning from a Small Frequency Droop value to the Normal value. Values are in 1/32ths with legal values being of N being less than or equal to 8. Array of 5 entries: 0 = PowerSave, 1 = Nominal; 2 = Turbo; 3 = UltraTurbo; 4 = Enable If index 4 is non-zero, the other entries are considered valid. Producer: Override</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VDM_FREQ_RETURN_S_N_OVERRIDE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VDM_FREQ_RETURN_S_N_OVERRIDE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>5</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Controls the enablement of Voltage Droop Monitors (VDM) to throttle the core upon an extreme droop event. Producer: Machine Readable Workbook Consumers: p9_hcode_image_build to set flag for CME QuadManager Hcode reaction</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VDM_EXTREME_THOTTLE_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VDM_EXTREME_THOTTLE_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Producer: Override</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VDM_FMAX_OVERRIDE_KHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VDM_FMAX_OVERRIDE_KHZ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>5</array>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Producer: Override</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VDM_FMIN_OVERRIDE_KHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VDM_FMIN_OVERRIDE_KHZ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>5</array>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Voltage Droop Monitor (VDM) Voltage Compare Voltage to expect when no droop is present (binary in mV). A default value of 0 indicates no override Array of 5 entries: 0 = PowerSave, 1 = Nominal; 2 = Turbo; 3 = UltraTurbo; 4 = Enable Producer: Override</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VDM_VID_COMPARE_OVERRIDE_MV</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VDM_VID_COMPARE_OVERRIDE_MV</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>5</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>VDM Voltage Compare Bias - % of bias (signed twos complement in 0.5 percent steps) that is applied to the #W VDM VID Compare before placement in the respective Pstate Paramter Blocks that will be consumed by Hcode. Array of 4 entries: 0 = PowerSave, 1 = Nominal; 2 = Turbo; 3 = UltraTurbo Producer: Override</description>
    <hwpfToHbAttrMap>
      <id>ATTR_VDM_VID_COMPARE_BIAS_0P5PCT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>VDM_VID_COMPARE_BIAS_0P5PCT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <int8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Indicates the response of the DPLL frequency upon VDM events if ATTR_SYSTEM_VDM_DISABLE is not ON. NONE -&gt; DPLL Mode 2 DROOP_PROTECT -&gt; DPLL Mode 3 DROOP_PROTECT_OVERVOLT -&gt; DPLL Mode 3.5 DYNAMIC -&gt; DPLL Mode 4 DYNAMIC_PROTECT -&gt; DPLL Mode 5 Producer: MRWB.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_DPLL_VDM_RESPONSE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DPLL_VDM_RESPONSE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Override value for the value of the deadzone where the iVRM cannot regulate (binary in millivolts). The deadzone is the difference between the voltage from the external VRM after load line and other losses are removed and the request regulation voltage. If this difference is smaller than the value of this attribute, the iVRM is forced in to bypass to use the external voltage. Producer: Override Consumer: p9_pstate_parameter_block -&gt; CME pstate parameter block PGPE pstate parameter block Handling: p9_pstate_parameter_block reads this attribute. If zero, the value of 50 (0x32) is used. If non-zero, this value is used.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IVRM_DEADZONE_MV</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IVRM_DEADZONE_MV</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Override Lookup table used to as part of determining the PFET width to use based on the voltage across the PFET header. Producer: Override Consumer: p9_pstate_parameter_block -&gt; CME pstate parameter block PGPE pstate parameter block</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IVRM_STRENGTH_LOOKUP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IVRM_STRENGTH_LOOKUP</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>64</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Overide the hardcoded multiplier table used with the strength lookup to determine the IVRM PFET width. Producer: Override Consumer: p9_pstate_parameter_block -&gt; CME pstate parameter block PGPE pstate parameter block</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IVRM_VIN_MULTIPLIER</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IVRM_VIN_MULTIPLIER</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>64</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Override voltage maximum that is used for the IVRM PFET width calculation. Setting to 0 will use the default 1100mV. Setting this to a non-zero value will cause this value to be used instead. Producer: Override Consumer: p9_pstate_parameter_block -&gt; CME pstate parameter block PGPE pstate parameter block</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IVRM_VIN_MAX_MV</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IVRM_VIN_MAX_MV</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Override time (in nanoseconds) to wait between IVRM steps that are part of a larger transition to the ultimate destination voltage. Producer: Override Consumer: p9_pstate_parameter_block -&gt; CME pstate parameter block PGPE pstate parameter block</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IVRM_STEP_DELAY_NS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IVRM_STEP_DELAY_NS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Override time (in nanoseconds) to wait after the iVRM indicates "done" in the event extra time is required. A zero value will have the hardcoded default to be used. Producer: MRWB. Consumer: p9_pstate_parameter_block -&gt; CME pstate parameter block PGPE pstate parameter block</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IVRM_STABILIZATION_DELAY_NS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IVRM_STABILIZATION_DELAY_NS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>TODO RTC 157943 -- Placeholder description This overrides the RDP to TDP Scaling Factor IQ VPD field that is used for Workload Optimized Frequency (WOF) voltage uplifting. Consumers: p9_pstate_parameter_block</description>
    <hwpfToHbAttrMap>
      <id>ATTR_TDP_RDP_CURRENT_FACTOR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>TDP_RDP_CURRENT_FACTOR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Disables the enablement of resonant clocking in the system. Producer: Override Consumers: p9_pstate_parameter_block to clear the flag for CME QuadManager Hcode reaction</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_RESCLK_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_RESCLK_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Minimum delay (in nanoseconds) between clock grid management transition steps Producer: MRWB from clock team Consumers: p9_build_pstate_datablock -&gt; CME Quad Pstate Region (CQPR) for CM Quad Manager Platform default: 0</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_RESCLK_STEP_DELAY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_RESCLK_STEP_DELAY</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Debug modes supported for CME/SGPE Scan layout in HOMER.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_RING_DBG_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_RING_DBG_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Time between invocations of the 24x7 performance collection function on GPE1. The time (in milliseconds) is derived as 2^PERF_24x7_INVOCATION_TIME_MS with 0 indicating the function is OFF. Consumer: p9_hcode_image_build.c -&gt; SGPE Header field Provided by the Machine Readable Workbook to tune the collection. Platform default: 1</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PERF_24x7_INVOCATION_TIME_MS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PERF_24x7_INVOCATION_TIME_MS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Enables the SGPE Hcode to enable the CME instruction traces into the L3 Trace array for debug. Note: all configured CMEs will be put into this mode if this attribute is ON. Consumer: p9_hcode_image_build.c -&gt; SGPE Header field Platform default: OFF</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CME_INSTRUCTION_TRACE_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CME_INSTRUCTION_TRACE_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Enables the SGPE Hcode to enable the CME instruction traces into the CHTM for debug. Note: all configured CMEs will be put into this mode if this attribute is ON. Consumer: p9_hcode_image_build.c -&gt; SGPE Header field Platform default: OFF</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CME_CHTM_TRACE_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CME_CHTM_TRACE_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>CHTM Trace Memory Configuration value goes directly into CHTM_MEM register. User is responsible to put correct data for each bit field of the register. Consumer: p9_hcode_image_build.c -&gt; SGPE Header field Platform default: 0</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CME_CHTM_TRACE_MEMORY_CONFIG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CME_CHTM_TRACE_MEMORY_CONFIG</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0x00</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Enables the PGPE Hcode to physically perform frequency and voltage operations based on constructed parameters (eg #V VPD, system parameters, biases, WPF VFRTs. etc). If OFF, the PGPE provides an immedicate good response to all Pstate/WOF IPC operations from the OCC for firmware integration testing purposes. Consumer: p9_hcode_image_build.c -&gt; PGPE Header field Platform default: ON</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PGPE_HCODE_FUNCTION_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PGPE_HCODE_FUNCTION_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Enables pstate parameter block code to use the static #W data Consumer: p9_pstate_parameter_block.C -&gt; Platform default: OFF</description>
    <hwpfToHbAttrMap>
      <id>ATTR_POUND_W_STATIC_DATA_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>POUND_W_STATIC_DATA_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Time between invocations of auxiliary function on GPE1. The time (in milliseconds) is derived as 2^ATTR_AUX_FUNC_INVOCATION_TIME_MS with 0 indicating the function is OFF. Consumer: p9_hcode_image_build.c -&gt; SGPE Header field Provided by the Machine Readable Workbook to tune the collection. Platform default: 1</description>
    <hwpfToHbAttrMap>
      <id>ATTR_AUX_FUNC_INVOCATION_TIME_MS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>AUX_FUNC_INVOCATION_TIME_MS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x01</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Enables pstate parameter block code to use the static system vfrt data Consumer: p9_pstate_parameter_block.C -&gt; Platform default: OFF</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYS_VFRT_STATIC_DATA_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYS_VFRT_STATIC_DATA_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>SYSTEM Attribute Nest leakage percentage used to calculate the Core leakage. Will eventually be read into OCC Pstate Parameter Block so the OCC can see it for it's calculations. Valid Values: 0% thru 100% Producer: Machine Readable Workbook Consumer: OCC Firmware</description>
    <hwpfToHbAttrMap>
      <id>ATTR_NEST_LEAKAGE_PERCENT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>NEST_LEAKAGE_PERCENT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x3C</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Controls the mode of Pstate Protocol for testing. ON: Boots the PGPE in "OCC Pstate Mode" but does NOT start the Pstate protocol OFF: Does NOT boot the PGPE AUTO: Boots the PGPE and automatically starts the Pstate protocol. PMCR operations to move Pstates are honored Producer: Override Consumers: p9_pstate_parameter_block and p9_pm_pstate_gpe_init</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_PSTATES_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_PSTATES_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>The number of PGPE Fixed Timer Interrupts (see Hcode documentation for durations) to assert a core throttle when OCC Scratch 2[Core Throttle Continuous Change Enable] is set. A value of 0 when Continuous Change Enable is set will deassert throttle. Producer: Override/Lab Consumers: p9_hcode_image_build.c -&gt; PGPE Header field</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CORE_THROTTLE_ASSERT_COUNT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CORE_THROTTLE_ASSERT_COUNT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>The number of PGPE Fixed Timer Interrupts (see Hcode documentation for machine dependent durations) to deassert core throttle when OCC Scratch 2[Core Throttle Continuous Change Enable] is set. A value of 0 when Continuous Change Enable is set and ATTR_CORE_THROTTLE_ASSERT_COUNT is non-0, throttling is always on. Producer: Override/Lab Consumers: p9_hcode_image_build.c -&gt; PGPE Header field</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CORE_THROTTLE_DEASSERT_COUNT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CORE_THROTTLE_DEASSERT_COUNT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>env: 1 = Awan/HWSimulator. 0 = Simics/RealHW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IS_SIMULATION</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IS_SIMULATION</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Which execution platform the HW Procedure is running on Some HWPs (e.g. special wakeup) use different registers for different platforms to avoid arbitration problems when multiple platforms do the same thing concurrently</description>
    <hwpfToHbAttrMap>
      <id>ATTR_EXECUTION_PLATFORM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>EXECUTION_PLATFORM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>The manufacturing flags. This is a bitfield. Each bit is a flag and multiple flags can be set</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MNFG_FLAGS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MNFG_FLAGS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0x0000000000000000</default>
      </uint64_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Defines system specific value of DMI refclock receiver termination (FSI GP4 bits 8:9)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_DMI_REFCLOCK_RCVR_TERM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_DMI_REFCLOCK_RCVR_TERM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines system specific value of DDR refclock receiver termination (FSI GP4 bits 10:11)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_DDR_REFCLOCK_RCVR_TERM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_DDR_REFCLOCK_RCVR_TERM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Centaur DQ to DIMM connector DQ mapping. Uint8 value for each Centaur DQ (0-79). The value is the corresponding DIMM Connector DQ. Therefore if (data[2] == 60) then Centaur DQ 2 maps to DIMM DQ 60 If the logical DIMM is on a Centaur-DIMM then the value is the same as the array index because there is no DIMM connector. If the logical DIMM is an IS-DIMM then the value depends on board wiring.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_DQ_TO_DIMM_CONN_DQ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_DQ_TO_DIMM_CONN_DQ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>80</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>MBA Chiplet port this DIMM is connected to</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MBA_PORT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MBA_PORT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>MBA port DIMM number of this DIMM</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MBA_DIMM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MBA_DIMM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Bad DQ bitmap from a Centaur:MBA point of view. The data is a 10 byte bitmap for each of 4 possible ranks. The bad DQ data is stored in DIMM SPD, it is stored in a special format and is translated to a DIMM Connector point of view for IS-DIMMs. All of these details are hidden from the user of this attribute.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_BAD_DQ_BITMAP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_BAD_DQ_BITMAP</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4,10</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Spare DRAM availability for all DIMMs connected to the target MBA. For each rank on a DIMM, there are 8 DQ lines to spare DRAMs. - NO_SPARE: No spare DRAMs - LOW_NIBBLE: x4 DRAMs in use, one spare DRAM connected to SP_DQ0-3 - HIGH_NIBBLE: x4 DRAMs in use, one spare DRAM connected to SP_DQ4-7 - FULL_BYTE: Either 1/ x4 DRAMs in use, two spare DRAMs connected to SP_DQ0-7 2/ x8 DRAMs in use, one spare DRAM connected to SP_DQ0-7 For C-DIMMs, this is in a VPD field : Record:VSPD, Keyword:AM</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_DIMM_SPARE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_DIMM_SPARE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2,2,4</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>RCD Timing. Supplied by VPD, used by mss_eff_config.C. Each dimm will have a value. consumer: mss_eff_config</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_DIMM_RCD_OUTPUT_TIMING</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_DIMM_RCD_OUTPUT_TIMING</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2,2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>The VPD Version of this DIMM. The version number can be an indication of when different DIMM keywords are valid and is loaded from the platform. The version represented here represents one of three distinct vintages of parts : unknown/error, early build CDIMMs with VZ less than 10, everything else. In other words, this attribute does NOT equate to the VZ keyword.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_VERSION</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_VERSION</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>The C-DIMM ranks that have address mirroring. This data is in the Record:VSPD, Keyword:AM field in C-DIMM VPD. This attribute is only valid for C-DIMMs, an error should be returned if queried from IS-DIMMs. Note: Muliple ranks can be mirrored.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_DRAM_ADDRESS_MIRRORING</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_DRAM_ADDRESS_MIRRORING</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2,2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Read ODT. Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT),mss_eff_cnfg_termination consumer: various.C files and initfiles firmware notes: none</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_ODT_RD</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_ODT_RD</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2,2,4</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Write ODT. Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Creator: VPD(MT)/ mss_eff_cnfg_termination consumer: various.C and initfile firmware notes: none</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_ODT_WR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_ODT_WR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2,2,4</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>DRAM Ron. Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. OHM48 is for DDR4. creator: VPD(MT)/mss_eff_cnfg_termination consumer: various.C files (no initfile) firmware notes: none This Attribute is to be interpreted as an Integer</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_DRAM_RON</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_DRAM_RON</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2,2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>DRAM Rtt_Nom. Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT),mss_eff_cnfg_termination consumer: various.C files (no initfiles) firmware notes: none This Attribute is to be interpreted as an Integer</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_DRAM_RTT_NOM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_DRAM_RTT_NOM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2,2,4</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>DRAM Rtt_WR. Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Creator: VPD(MT), mss_eff_cnfg_termination consumer: various.C files (no initfiles) firmware notes: none This Attribute is to be interpreted as an Integer</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_DRAM_RTT_WR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_DRAM_RTT_WR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2,2,4</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>DRAM Rtt_PARK. Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. RTT_Park value. This is for DDR4 MRS5.Each memory channel will have a value. Creator: VPD(MT), mss_eff_cnfg_termination consumer: various.C files (no initfiles) firmware notes: none This Attribute is to be interpreted as an Integer</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_DRAM_RTT_PARK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_DRAM_RTT_PARK</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2,2,4</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>DRAM Write Vref. Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT) or mss_eff_cnfg_termination consumer: various.C and initfile firmware notes: none This is the nominal value This is for DDR3 This Attribute is to be interpreted as an Integer</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_DRAM_WR_VREF</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_DRAM_WR_VREF</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint32_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>DRAM Write Vref. Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT) or mss_eff_cnfg_termination consumer: various firmware notes: none This is the nominal value This is for DDR4 The value is a decode that is passed into ATTR_CEN_EFF_VREF_DQ_TRAIN_RANGE and ATTR_CEN_EFF_VREF_DQ_TRAIN_VALUE: Decode: (R for Range V for Value, blank for unused) WRDDR4_VREF Bits 01234567 Attr Name RVVVVVV Attr Bits 0543210</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_DRAM_WRDDR4_VREF</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_DRAM_WRDDR4_VREF</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Centaur DQ and DQS Drive Impedance Used in various locations and comes from the MT Keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT)/mss_eff_cnfg_termination consumer: initfile,various.C files firmware notes: none This is the nominal value This Attribute is to be interpreted as an Integer</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_DRV_IMP_DQ_DQS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_DRV_IMP_DQ_DQS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Centaur Address Drive Impedance Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: mss_eff_cnfg_termination consumer: initfile and various.C firmware notes: none This is the nominal value This Attribute is to be interpreted as an Integer</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_DRV_IMP_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_DRV_IMP_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Centaur Control Drive Impedance Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT)/mss_eff_cnfg_termination consumer: initfile,various .C firmware notes: none This is the nominal value This Attribute is to be interpreted as an Integer</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_DRV_IMP_CNTL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_DRV_IMP_CNTL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Centaur Clock Drive Impedance Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT),mss_eff_cnfg_termination consumer: initfiles,various firmware notes: none This is the nominal value This Attribute is to be interpreted as an Integer</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_DRV_IMP_CLK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_DRV_IMP_CLK</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Centaur Spare Clock Drive Impedance Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT) , mss_eff_cnfg_termination consumer: initfiles, various.C firmware notes: none This is the nominal value This Attribute is to be interpreted as an Integer</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_DRV_IMP_SPCKE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_DRV_IMP_SPCKE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Centaur DQ and DQS Receiver Impedance Used in various locations and it comes from the VPD MT keyword for custom DIMMs or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD, mss_eff_cnfg_termination Consumer: initfile + C code firmware notes: none This is the nominal value This Attribute is to be interpreted as an Integer</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_RCV_IMP_DQ_DQS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_RCV_IMP_DQ_DQS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Centaur DQ and DQS Slew Rate Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Slowest slew rate is 0, incrementing by one. The lower the number the slower the slew rate the higher the faster. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT), mss_eff_cnfg_termination consumer: initfiles,various.C firmware notes: none This is the nominal value This Attribute is to be interpreted as an Integer except MAX</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_SLEW_RATE_DQ_DQS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_SLEW_RATE_DQ_DQS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Centaur Address Slew Rate Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Slowest slew rate is 0, incrementing by one. The lower the number the slower the slew rate the higher the faster. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT),mss_eff_cnfg_termination consumer: initfile,various .C files firmware notes: none This is the nominal value This Attribute is to be interpreted as an Integer except Max</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_SLEW_RATE_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_SLEW_RATE_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Centaur Clock Slew Rate Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Slowest slew rate is 0, incrementing by one. The lower the number the slower the slew rate the higher the faster. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT)mss_eff_cnfg_termination consumer: initfile,various.C files firmware notes: none This is the nominal value This Attribute is to be interpreted as an Integer except max</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_SLEW_RATE_CLK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_SLEW_RATE_CLK</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Centaur Spare Clock Slew Rate Used in various locations and comes from the MT keyword or is computed in mss_eff_cnfg_termination. Slowest slew rate is 0, incrementing by one. The lower the number the slower the slew rate the higher the faster. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT) or mss_eff_cnfg_termination consumer: initfile,various.C firmware notes: none This is the nominal value This Attribute is to be interpreted as an Integer except max</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_SLEW_RATE_SPCKE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_SLEW_RATE_SPCKE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Centaur Control Slew Rate Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Slowest slew rate is 0, incrementing by one. The lower the number the slower the slew rate the higher the faster. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT),mss_eff_cnfg_termination consumer:initfile, various .C files firmware notes: none This is the nominal value This Attribute is to be interpreted as an Integer except for max</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_SLEW_RATE_CNTL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_SLEW_RATE_CNTL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Centaur Read Vref. Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Creator: VPD(MT) or mss_eff_cnfg_termination consumer: various.C and initfiles firmware notes: none This is the nominal value This Attribute is to be interpreted as an Integer</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_RD_VREF</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_RD_VREF</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint32_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M0_CLK_P0</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M0_CLK_P0</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M0_CLK_P0</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M0_CLK_P1</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M0_CLK_P1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M0_CLK_P1</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M1_CLK_P0</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M1_CLK_P0</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M1_CLK_P0</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M1_CLK_P1</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M1_CLK_P1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M1_CLK_P1</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M_CMD_A0</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M_CMD_A0</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M_CMD_A0</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M_CMD_A1</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M_CMD_A1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M_CMD_A1</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M_CMD_A2</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M_CMD_A2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M_CMD_A2</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M_CMD_A3</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M_CMD_A3</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M_CMD_A3</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M_CMD_A4</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M_CMD_A4</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M_CMD_A4</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M_CMD_A5</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M_CMD_A5</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M_CMD_A5</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M_CMD_A6</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M_CMD_A6</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M_CMD_A6</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M_CMD_A7</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M_CMD_A7</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M_CMD_A7</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M_CMD_A8</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M_CMD_A8</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M_CMD_A8</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M_CMD_A9</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M_CMD_A9</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M_CMD_A9</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M_CMD_A10</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M_CMD_A10</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M_CMD_A10</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M_CMD_A11</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M_CMD_A11</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M_CMD_A11</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M_CMD_A12</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M_CMD_A12</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M_CMD_A12</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M_CMD_A13</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M_CMD_A13</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M_CMD_A13</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M_CMD_A14</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M_CMD_A14</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M_CMD_A14</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M_CMD_A15</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M_CMD_A15</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M_CMD_A15</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M_CMD_BA0</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M_CMD_BA0</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M_CMD_BA0</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M_CMD_BA1</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M_CMD_BA1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M_CMD_BA1</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M_CMD_BA2</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M_CMD_BA2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M_CMD_BA2</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M_CMD_CASN</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M_CMD_CASN</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M_CMD_CASN</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M_CMD_RASN</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M_CMD_RASN</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M_CMD_RASN</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M_CMD_WEN</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M_CMD_WEN</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M_CMD_WEN</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M_PAR</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M_PAR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M_PAR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M_ACTN</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M_ACTN</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M_ACTN</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M0_CNTL_CKE0</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M0_CNTL_CKE0</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M0_CNTL_CKE0</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M0_CNTL_CKE1</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M0_CNTL_CKE1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M0_CNTL_CKE1</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M0_CNTL_CKE2</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M0_CNTL_CKE2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M0_CNTL_CKE2</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M0_CNTL_CKE3</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M0_CNTL_CKE3</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M0_CNTL_CKE3</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M0_CNTL_CSN0</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M0_CNTL_CSN0</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M0_CNTL_CSN0</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M0_CNTL_CSN1</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M0_CNTL_CSN1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M0_CNTL_CSN1</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M0_CNTL_CSN2</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M0_CNTL_CSN2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M0_CNTL_CSN2</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M0_CNTL_CSN3</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M0_CNTL_CSN3</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M0_CNTL_CSN3</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M0_CNTL_ODT0</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M0_CNTL_ODT0</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M0_CNTL_ODT0</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M0_CNTL_ODT1</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M0_CNTL_ODT1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M0_CNTL_ODT1</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M1_CNTL_CKE0</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M1_CNTL_CKE0</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M1_CNTL_CKE0</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M1_CNTL_CKE1</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M1_CNTL_CKE1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M1_CNTL_CKE1</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M1_CNTL_CKE2</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M1_CNTL_CKE2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M1_CNTL_CKE2</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M1_CNTL_CKE3</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M1_CNTL_CKE3</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M1_CNTL_CKE3</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M1_CNTL_CSN0</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M1_CNTL_CSN0</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M1_CNTL_CSN0</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M1_CNTL_CSN1</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M1_CNTL_CSN1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M1_CNTL_CSN1</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M1_CNTL_CSN2</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M1_CNTL_CSN2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M1_CNTL_CSN2</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M1_CNTL_CSN3</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M1_CNTL_CSN3</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M1_CNTL_CSN3</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M1_CNTL_ODT0</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M1_CNTL_ODT0</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M1_CNTL_ODT0</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls the IO M1_CNTL_ODT1</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PHASE_ROT_M1_CNTL_ODT1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PHASE_ROT_M1_CNTL_ODT1</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Settings for periodic CAL - zcal 1, syscal 1, centering 0, rdclk 1, dqs align 1, rdclk_update_dis 0, dutycycle 0, and power dis (dqs) 1. Second byte has repeat as 000, mpr mode as 0, mba as 11, and the spares as 00</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_PERIODIC_MEMCAL_MODE_OPTIONS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_PERIODIC_MEMCAL_MODE_OPTIONS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint32_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>This value comes from the VPD keyword MT bytes 54 and 55 MT(54:55) for the Logical DIMM associated with port A. Bytes 118:119 for port B, 182:183 for port C and 246:247 for port D. In the end, the AB and CD portions form a 32 bit word for each mba to write into the corresponding ddrphy register</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_CKE_PRI_MAP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_CKE_PRI_MAP</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint32_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>This value comes from the VPD keyword MT bytes 56 to 59 MT(56:59) for the Logical DIMM associated with port A. Bytes 120:123 for port B, 184:187 for port C and 248:251 for port D. The values for Port A concatenated with port B forms the value for one MBA. C concat D forms the value for the other MBA</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_CKE_PWR_MAP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_CKE_PWR_MAP</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>This value comes from the VPD keyword MT bytes 61 MT(61) for the Logical DIMM associated with port A. Bytes 125 for port B, 189 for port C and 253 for port D</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_GPO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_GPO</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>This value comes from the VPD keyword MT byte 60 bits 4:7 for the Logical DIMM associated with port A. Byte 124 bits 4:7 for port B, 188 bits 4:7 for port C and 252 bits 4:7 for port D</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_RLO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_RLO</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>This value comes from the VPD keyword MT byte 60 bits 0:3 for the Logical DIMM associated with port A. Byte 124 bits 0:3 for port B, 188 bits 0:3 for port C and 252 bits 0:3 for port D</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_WLO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_WLO</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>This value comes from the VPD MR keyword byte 49 for ports A and B and byte 177 for port C and D. This means that all ADR blocks use this value on an mba level</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_TSYS_ADR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_TSYS_ADR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>This value comes from the VPD MR keyword byte 113 for ports A and B and byte 241 for port C and D. This means all DP18 blocks use this value on a mba level</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_TSYS_DP18</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_TSYS_DP18</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Custom DIMM Sensor Map for Primary I2C Port (1 byte of data): 0x00 No sensors attached 0x01 DIMM sensor 0 attached 0x02 DIMM sensor 1 attached 0x04 DIMM sensor 2 attached 0x08 DIMM sensor 3 attached 0x10 DIMM sensor 4 attached 0x20 DIMM sensor 5 attached 0x40 DIMM sensor 6 attached 0x80 DIMM sensor 7 attached Comes from the VPD MW Keyword</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_CDIMM_SENSOR_MAP_PRIMARY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_CDIMM_SENSOR_MAP_PRIMARY</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Custom DIMM Sensor Map for Secondary I2C Port (1 byte of data): 0x00 No sensors attached 0x01 DIMM sensor 0 attached 0x02 DIMM sensor 1 attached 0x04 DIMM sensor 2 attached 0x08 DIMM sensor 3 attached 0x10 DIMM sensor 4 attached 0x20 DIMM sensor 5 attached 0x40 DIMM sensor 6 attached 0x80 DIMM sensor 7 attached Comes from the VPD MW Keyword</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_CDIMM_SENSOR_MAP_SECONDARY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_CDIMM_SENSOR_MAP_SECONDARY</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Describes if this MBA is in 2N address mode. The DIMM attributes associated with this MBA describes if this mode is needed for SI. Come from the VPD and consumed in the mba_def.initfile.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_DRAM_2N_MODE_ENABLED</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_DRAM_2N_MODE_ENABLED</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Master Power Slope that comes from the VPD MW Keyword</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_CDIMM_VPD_MASTER_POWER_SLOPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_CDIMM_VPD_MASTER_POWER_SLOPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Master Power Intercept that comes from the VPD MW Keyword</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_CDIMM_VPD_MASTER_POWER_INTERCEPT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_CDIMM_VPD_MASTER_POWER_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Supplier Power Slope that comes from the VPD the MV Keyword</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_CDIMM_VPD_SUPPLIER_POWER_SLOPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_CDIMM_VPD_SUPPLIER_POWER_SLOPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Supplier Power Intercept that comes from MV Keyword</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_CDIMM_VPD_SUPPLIER_POWER_INTERCEPT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_CDIMM_VPD_SUPPLIER_POWER_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Describes the Version of MT Keyword</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_MT_VERSION_BYTE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_MT_VERSION_BYTE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Describes the Version of MR Keyword</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_MR_VERSION_BYTE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_MR_VERSION_BYTE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Describes the DATA control byte from MR</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_MR_DATA_CONTROL_BYTE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_MR_DATA_CONTROL_BYTE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Describes the DATA control byte from MT</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_MT_DATA_CONTROL_BYTE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_MT_DATA_CONTROL_BYTE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Capable power control settings.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_POWER_CONTROL_CAPABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_POWER_CONTROL_CAPABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Derived from calibration/characterization of read centering. Number of windage offset in units of pico-seconds[ps] with sign bit0 (0b0=positive, 0b1=negative) and value in bits1..31, so 0x80000023 for example would mean "-35ps". Can be overwritten by ODM vendors if done from VPD. Each port will have a value. creator: VPD consumer: mss_draminit_training_adv firmware notes: none</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_RD_CTR_WINDAGE_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_RD_CTR_WINDAGE_OFFSET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint32_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>VPD index for associated chip's memory buffer VPD</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_ISDIMM_MBVPD_INDEX</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_ISDIMM_MBVPD_INDEX</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Master Total Power Slope that comes from the VPD MW Keyword</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_CDIMM_VPD_MASTER_TOTAL_POWER_SLOPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_CDIMM_VPD_MASTER_TOTAL_POWER_SLOPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Master Total Power Intercept that comes from the VPD MW Keyword</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_CDIMM_VPD_MASTER_TOTAL_POWER_INTERCEPT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_CDIMM_VPD_MASTER_TOTAL_POWER_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Supplier Total Power Slope that comes from the VPD MV Keyword</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_CDIMM_VPD_SUPPLIER_TOTAL_POWER_SLOPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_CDIMM_VPD_SUPPLIER_TOTAL_POWER_SLOPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Supplier Total Power Intercept that comes from the VPD MV Keyword</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_CDIMM_VPD_SUPPLIER_TOTAL_POWER_INTERCEPT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_CDIMM_VPD_SUPPLIER_TOTAL_POWER_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>FOR LAB USE ONLY: Frequency override of this memory channel in MHz, comprising of up to three DIMMs. Set by config file or an attribute writing program. Consumed by mss_freq. The default of AUTO means mss_freq will find the best frequencies given the DIMMs plugged in and other rules. Otherwise, this is the system frequency. firmware notes: Platforms should initialize this attribute to AUTO (0)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MSS_FREQ_OVERRIDE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MSS_FREQ_OVERRIDE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Training Control over IPL - ENUM - 0x00=DISABLE /Skip V-ref Train; 0x01=DRAM - Enable V-Ref Train DRAM Level; 0x02=RANK Level Training; 0x03=PORT Level Training; 0x04=MBA Level; 0x05=CENTAUR level; Default Value = 0x03 for OpenPower platforms = 0x01 for others (TULETA, BRAZOS, ALPINE).</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MSS_VREF_CAL_CNTL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MSS_VREF_CAL_CNTL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>DRAM Write Vref. Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT) or mss_eff_cnfg_termination consumer: various.C and initfile firmware notes: none This is the nominal value This is for DDR3</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_EFF_DRAM_WR_VREF</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_EFF_DRAM_WR_VREF</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint32_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Centaur DQ and DQS Drive Impedance Used in various locations and comes from the MT Keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT)/mss_eff_cnfg_termination consumer: initfile,various.C files firmware notes: none This is the nominal value</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_EFF_CEN_DRV_IMP_DQ_DQS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_EFF_CEN_DRV_IMP_DQ_DQS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Centaur DQ and DQS Receiver Impedance Used in various locations and it comes from the VPD MT keyword for custom DIMMs or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD, mss_eff_cnfg_termination Consumer: initfile + C code firmware notes: none This is the nominal value</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_EFF_CEN_RCV_IMP_DQ_DQS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_EFF_CEN_RCV_IMP_DQ_DQS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Centaur DQ and DQS Slew Rate Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Slowest slew rate is 0, incrementing by one. The lower the number the slower the slew rate the higher the faster. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT), mss_eff_cnfg_termination consumer: initfiles,various.C firmware notes: none This is the nominal value</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_EFF_CEN_SLEW_RATE_DQ_DQS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_EFF_CEN_SLEW_RATE_DQ_DQS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Centaur Read Vref. Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Creator: VPD(MT) or mss_eff_cnfg_termination consumer: various.C and initfiles firmware notes: none This is the nominal value</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_EFF_RD_VREF</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_EFF_RD_VREF</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint32_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Machine Readable Workbook safe mode throttle value for numerator cfg_nm_n_per_mba</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MRW_SAFEMODE_MEM_THROTTLE_NUMERATOR_PER_MBA</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MRW_SAFEMODE_MEM_THROTTLE_NUMERATOR_PER_MBA</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook safe mode throttle value for numerator cfg_nm_n_per_chip</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MRW_SAFEMODE_MEM_THROTTLE_NUMERATOR_PER_CHIP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MRW_SAFEMODE_MEM_THROTTLE_NUMERATOR_PER_CHIP</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook Thermal Memory Power Limit</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MRW_THERMAL_MEMORY_POWER_LIMIT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MRW_THERMAL_MEMORY_POWER_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>At a system level, this attribute controls if interleaving is required, requested or never. The MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MRW_MBA_CACHELINE_INTERLEAVE_MODE_CONTROL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MRW_MBA_CACHELINE_INTERLEAVE_MODE_CONTROL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Reflects the functionality of the L4 Cache. Determines if the L4 is enabled or not. See chapter 6 of the Centaur Workbook. On means the full cache is enabled. HALF_A (EVEN) means only A is enabled and HALF_B (ODD) means only B is enabled. For DD1X, the values of UNK_OFF, UNK_ON, UNK_HALF_A and UNK_HALFB were added because early parts did not have the fuses blown correctly, so the cache repairs may not have worked. This value is set by the platform which can get the chips value by running the mss_cen_get_ecid function. Note: Cronus and Firmware plus our initfiles do not really support any of the UNK values. It is the responsibility of the platform to map the UNK values to the appropriate value of OFF/ON/HALF_A/HALF_B</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MSS_CACHE_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MSS_CACHE_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of on or off. Determines if prefetching enabled or not. See chapter 7 of the Centaur Workbook.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MSS_PREFETCH_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MSS_PREFETCH_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of on or off. Determines if the cleaner of the L4 cache (write modified entries to memory on idle cycles) enabled or not. See chapter 7 of the Centaur Workbook.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MSS_CLEANER_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MSS_CLEANER_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>A disable switch for resetting the phy delay values at the beginning of calling mss_draminit_training.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MSS_DRAMINIT_RESET_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MSS_DRAMINIT_RESET_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>When this value is true, then mss_eff config will allow a single port to have one dimm and will allow ports to have different sizes. Used in eff_config</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MSS_ALLOW_SINGLE_PORT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MSS_ALLOW_SINGLE_PORT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>DQS Swizzle type is set by the platform to describe what kind of DQS connection is being used for register acceses. Type 0 is normal, type 1 is for systems with wiring like glacier 1, type 2 is for Pallmeto. Additional types maybe defined if new boards have even different DQS swizzle features</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MSS_DQS_SWIZZLE_TYPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MSS_DQS_SWIZZLE_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook DIMM power curve percent uplift for this system at max utilization.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook DIMM power curve percent uplift for this system at idle utilization.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook throttle value for denominator cfg_nm_m</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MRW_MEM_THROTTLE_DENOMINATOR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MRW_MEM_THROTTLE_DENOMINATOR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook value for maximum dram data bus utilization in centi percent (c%). Used to determine memory throttle values.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MRW_MAX_DRAM_DATABUS_UTIL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MRW_MAX_DRAM_DATABUS_UTIL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>The MRW for a system should set this to TRUE for systems that must obey plug rules. Lab environments should default this to off and allow the user to override using normal methods to test.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MRW_STRICT_MBA_PLUG_RULE_CHECKING</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MRW_STRICT_MBA_PLUG_RULE_CHECKING</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Used for Custom DIMMs to not enable the reading of the dimm temperature sensor on the master i2c bus</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MRW_CDIMM_MASTER_I2C_TEMP_SENSOR_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MRW_CDIMM_MASTER_I2C_TEMP_SENSOR_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Used for Custom DIMMs to not enable the reading of the dimm temperature sensor on the spare i2c bus</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MRW_CDIMM_SPARE_I2C_TEMP_SENSOR_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MRW_CDIMM_SPARE_I2C_TEMP_SENSOR_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Possible DRAM voltage override.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MSS_VOLT_OVERRIDE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MSS_VOLT_OVERRIDE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>List of Voltages that are compliant with the system. DIMMs that do not have voltages listed in their SPD as supported are errored out. Procedure defined is currently 1.2V and 1.35V only.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MSS_VOLT_COMPLIANT_DIMMS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MSS_VOLT_COMPLIANT_DIMMS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Capable power control settings. In MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MRW_POWER_CONTROL_REQUESTED</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MRW_POWER_CONTROL_REQUESTED</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>ISDIMM DQ mapping that comes from QX keyword on the CDIMM VPD.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_ISDIMMTOC4DQ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_ISDIMMTOC4DQ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4,80</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>ISDIMM DQQ mapping that comes from QS keyword on the CDIMM VPD.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_VPD_ISDIMMTOC4DQS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_VPD_ISDIMMTOC4DQS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4,20</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook value detailing the wiring of the 8 dimm temperature sensors for non custom dimms, in DIMM A0,A1,B0,B1,C0,C1,D0,D1 order. One nibble per sensor where bit0 (MSB) is the i2c bus the sensor is attached to (0 for master, 1 for spare) and bits 1:3 are for A2,A1,A0 of the sensor i2c address (where A2 is MSB)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MRW_MEM_SENSOR_CACHE_ADDR_MAP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MRW_MEM_SENSOR_CACHE_ADDR_MAP</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook enablement of the HWP code to adjust the VMEM regulator power limit based on number of installed DIMMs.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook value for the maximum possible number of dimms that can be installed under any of the VMEM regulators.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook DDR3 VMEM regulator power limit per CDIMM assuming a full configuration. Units in cW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook DDR4 VMEM regulator power limit per CDIMM assuming a full configuration. Units in cW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR4</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR4</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook attribute that holds the step size of the VREF when doing a box shmoo</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MRW_WR_VREF_CHECK_VREF_STEP_SIZE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CEN_MRW_WR_VREF_CHECK_VREF_STEP_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Value to select amount of margin to be applied.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_DMI_CEN_TX_MARGIN_RATIO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_DMI_CEN_TX_MARGIN_RATIO</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Value to select amount of tx ffe postcusor to apply.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_IO_DMI_CEN_TX_FFE_POSTCURSOR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IO_DMI_CEN_TX_FFE_POSTCURSOR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Attribute indicating the target's class</description>
    <hasStringConversion />
    <id>CLASS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <enumeration>
        <id>CLASS</id>
      </enumeration>
    </simpleType>
  </attribute>
  <attribute>
    <description>Attribute indicating the target's type</description>
    <hasStringConversion />
    <id>TYPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <enumeration>
        <id>TYPE</id>
      </enumeration>
    </simpleType>
  </attribute>
  <attribute>
    <description>Attribute indicating the target's model</description>
    <hasStringConversion />
    <id>MODEL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <enumeration>
        <id>MODEL</id>
      </enumeration>
    </simpleType>
  </attribute>
  <attribute>
    <description>Attribute indicating the target's engine type</description>
    <hasStringConversion />
    <id>ENGINE_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <enumeration>
        <id>ENGINE_TYPE</id>
      </enumeration>
    </simpleType>
  </attribute>
  <attribute>
    <description>Define context for current phase of system IPL.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_SYSTEM_IPL_PHASE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>SYSTEM_IPL_PHASE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x01</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Dummy platInit uint8[1][3][5] attribute used for testing.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_DUMMY_SCRATCH_PLAT_INIT_UINT8</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>DUMMY_RW</id>
    <ignoreEkb />
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>1,3,5</array>
      <uint8_t>
        <default>5</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Dummy attribute with write-only permissions</description>
    <id>DUMMY_WO</id>
    <persistency>non-volatile</persistency>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Dummy attribute with read-only permissions</description>
    <id>DUMMY_RO</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Hierarchical path to the target with respect to power</description>
    <id>POWER_PATH</id>
    <nativeType>
      <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <complexType>
      <description>Structure which defines a target's primary capabilities. A target can only support at most FSI SCOM and one of the other two SCOM types. Applicable for all targets. Structure is read-only.</description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Target does not support FSI SCOM; 0b1: Target supports FSI SCOM</description>
        <name>supportsFsiScom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Target does not support XSCOM; 0b1: Target supports FSI XSCOM</description>
        <name>supportsXscom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Target does not support inband SCOM</description>
        <name>supportsInbandScom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>5</bits>
        <default>0</default>
        <description>Reserved for future use</description>
        <name>reserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Attribute which describes capabilities of a target</description>
    <id>PRIMARY_CAPABILITIES</id>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <description>CPU Attribute</description>
    <id>CPU_ATTR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <complexType>
      <description>FSI flags</description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Set on FSI master chips (procs) if that chip uses slaveB to attach to the acting master chip.</description>
        <name>flipPort</name>
        <type>uint16_t</type>
      </field>
      <field>
        <bits>15</bits>
        <default>0</default>
        <description>Reserved for future expansion</description>
        <name>reserved</name>
        <type>uint16_t</type>
      </field>
    </complexType>
    <description>Reserved for any special flags we might need to access FSI</description>
    <id>FSI_OPTION_FLAGS</id>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <description>HardWare Availability Service State Changed Attribute. Keeps track of changedSinceChecked state, indicates if the target has changed since last checked by the appropriate service. This is a bit field of flags (see HWAS_CHANGED_BIT enumeration that follows).</description>
    <id>HWAS_STATE_CHANGED_FLAG</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0x0</default>
      </uint64_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>HardWare Availability Service State Changed Mask. Used when a target changes (ie, via HCDB change) to set the HWAS_STATE_CHANGED_FLAG, so that the appropriate services will all handle the change. This is a bit field of flags (see HWAS_CHANGED_BIT enumeration that follows).</description>
    <id>HWAS_STATE_CHANGED_SUBSCRIPTION_MASK</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0x0</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <complexType>
      <description>Numeric POD type test structure</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path for testing purposes</description>
        <name>fsiPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>CHIP</default>
        <description>Class for testing purposes</description>
        <name>className</name>
        <type>CLASS</type>
      </field>
      <field>
        <default>0xAB</default>
        <description>Test uint8</description>
        <name>uint8</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xABCD</default>
        <description>Test uint16</description>
        <name>uint16</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xABCDEF01</default>
        <description>Test uint32</description>
        <name>uint32</name>
        <type>uint32_t</type>
      </field>
      <field>
        <default>0xABCDEF0123456789</default>
        <description>Test uint64</description>
        <name>uint64</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>-124</default>
        <description>Test int8</description>
        <name>int8</name>
        <type>int8_t</type>
      </field>
      <field>
        <default>-32764</default>
        <description>Test int16</description>
        <name>int16</name>
        <type>int16_t</type>
      </field>
      <field>
        <default>-2147483644</default>
        <description>Test int32</description>
        <name>int32</name>
        <type>int32_t</type>
      </field>
      <field>
        <default>-9223372036854775804</default>
        <description>Test int64</description>
        <name>int64</name>
        <type>int64_t</type>
      </field>
    </complexType>
    <description>Attribute which tests numeric POD types</description>
    <id>NUMERIC_POD_TYPE_TEST</id>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <description>If the Target is directly deconfigurable and GARDable; target may still be deconfigured in 'by association' processing.</description>
    <id>DECONFIG_GARDABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <complexType>
      <description>Structure to define the addressing for an I2C slave device.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x02</default>
        <description>The number of bytes a device requires to set its internal address/offset. DDR4 DIMMs require a special EEPROM page switching mechanic denoted here by a value of 1 0 = Zero Byte Addressing 1 = One Byte Addressing with page select 2 = Two Byte Addressing 3 = OneByte Addressing with no page select</description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The number of kilobytes a device can hold. 'Zero' value possible for some devices.</description>
        <name>maxMemorySizeKB</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x01</default>
        <description>The number of chips making up an eeprom device.</description>
        <name>chipCount</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The maximum number of bytes that can be written to a device at one time. 'Zero' value means no maximum value is expected or checked.</description>
        <name>writePageSize</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xA</default>
        <description>The amount of time in milliseconds a device requires on the completion of a write command to update its internal memory.</description>
        <name>writeCycleTime</name>
        <type>uint64_t</type>
      </field>
    </complexType>
    <description>Information needed to address the EEPROM slaves</description>
    <id>EEPROM_VPD_PRIMARY_INFO</id>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <complexType>
      <description>Structure to define the addressing for an I2C slave device.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x02</default>
        <description>The number of bytes a device requires to set its internal address/offset.</description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The number of kilobytes a device can hold. 'Zero' value possible for some devices.</description>
        <name>maxMemorySizeKB</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x01</default>
        <description>The number of chips making up an eeprom device.</description>
        <name>chipCount</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The maximum number of bytes that can be written to a device at one time. 'Zero' value means no maximum value is expected or checked.</description>
        <name>writePageSize</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xA</default>
        <description>The amount of time in milliseconds a device requires on the completion of a write command to update its internal memory.</description>
        <name>writeCycleTime</name>
        <type>uint64_t</type>
      </field>
    </complexType>
    <description>Information needed to address the EERPROM slaves</description>
    <id>EEPROM_VPD_BACKUP_INFO</id>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <complexType>
      <description>Structure to define the addressing for an I2C slave device.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x02</default>
        <description>The number of bytes a device requires to set its internal address/offset.</description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x100</default>
        <description>The number of kilobytes a device can hold. 'Zero' value possible for some devices.</description>
        <name>maxMemorySizeKB</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x04</default>
        <description>The number of chips making up an eeprom device.</description>
        <name>chipCount</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The maximum number of bytes that can be written to a device at one time. 'Zero' value means no maximum value is expected or checked.</description>
        <name>writePageSize</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The amount of time in milliseconds a device requires on the completion of a write command to update its internal memory.</description>
        <name>writeCycleTime</name>
        <type>uint64_t</type>
      </field>
    </complexType>
    <description>Information needed to address the EERPROM slaves</description>
    <id>EEPROM_SBE_PRIMARY_INFO</id>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <complexType>
      <description>Structure to define the addressing for an I2C slave device.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x02</default>
        <description>The number of bytes a device requires to set its internal address/offset.</description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x100</default>
        <description>The number of kilobytes a device can hold. 'Zero' value possible for some devices.</description>
        <name>maxMemorySizeKB</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x04</default>
        <description>The number of chips making up an eeprom device.</description>
        <name>chipCount</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The maximum number of bytes that can be written to a device at one time. 'Zero' value means no maximum value is expected or checked.</description>
        <name>writePageSize</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The amount of time in milliseconds a device requires on the completion of a write command to update its internal memory.</description>
        <name>writeCycleTime</name>
        <type>uint64_t</type>
      </field>
    </complexType>
    <description>Information needed to address the EERPROM slaves</description>
    <id>EEPROM_SBE_BACKUP_INFO</id>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <complexType>
      <description>Structure to define the addressing for an I2C slave device.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Information needed to address an I2C slave device</description>
    <id>TEMP_SENSOR_I2C_CONFIG</id>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <complexType>
      <description>Structure to define the addressing for an I2C TPM.</description>
      <field>
        <default>0x0</default>
        <description>Boolean indicating whether this TPM is available in the system</description>
        <name>tpmEnabled</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x01</default>
        <description>Port from the I2C Master device. This is a 6-bit value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xAE</default>
        <description>Device address on the I2C bus for Locality 0. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddrLocality0</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xA8</default>
        <description>Device address on the I2C bus for Locality 1. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddrLocality1</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xAA</default>
        <description>Device address on the I2C bus for Locality 2. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddrLocality2</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xA4</default>
        <description>Device address on the I2C bus for Locality 3. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddrLocality3</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xA6</default>
        <description>Device address on the I2C bus for Locality 4. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddrLocality4</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x00</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x01</default>
        <description>The number of bytes a device requires to set its internal address/offset.</description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Information needed to address the TPM slaves</description>
    <id>TPM_INFO</id>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <description>A unit's position within the chip with respect to similar units. Note that this value is relative to the parent chip, not a parent unit. This data is from the MRW.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_CHIP_UNIT_POS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>CHIP_UNIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines a negative percentage value that is applied to the ATTR_NOMINAL_FREQ_MHZ determined from MVPD #V. It is used to explicitly raise the value of MIN_FREQ_MHZ above what is specified by MVPD #V data. On FSP systems this is sourced from the power_management def file. Value must be between 0 and -100. A value of zero indicates no override.</description>
    <id>DPO_MIN_FREQ_PERCENT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <int32_t>
        <default>0</default>
      </int32_t>
      <range>
        <max>0</max>
        <min>-100</min>
      </range>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <complexType>
      <description>Structure which defines a system's SP functions. Applicable for System target only. Structure is read-only.</description>
      <field>
        <bits>1</bits>
        <default>1</default>
        <description>If this flag is set then mailboxEnabled MUST also be set 0b0: SP does not support for VPD, payload, ATTR sync, VDDR, TOD; 0b1: SP supports VPD, payload, ATTR sync, VDDR, TOD</description>
        <name>baseServices</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>1</default>
        <description>0b0: SP does not initialize FSI slave logic, Hostboot must; 0b1: SP does initialize FSI slave logic so Hostboot should not</description>
        <name>fsiSlaveInit</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: There is no SP mailbox support; 0b1: There is SP mailbox support</description>
        <name>mailboxEnabled</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>1</default>
        <description>0b0: SP does not initialize FSI master logic, Hostboot must; 0b1: SP does initialize FSI master logic so Hostboot should not</description>
        <name>fsiMasterInit</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>1</default>
        <description>0b0: SP does not perform hardware change detection, Hostboot must; 0b1: SP does perform hardware change detection (HCDB) so Hostboot should not</description>
        <name>hardwareChangeDetection</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>1</default>
        <description>0b0: SP does not perform Power Line Disturbance (PLD) detection, Hostboot must; 0b1: SP does perform Power Line Disturbance (PLD) detection so Hostboot should not</description>
        <name>powerLineDisturbance</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>26</bits>
        <default>0</default>
        <description>Reserved for future use</description>
        <name>reserved</name>
        <type>uint32_t</type>
      </field>
    </complexType>
    <description>Attribute which describes what the SP is or is not doing in this system</description>
    <id>SP_FUNCTIONS</id>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <complexType>
      <description>Structure which defines a system's HB settings. Applicable for System target only.</description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Enable / Disable continuous trace. 0b0: Continuous trace is disabled. 0b1: Continuous trace is enabled.</description>
        <name>traceContinuous</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Override trace debug selection for SCAN component. 0b0: TRACS entries for SCAN have default behavior. 0b1: TRACS entries for SCAN are enabled.</description>
        <name>traceScanDebug</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Override trace debug selection for DBG component. 0b0: TRACS entries for DBG have default behavior. 0b1: TRACS entries for DBG are enabled.</description>
        <name>traceFapiDebug</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>5</bits>
        <default>0</default>
        <description>Reserved for future use</description>
        <name>reserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Attribute which describes how the SP has configured features in Hostboot.</description>
    <id>HB_SETTINGS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <writeable />
  </attribute>
  <attribute>
    <description>Peer target's address of a A/X-bus connection. NULL means address 0 for no peer target. If a target instance overrides the default with the peer target's PHYS_PATH. The target compiler will convert the valid PHYS_PATH string into the runtime virtual address of the peer target instance.</description>
    <id>PEER_TARGET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <Target_t>
        <default>NULL</default>
      </Target_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Attribute indicating what kind of payload is to be started.</description>
    <hasStringConversion />
    <id>PAYLOAD_KIND</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <enumeration>
        <id>PAYLOAD_KIND</id>
      </enumeration>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>System XSCOM base address</description>
    <id>XSCOM_BASE_ADDRESS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>MCS Inband Scom base address</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MCS_INBAND_BASE_ADDRESS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>IBSCOM_MCS_BASE_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0x0003E00000000000</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>PROC Inband Scom base address</description>
    <id>IBSCOM_PROC_BASE_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0x0003E00000000000</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Indicate that payload should be placed in mirrored memory. Set by the FSP based on the value of the registry key indicating the memory mirroring mode.</description>
    <id>PAYLOAD_IN_MIRROR_MEM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>NPU MMIO BAR base address values creator: platform consumer: proc_setup_bars firmware notes: 64-bit address representing BAR RA NOTE: BAR register covers RA 14:51 first dimension: unit number (0:3) second dimension: BAR number (0:1)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_NPU_MMIO_BAR_BASE_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>NPU_MMIO_BAR_BASE_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4,2</array>
      <uint64_t>
        <default>0</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>NPU MMIO BAR size values creator: platform consumer: proc_setup_bars firmware notes: none first dimension: unit number (0:3) second dimension: BAR number (0:1)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_NPU_MMIO_BAR_SIZE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>NPU_MMIO_BAR_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4,2</array>
      <uint64_t>
        <default>0</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Base Address of FSP IO Region</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FSP_BAR_BASE_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>FSP_BASE_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0x0003FFE000000000</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Size of FSP IO Region</description>
    <id>FSP_BAR_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0x0000000100000000</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Base Address of PHB Register Space</description>
    <id>PHB_BASE_ADDRS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint64_t>
        <default>0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Base Address of PCI 64 bit Memory Space</description>
    <id>PCI_BASE_ADDRS_64</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Base Address of PCI 32 bit Memory Space</description>
    <id>PCI_BASE_ADDRS_32</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Base Address of RNG IO Region</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_NX_MMIO_BAR_BASE_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>RNG_BASE_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0xFFFFFFFFFFFFFFFF</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Size of RNG IO Region</description>
    <id>RNG_BAR_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0x000000000001000</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Base Address of In-Memory Trace Region Set by FSP-based tooling</description>
    <id>IMT_BASE_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0xFFFFFFFFFFFFFFFF</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Size of IMT IO Region Set by FSP-based tooling</description>
    <id>IMT_BAR_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0x0000000000000000</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Memory AVDD voltage domain ID. All memory buffers in the same AVDD voltage domain will share the same ID. IDs are arbitrarily assigned, used for correlation between HB + HWSV, and are generated by genHwsvMrwXml.pl</description>
    <id>AVDD_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Memory VDD voltage domain ID. All memory buffers in the same VDD voltage domain will share the same ID. IDs are arbitrarily assigned, used for correlation between HB + HWSV, and are generated by genHwsvMrwXml.pl</description>
    <id>VDD_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Memory VCS voltage domain ID. All memory buffers in the same VCS voltage domain will share the same ID. IDs are arbitrarily assigned, used for correlation between HB + HWSV, and are generated by genHwsvMrwXml.pl</description>
    <id>VCS_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Memory VPP voltage domain ID. All memory buffers in the same VPP voltage domain will share the same ID. IDs are arbitrarily assigned, used for correlation between HB + HWSV, and are generated by genHwsvMrwXml.pl</description>
    <id>VPP_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Nest VDDR Voltage Rail ID. The ID is an arbitrary value and is needed as correlation token between HB and HWSV. It will be generated by the genHwsvMrwXml.pl</description>
    <id>NEST_VDDR_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Nest VIO Voltage Rail ID. The ID is an arbitrary value and is needed as correlation token between HB and HWSV. It will be generated by the genHwsvMrwXml.pl</description>
    <id>NEST_VIO_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Nest VDD Voltage Rail ID. The ID is an arbitrary value and is needed as correlation token between HB and HWSV. It will be generated by the genHwsvMrwXml.pl</description>
    <id>NEST_VDD_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Nest VDN Voltage Rail ID. The ID is an arbitrary value and is needed as correlation token between HB and HWSV. It will be generated by the genHwsvMrwXml.pl</description>
    <id>NEST_VDN_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Nest VCS Voltage Rail ID. The ID is an arbitrary value and is needed as correlation token between HB and HWSV. It will be generated by the genHwsvMrwXml.pl</description>
    <id>NEST_VCS_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>VDDR memory programming type 0 = POWERON - domain is programmed as part of regular power on sequence, 1 = STATIC - domain needs to be programmed, no special computation needed, 2 = DYNAMIC - domain needs to be programmed, uses dynamic vid logic</description>
    <hasStringConversion />
    <id>MSS_VDDR_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>VPP memory programming type 0 = POWERON - domain is programmed as part of regular power on sequence, 1 = STATIC - domain needs to be programmed, no special computation needed, 2 = DYNAMIC - domain needs to be programmed, uses dynamic vid logic</description>
    <hasStringConversion />
    <id>MSS_VPP_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>VCS memory programming type 0 = POWERON - domain is programmed as part of regular power on sequence, 1 = STATIC - domain needs to be programmed, no special computation needed, 2 = DYNAMIC - domain needs to be programmed, uses dynamic vid logic</description>
    <hasStringConversion />
    <id>MSS_VCS_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>AVDD memory programming type 0 = POWERON - domain is programmed as part of regular power on sequence, 1 = STATIC - domain needs to be programmed, no special computation needed, 2 = DYNAMIC - domain needs to be programmed, uses dynamic vid logic</description>
    <hasStringConversion />
    <id>MSS_AVDD_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>VDD memory programming type 0 = POWERON - domain is programmed as part of regular power on sequence, 1 = STATIC - domain needs to be programmed, no special computation needed, 2 = DYNAMIC - domain needs to be programmed, uses dynamic vid logic</description>
    <hasStringConversion />
    <id>MSS_VDD_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>System attribute. The max EX units per proc chip available in the system.</description>
    <id>MAX_EXS_PER_PROC_CHIP</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>System attribute. The max DIMMs per MBA Port available in the system.</description>
    <id>MAX_DIMMS_PER_MBA_PORT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>System attribute. The max MBA ports per MBA available in the system.</description>
    <id>MAX_MBA_PORTS_PER_MBA</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>System attribute. The max MBAS per membuf available in the system.</description>
    <id>MAX_MBAS_PER_MEMBUF_CHIP</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>System attribute. The max chiplets per proc available in the system.</description>
    <id>MAX_CHIPLETS_PER_PROC</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Attribute to test signed attribute functionality in the system</description>
    <id>TEST_NEGATIVE_FCN</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <int8_t>
        <default>-6</default>
      </int8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>FRU ID attribute used to report FRU information to the BMC for each fru in the system.</description>
    <global />
    <id>FRU_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>BMC FRU ID attribute to report the system firmware levels to the BMC.</description>
    <id>BMC_FRU_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>FRU ID attribute for centaur ECID data. This fru ID is used to report the ECID data to the BMC and make it available for systems which have then centaur chips soldered to the backplane.</description>
    <id>CENTAUR_ECID_FRU_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Set to 1 by HWSV to indicate that attribute overrides exist in a PLCK IPL (not an IPL by steps). This is read by Hostboot to determine if it needs to request the attribute overrides from HWSV before starting its IPL.</description>
    <id>PLCK_IPL_ATTR_OVERRIDES_EXIST</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Cec Degraded Mode Policy flags Use the CDM_POLICIES enum to decode. If the appropriate bit is 1 then the policy mode is enabled, and those type of Guard records are disabled.</description>
    <id>CDM_POLICIES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Field Core Override (FCO) is the override value for the number of functional cores allowed on the system. FCO is used when customers order a system with N cores but they only want to enable less than N cores to lower software license costs. A field in the anchor VPD is set by manufacturing to specify the maximum number of cores to enable. The number is maintained, even if some cores are garded out due to error. A value of 0 means all cores allowed;</description>
    <id>FIELD_CORE_OVERRIDE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Value of the next PLID that host service should send</description>
    <id>HOSTSVC_PLID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x89000000</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Policy indicating whether to perform the maximum amount of memory pattern testing possible or not. Set to 0x01 to perform the maximum amount of memory pattern testing possible. Set to 0x00 to perform the default amount of memory pattern testing.</description>
    <id>RUN_MAX_MEM_PATTERNS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Holds the effective EC of the system. Effective EC is the lowest EC among all the functional procs in the system. Some cards may "downbin" the effective ECs of their contained processors, which could lower the effective EC of the system beyond what would occur when considering processor ECs alone</description>
    <id>EFFECTIVE_EC</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x10</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>The amount of mainstore that PHYP needs to preserve per node during MPIPL.</description>
    <id>HB_RSV_MEM_SIZE_MB</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>256</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Indicates if system should consider abus logic when deconfiguring in _deconfigureAssocProc(), will be overwritten on multi-node system</description>
    <id>DO_ABUS_DECONFIG</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Units: uV/Membuf</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_AVDD_SLOPE_ACTIVE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_CENT_AVDD_SLOPE_ACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Units: uV/Membuf</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_AVDD_SLOPE_INACTIVE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_CENT_AVDD_SLOPE_INACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Units: mV</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_AVDD_SLOPE_INTERCEPT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MSS_CENT_AVDD_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Units: uV/Membuf</description>
    <id>MSS_CENT_VDD_SLOPE_ACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Units: uV/Membuf</description>
    <id>MSS_CENT_VDD_SLOPE_INACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Units: mV</description>
    <id>MSS_CENT_VDD_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Units: uV/Membuf</description>
    <id>MSS_CENT_VCS_SLOPE_ACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Units: uV/Membuf</description>
    <id>MSS_CENT_VCS_SLOPE_INACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Units: mV</description>
    <id>MSS_CENT_VCS_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Units: uV/DRAM</description>
    <id>MSS_VOLT_VPP_SLOPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Units: mV</description>
    <id>MSS_VOLT_VPP_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Units: uV/DRAM</description>
    <id>MSS_VOLT_VPP_SLOPE_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Units: mV</description>
    <id>MSS_VOLT_VPP_INTERCEPT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Units: 1/Amps</description>
    <id>MSS_VOLT_DDR3_VDDR_SLOPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Units: mV</description>
    <id>MSS_VOLT_DDR3_VDDR_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Maximum voltage limit for the dynamic VID DDR3 VDDR voltage setpoint. In mV.</description>
    <id>MRW_DDR3_VDDR_MAX_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Units: 1/Amps</description>
    <id>MSS_VOLT_DDR3_VDDR_SLOPE_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Units: mV</description>
    <id>MSS_VOLT_DDR3_VDDR_INTERCEPT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Maximum voltage limit for the dynamic VID DDR3 VDDR voltage setpoint. In mV.</description>
    <id>MRW_DDR3_VDDR_MAX_LIMIT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Units: 1/Amps</description>
    <id>MSS_VOLT_DDR4_VDDR_SLOPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Units: mV</description>
    <id>MSS_VOLT_DDR4_VDDR_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Maximum voltage limit for the dynamic VID DDR4 VDDR voltage setpoint. In mV.</description>
    <id>MRW_DDR4_VDDR_MAX_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Units: 1/Amps</description>
    <id>MSS_VOLT_DDR4_VDDR_SLOPE_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Units: mV</description>
    <id>MSS_VOLT_DDR4_VDDR_INTERCEPT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Maximum voltage limit for the dynamic VID DDR4 VDDR voltage setpoint. In mV.</description>
    <id>MRW_DDR4_VDDR_MAX_LIMIT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Effective PCIE IOP reversal configuration Creator: Firmware Purpose: Holds the effective PCIE IOP reversal value after taking into account any IOP bifurcations. If no IOP bifurcations present, this is just the value of the PROC_PCIE_IOP_REVERSAL_NON_BIFURCATED attribute. Data Format: x4 array of uint8_t values. The first uint8_t value is for lane set 0, the second for lane set 1 and so on. The given index in the array is a mask which specifies which bit to invert in the lane swap settings for the given PEC/lane set.</description>
    <id>PEC_PCIE_IOP_REVERSAL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Base PCIE IOP reversal configuration Creator: Firmware Purpose: Holds the base PCIE IOP reversal value without considering IOP bifurcation. Data Format: x4 array of uint8_t values. The first uint8_t value is for lane set 0, the second for lane set 1 and so on. The given index in the array is a mask which specifies which bit to invert in the lane swap settings for the given lane set.</description>
    <id>PEC_PCIE_IOP_REVERSAL_NON_BIFURCATED</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Base PCIE IOP reversal configuration Creator: Firmware Purpose: Holds the PCIE IOP reversal value for cases where the IOP is bifurcated Data Format: x4 array of uint8_t values. The first uint8_t value is lane set 0, the second for lane set 2 and so on. The given index in the array is a mask which specifies which bit to invert in the lane swap settings for the given lane set</description>
    <id>PEC_PCIE_IOP_REVERSAL_BIFURCATED</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Bifurcated PCIE IOP swap configuration value Creator: MRW Purpose: Holds the base IOP swap configuration value for the IOPs in the case where they are bifurcated. The swap value controls how PCIE lanes are recordered when the leave the IOP, to provide lane routing flexibility. Data Format: A uint8_t value. The value specifices for the hardware how to swap the PCIE lanes for the given PEC.</description>
    <id>PEC_PCIE_IOP_SWAP_BIFURCATED</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>PCIE Lane Mask bifurcated configuration Creator: MRW Purpose: Holds the PCIE lane mask assuming IOPs are bifurcated. Data Format: x4 array of uint16_t values. The first uint8_t value is lane set 0, the second for lane set 2 and so on. A lane set mask indicates which groups of lanes are assigned to an IOP. For instance, lane set 0 value of 0xFF00 and lane set 1 value of 0x00FF means the IOP is bifurcated into two x8s.</description>
    <id>PEC_PCIE_LANE_MASK_BIFURCATED</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Indicates whether PCIE lanes terminate at a pluggable slot Creator: MRW Purpose: Used by FW to know whether the given PCIE lanes terminate at a pluggable slot or not. If this is the case, and the platform supports bifurcation, the card's VPD should be interrogated to determine whether to bifurcate the IOP or not. Data Format: x4 array of uint8_t values. The first value indicates whether lane set 0 terminates at a pluggable slot. The next three values indicate the same for lane sets 1-3. A value of 1 at a given array index indicates the lanes terminate at a pluggable slot, 0 otherwise.</description>
    <id>PROC_PCIE_IS_SLOT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Specifies a target's CEC degraded mode domain. For example, all DIMMs are part of the DIMM CEC degraded mode domain.</description>
    <hasStringConversion />
    <id>CDM_DOMAIN</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <enumeration>
        <id>CDM_DOMAIN</id>
      </enumeration>
    </simpleType>
  </attribute>
  <attribute>
    <description>Setting to require(0x1) or not require(0x0) a functional TPM to boot the system.</description>
    <id>TPM_REQUIRED</id>
    <persistency>non-volatile</persistency>
    <range>
      <max>1</max>
      <min>0</min>
    </range>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L2 Cache CEs allowed during Manufacturing. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_P8EX_L2_CACHE_CES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L2 Directory CEs allowed during Manufacturing. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_P8EX_L2_DIR_CES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L3 Cache CEs allowed during Manufacturing. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_P8EX_L3_CACHE_CES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>3</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L3 Directory CEs allowed during Manufacturing. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_P8EX_L3_DIR_CES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L2 Line Deletes allowed in the Field. creator: platform (generated based on MRW data)</description>
    <id>FIELD_TH_P8EX_L2_LINE_DELETES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>6</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L3 Line Deletes allowed in the Field. creator: platform (generated based on MRW data)</description>
    <id>FIELD_TH_P8EX_L3_LINE_DELETES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>6</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L2 Column Repairs allowed in the Field. creator: platform (generated based on MRW data)</description>
    <id>FIELD_TH_P8EX_L2_COL_REPAIRS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>7</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L3 Column Repairs allowed in the Field. creator: platform (generated based on MRW data)</description>
    <id>FIELD_TH_P8EX_L3_COL_REPAIRS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>7</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L2 Line Deletes allowed during Manufacturing. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_P8EX_L2_LINE_DELETES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L3 Line Deletes allowed during Manufacturing. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_P8EX_L3_LINE_DELETES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L2 Column Repairs allowed during Manufacturing. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_P8EX_L2_COL_REPAIRS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Maximum number of L3 Column Repairs allowed during Manufacturing. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_P8EX_L3_COL_REPAIRS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Base threshold (for 2GB DRAM ) of Memory CEs allowed during runtime. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_CEN_MBA_RT_SOFT_CE_TH_ALGO</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the Base threshold (for 2GB DRAM ) of Memory CEs allowed during IPL. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_CEN_MBA_IPL_SOFT_CE_TH_ALGO</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the maximum number of Memory RCEs allowed per Rank during runtime. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_CEN_MBA_RT_RCE_PER_RANK</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the maximum number of L4 Cache CEs allowed. creator: platform (generated based on MRW data)</description>
    <id>MNFG_TH_CEN_L4_CACHE_CES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>With MNFG thresholds enabled, PRD will make a predictive callout when an RCD parity error (recovery enabled) attention count is equal to this value. A value of 0 defaults to the max threshold of 0xff.</description>
    <id>MNFG_TH_RCD_PARITY_ERRORS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>With MNFG thresholds enabled, PRD will make a predictive callout when a memory intermittent UE attention count is equal to this value. A value of 0 defaults to the max threshold of 0xff.</description>
    <id>MNFG_TH_MEMORY_IUES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>With MNFG thresholds enabled, PRD will make a predictive callout when a memory intermittent MPE attention count is equal to this value. A value of 0 defaults to the max threshold of 0xff.</description>
    <id>MNFG_TH_MEMORY_IMPES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>The number of reconfig loops allowed due to RCD parity errors when recovery is disabled. PRD will make a predictive callout and stop issuing reconfigs due to RCD parity errors when RCD_PARITY_RECONFIG_LOOP_COUNT is greater than this value. A value of 0 indicates that no reconfig loops are allowed due to RCD parity errors.</description>
    <id>RCD_PARITY_RECONFIG_LOOPS_ALLOWED</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>PRD will increment this count and issue a reconfig loop each time an RCD parity error (recovery disabled) is detected during Memory Diagnostics. This value will be cleared at the end of Memory Diagnostics if it is able to complete without the need to issue a reconfig loop.</description>
    <id>RCD_PARITY_RECONFIG_LOOP_COUNT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Used to tell if a resource is critical to perform an IPL. If this attribute is set to 1 and the target is deconfigured, the IPL MUST terminate.</description>
    <id>RESOURCE_IS_CRITICAL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>VAS - Hypervisor Window Contexts address MMIO consumed by PHYP</description>
    <id>VAS_HYPERVISOR_WINDOW_CONTEXT_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>VAS - User Window Context address MMIO consumed by PHYP</description>
    <id>VAS_USER_WINDOW_CONTEXT_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>LPC Bus address - MMIO consumed by PHYP</description>
    <id>LPC_BUS_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Nvidia Link - NPU Privileged Regs address MMIO consumed by PHYP</description>
    <id>NVIDIA_NPU_PRIVILEGED_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Nvidia Link - NPU User Regs address MMIO consumed by PHYP</description>
    <id>NVIDIA_NPU_USER_REG_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Nvidia Link - Phy 0 Regs address MMIO consumed by PHYP</description>
    <id>NVIDIA_PHY0_REG_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Nvidia Link - Phy 1 Regs address MMIO consumed by PHYP</description>
    <id>NVIDIA_PHY1_REG_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>NX - RNG space - MMIO consumed by PHYP</description>
    <id>NX_RNG_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Icache Line Size in bytes</description>
    <id>ICACHE_LINE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>ICache Block Size in bytes</description>
    <id>ICACHE_BLOCK_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>ICache Size in KB</description>
    <id>ICACHE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>ICache Assoc Sets</description>
    <id>ICACHE_ASSOC_SETS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>DCache Line Size in bytes</description>
    <id>DCACHE_LINE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>DCache Associative Sets</description>
    <id>DCACHE_ASSOC_SETS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>L2 Cache Line Size in bytes</description>
    <id>L2_CACHE_LINE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>L2 Cache Size in KB</description>
    <id>L2_CACHE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>L2 Cache Assoc Sets</description>
    <id>L2_CACHE_ASSOC_SETS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>L3 Cache Line Size in bytes</description>
    <id>L3_CACHE_LINE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>L3 Cache Size in KB</description>
    <id>L3_CACHE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Time Base frequency in MHZ</description>
    <id>TIME_BASE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x800000</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>TLB Data Entries</description>
    <id>TLB_DATA_ENTRIES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>TLB Data Associative Sets</description>
    <id>TLB_DATA_ASSOC_SETS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>TLB Instruction Entries</description>
    <id>TLB_INSTR_ENTRIES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>TLB Instruction Associative Sets</description>
    <id>TLB_INSTR_ASSOC_SETS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Reserve Size in bytes</description>
    <id>TLB_RESERVE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>L1 Data Cache Size in KB</description>
    <id>DATA_CACHE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>L1 Data Cache Line Size in bytes</description>
    <id>DATA_CACHE_LINE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Thread Count</description>
    <id>THREAD_COUNT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x4</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>System control to set the power limit for Workload Optimized Frequency (WOF) algorithms. This is used to select the proper VFRT tables. Producer: TMGT Consumers: FW that selects VFRT tables</description>
    <id>WOF_POWER_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>The address offset which each Chiplet types pervasive address space used to represent the a chiplet. 0x00 to 0x0F =&gt; For P9 all non-core and non-cache chiplets 0x10 to 0x1F =&gt; All Cache Chiplets 0x20 to 0x37 =&gt; All Core Chiplets 0x38 to 0x3F =&gt; Multicast Operation</description>
    <id>CHIPLET_ID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Do we support dynamically updating memory voltages? 0 = no, 1 = yes</description>
    <id>SUPPORTS_DYNAMIC_MEM_VOLT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>This field is of the form "vendor,name" where the name indicates the family of the systems. The textual portion of the string has a maximum length of 63 characters to accommodate a terminating NULL. Both vendor and name fields are lower case US ASCII. No special characters other than ",", "-", and "+" as described below should be used in the string.</description>
    <id>SYSTEM_FAMILY</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <string>
        <default>ibm,p9</default>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
  </attribute>
  <attribute>
    <description>This field is of the form ?vendor,type? where the type indicates a type of system within the System Family. The textual portion of the string has a maximum length of 63 characters to accommodate a terminating NULL. Both vendor and name fields are lower case US ASCII. No special characters other than ",", "-", and "+" as described below should be used in the string. If identification of specific models within a system type is desired, "-model" should be appended to the end of the name. The "-model" portion is optional and could be used to identify the packaging, specific model numbers, etc. NOTE: No Hostboot code should ever key off of this value.</description>
    <id>SYSTEM_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <string>
        <default>ibm,miscopenpower</default>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
  </attribute>
  <attribute>
    <description>STOP levels supported at runtime (sent to Host via HDAT): Bit 0: STOP0 Supported - Quiesce thread only Bit 1: STOP1 Supported - P8 Nap Bit 2: STOP2 Supported - P8 Fast Sleep Bit 3: STOP3 Supported - P8 Fast Sleep using iVRMs Bit 4: STOP4 supported - P8 Deep Sleep Bit 5: STOP5 Supported - WOF-friendly "Instant on" Bit 6,7: Reserved Bit 8: STOP8 supported - Half Quad Sleep Bit 9: STOP9 supported - P8 Fast Winkle Bit 10: Reserved Bit 11: STOP11 supported - P8 Deep Winkle Bit 12-15 : Reserved Bits 16..31 - Reserved</description>
    <id>SUPPORTED_STOP_STATES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x80000000</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>PCIE Lane Equalization values for each PHB Creator: MRW Purpose: Holds settings which are loaded into the HW to optimize the PCIE lane signal eye between the chips + PCIE Gen3 endpoints Data Format: 16 entries of 16 bytes of EQ data per PHB. Each PHB has an EQ value for each of its 16 lanes. Each value is a uint16 formatted as follows: Bit 0:3 - up_rx_hint (bit 0 reserved) Bit 4:7 - up_tx_preset Bit 8:11 - dn_rx_hint (bit 0 reserved) Bit 12:15 - dn_tx_preset</description>
    <id>PROC_PCIE_LANE_EQUALIZATION_GEN3</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>16</array>
      <uint16_t>
        <default>0x7777,0x7777,0x7777,0x7777, 0x7777,0x7777,0x7777,0x7777, 0x7777,0x7777,0x7777,0x7777, 0x7777,0x7777,0x7777,0x7777</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>PCIE Lane Equalization values for each PHB Creator: MRW Purpose: Holds settings which are loaded into the HW to optimize the PCIE lane signal eye between the chips + PCIE Gen4 endpoints Data Format: 16 entries of 16 bytes of EQ data per PHB. Each PHB has an EQ value for each of its 16 lanes. Each value is a uint16 formatted as follows: Bit 0:3 - up_rx_hint (bit 0 reserved) Bit 4:7 - up_tx_preset Bit 8:11 - dn_rx_hint (bit 0 reserved) Bit 12:15 - dn_tx_preset</description>
    <id>PROC_PCIE_LANE_EQUALIZATION_GEN4</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>16</array>
      <uint16_t>
        <default>0x7777,0x7777,0x7777,0x7777, 0x7777,0x7777,0x7777,0x7777, 0x7777,0x7777,0x7777,0x7777, 0x7777,0x7777,0x7777,0x7777</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Used to tell INTRP code whether to use the XIVE HW Reset or a software based reset. 0 = Software based reset 1 = XIVE HW reset</description>
    <id>XIVE_HW_RESET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Used to tell I2C code whether to run I2C Engine 2 Port 0 in diag mode or not 0 = Use Diag Mode 1 = Disable Diag Mode</description>
    <id>DISABLE_I2C_ENGINE2_PORT0_DIAG_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>SYSTEM Attribute Maximum frequency (binary in MHz) that any processor in the system will run. Used to define the top end of the PState range in the frequency space. From this, the ATTR_PROCPM_PSTATE0_FREQUENCY is computed using ATTR_SYSTEM_REFCLK_FREQUENCY to determine the step size. Consumers: proc_build_gpstate_table.C (among others) Data is is provided by MVPD #V and is calculated as the minimum of the turbo frequencies</description>
    <id>FREQ_CORE_MAX</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>The asynchronous nest frequency</description>
    <id>ASYNC_NEST_FREQ_MHZ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>2000</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>System Mirrorable base address</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MIRROR_BASE_ADDRESS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MIRROR_BASE_ADDRESS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0x0000800000000000</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>PCIE PHB valid mask creator: platform consumer: proc_pcie_scominit firmware notes: Bit mask defining set of active/valid PHBs bit0=PHB0, bit1=PHB1, bit2=PHB2, bit3=PHB3</description>
    <id>PROC_PCIE_PHB_ACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>creator: platform Number of PCIe PEC units present on target Nimbus: 3</description>
    <id>PROC_PCIE_NUM_PEC</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of PCS system control creator: platform consumer: p9_pcie_scominit firmware notes: These are config dependent attributes based on PCIe Lane/sideband signal routing and PCIe endpoints attached. There are four groups of four lanes: 0-3 (A-D), 4-7 (E-H), 8-11(I-L), and 12-15(M-P). Each lane group can be assigned to a MAC interface. The supported configurations are as follows: 1. MAC #1 = x16, MAC #2 = N/A, MAC #3 = N/A, MAC #4 = N/A : PCS_SYSTEM_CONTROL_REG = 0x0000. 2. MAC #1 = x8, MAC #2 = x8, MAC #3 = N/A, MAC #4 = N/A : PCS_SYSTEM_CONTROL_REG = 0x0050. 3. MAC #1 = x8, MAC #2 = x4, MAC #3 = x4, MAC #4 = N/A : PCS_SYSTEM_CONTROL_REG = 0x0090. All other configurations are not supported.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PCS_SYSTEM_CNTL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_PCS_SYSTEM_CNTL</id>
    <ignoreEkb />
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Control execution of updateProcessorSbeSeeproms() if 0, enable SBE update of processor SEEPROM if 1, disable SBE update of processor SEEPROM Consumer: sbe_update.C Default: 0</description>
    <id>SBE_UPDATE_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>PCIE IOP lane configuration creator: platform consumer: p9_pcie_scominit firmware notes: These are config dependent attributes based on PCIe Lane/sideband signal routing and PCIe endpoints attached. Encoded PCIE IOP lane configuration PEC0: PHB0 CFG[0:1] SWP[0] Examples: Config #1 PEC0 Lane Config[0:1] = 0b00 PHB0 Swap bit[0] = 0 (Straight lane wiring) Config #2 PEC0 Lane Config[0:1] = 0b00 PHB0 Swap bit[0] = 1 (Reverse lane wiring) PEC1: PHB1 CFG[0:1] SWP[0] PHB2 CFG[2:3] SWP[1] Examples: Config #1 PEC1 Lane Config[0:3] = 0b0000 PHB1 Swap bit[0] = 0 (Straight lane wiring) PHB2 Swap bit[1] = 0 (Straight lane wiring) Config #2 PEC1 Lane Config[0:3] = 0b0000 PHB1 Swap bit[0] = 1 (Reverse lane wiring) PHB2 Swap bit[1] = 0 (Straight lane wiring) PEC2: CFG[0:1] = 0b00 PHB3 CFG[2:3]; SWP[0] CFG[4:5] = don't care SWP[1:2] = don't care CFG[0:1] = 0b01 PHB3 CFG[2:3]; SWP[0] PHB4 CFG[4:5]; SWP[1] PHB5 SWP[2] = don't care CFG[0:1] = 0b10 PHB3 CFG[2:3]; SWP[0] PHB4 CFG[4]; SWP[1] PHB5 CFG[5]; SWP[2] Examples: Config #1 (PEC2 Lane Config[0:5] = 0b000000) PHB3 Swap bit[0] = 0 (Straight lane wiring) PHB4 Swap bit[1] = don't care PHB5 Swap bit[2] = don't care Config #1 (PEC2 Lane Config[0:5] = 0b010000) PHB3 Swap bit[0] = 1 (Reverse lane wiring) PHB4 Swap bit[1] = 0 (Straight lane wiring) PHB5 Swap bit[2] = don't care Config #3 (PEC2 Lane Config[0:5] = 0b100000) PHB3 Swap bit[0] = 1 (Reverse lane wiring) PHB4 Swap bit[1] = 0 (Straight lane wiring) PHB5 Swap bit[2] = 1 (Reverse lane wiring)</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_CONFIG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PROC_PCIE_IOP_CONFIG</id>
    <ignoreEkb />
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Indicates istep IPL</description>
    <hwpfToHbAttrMap>
      <id>ATTR_ISTEP_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>ISTEP_MODE</id>
    <ignoreEkb />
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>1 = System has redundant clock oscillators 0 = System does not have redundant clock oscillators From the Machine Readable Workbook</description>
    <id>REDUNDANT_CLOCKS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Stores the SMT setting used to determine fused mode. SMT4_DEFAULT: Nimbus_DD1, boot in SMT4 but can change to SMT8 SMT4_ONLY: Nimbus_DD2/Cumulus, set based on PVR info SMT8_ONLY: Nimbus_DD2/Cumulus, set based on PVR info</description>
    <id>FUSED_CORE_MODE_HB</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>LID id used to load tables for Workload Optimized Frequency (WOF) algorithms. Producer: TMGT Consumers: FW that selects VFRT tables</description>
    <id>WOF_TABLE_LID_NUMBER</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x81E00440</default>
      </uint32_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>PROC_CHIP Attribute If true, the chip is installed on a Dual Chip Module Provided by the Machine Readable Workbook</description>
    <id>PROC_DCM_INSTALLED</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>PCS rx loff control creator: platform consumer: p9_pcie_scominit firmware notes: The value of rx loff control for PCS. Array index: Configuration number index 0~3 for CONFIG0~3</description>
    <id>PROC_PCIE_PCS_RX_LOFF_CONTROL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of PCS rx phase rotator control creator: platform consumer: p9_pcie_scominit</description>
    <id>PROC_PCIE_PCS_RX_PHASE_ROTATOR_CNTL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of PCS rx sigdet control creator: platform consumer: p9_pcie_scominit</description>
    <id>PROC_PCIE_PCS_RX_SIGDET_CNTL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Value of PCS tx fifo config offset creator: platform consumer: p9_pcie_scominit</description>
    <id>PROC_PCIE_PCS_TX_FIFO_CONFIG_OFFSET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Hot Plug Controller values for a specific processor. Purpose: Holds information about the hot plug controllers so that a Hardware procedure is able to turn them on and off. Data Format: up to 8 Hot Plug Controllers x 7 variables of information This data is at the processor level. The needed information and their individual sizes are as follows: (1) I2C Master processor engine (uint8_t) (2) I2C Master processor port (uint8_t) (3) Bus Speed (uint16_t value: 2 uint8_t values: MSB, LSB) (4) Slave address (uint8_t) (5) Device type (uint8_t: see SUPPORTED_HOT_PLUG enum) (6) I2C Master processor node (uint8_t) (7) I2C Master processor position (uint8_t) Thus, the information will be 8 bytes.</description>
    <id>HOT_PLUG_POWER_CONTROLLER_INFO</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>8,8</array>
      <uint8_t>
        <default>0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Override for Minimum frequency for which undervolting is allowed. If value = 0, the value of VPD CPMin data point is passed to OCC FW via Pstate SuperStructure. If value != 0, this value will be passed to OCC FW via Pstate SuperStructure as the floor frequency for enabled CPMs. Will be internally rounded to the nearest ATTR_PROC_REFCLK_FREQUENCY / 8 value. Consumer: OCC FW; OCC Lab Tools Provided by the Machine Readable Workbook.</description>
    <id>PM_UNDERVOLTING_FRQ_MINIMUM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Override for Maximum frequency for which undervolting is allowed. If value = 0, the value of VPD Turbo data point is passed to OCC FW via Pstate SuperStructure. If value != 0, this value will be passed to OCC FW via Pstate SuperStructure as the ceiling frequency for enabled CPMs. Will be internally rounded to the nearest ATTR_PROC_REFCLK_FREQUENCY / 8 value. Consumer: OCC FW; OCC Lab Tools Provided by the Machine Readable Workbook.</description>
    <id>PM_UNDERVOLTING_FREQ_MAXIMUM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Setting depends on di/dt charateristics of the system. Set Assisted if power off serialization is needed and WINKLE_TYPE=Fast; Set to Hardware if the system can handle the unrelated powering off between cores. Hardware setting decreases entry latency Producer: MRWB Consumer: p8_poreslw_init.C</description>
    <id>PM_WINKLE_ENTRY</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Setting depends on di/dt charateristics of the system and the setting of ATTR_PM_WINKLE_TYPE. Set to Assisted if power on serialization is needed and WINKLE_TYPE=Fast; Set to Hardware if the system can handle the unrelated powering off between cores. Hardware setting decreases entry latency. Must be set to Assisted if ATTR_PM_WINKLE_TYPE=Deep as this necessary for restore. Setting to Hardware is a test mode for Fast only. Producer: MRWB Consumer: p8_poreslw_init.C</description>
    <id>PM_WINKLE_EXIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>PROC_CHIP Attribute Defines the configuration of the SPIVID ports from the target. - NONE means that no VRM is attached. - PORTxNONRED means that the indicated port is used in a non-redundant configuration. - REDUNDANT means that all three are connected and considered redundant. Provided by the Machine Readable Workbook.</description>
    <id>PM_SPIVID_PORT_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>DEPRECATED!!! Use PBAX_GROUPID instead PROC_CHIP Attribute Receive PBAX Nodeid. Value that indicates this PBA's PBAX Node affinity. This is matched to pbax_nodeid of the PMISC Address phase. Provided by the Machine Readable Workbook.</description>
    <id>PM_PBAX_NODEID</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>PROC_CHIP Attribute Set Assisted if power off serialization is needed and SLEEP_TYPE=Fast; Set to Hardware if the system can handle the unrelated powering off between cores. Hardware setting decreases entry latency Producer: MRWB Consumer: proc_pm_init and proc_pcbs_init</description>
    <id>PM_SLEEP_ENTRY</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>PROC_CHIP Attribute Set to Assisted if power on serialization is needed and SLEEP_TYPE=Fast; Set to Hardware if the system can handle the unrelated powering off between cores. Hardware setting decreases entry latency Must be set to Assisted if ATTR_PM_SLEEP_TYPE=Deep as this necessary for restore. Setting to Hardware is a test mode for Fast only. Producer: MRWB Consumer: proc_pm_init and proc_pcbs_init.</description>
    <id>PM_SLEEP_EXIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>PROC_CHIP Attribute Selects which voltage level to place the Core domain PFETs upon Sleep entry. 0 = Vret (Fast Sleep Mode), 1 = Voff (Deep Sleep Mode) Producer: MRWB Consumer: proc_pm_init and proc_pcbs_init</description>
    <id>PM_SLEEP_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>PROC_CHIP Attribute Selects which voltage level to place the Core and ECO domain PFETs upon Winkle entry. 0 = Vret (Fast Winkle Mode), 1 = Voff (Deep Winkle Mode)</description>
    <id>PM_WINKLE_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Lane mask for which 8 lanes belong to this brick This is a right justified 24-bit value. Only 8 of the 24 bits will be set representing the lanes belonging to the associated brick. Provided by the MRW.</description>
    <id>OBUS_BRICK_LANE_MASK</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines the maximum Seeprom storage size for the fully-customized SBE image permitted by the platform. For platforms (FSP/HB FW) which require the image to be constrained into a physical storage device (SEEPROM), this should reflect the maximum size of that memory (e.g., 256KB). For platforms (Cronus) which may use a customized image in a virtual envrionment with no physical storage constraints, this size may be larger than the physical SEEPROM size.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_MAX_SBE_SEEPROM_SIZE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>MAX_SBE_SEEPROM_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t>
        <default>0x40000</default>
      </uint32_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Control CME response to execution of PowerPC STOP instruction if OFF, treat STOP5 as STOP5 if ON, treat STOP5 as STOP4 Producer: ??? Consumer: p9_hcode_image_build.C Platform default: ON</description>
    <hwpfToHbAttrMap>
      <id>ATTR_STOP5_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>STOP5_DISABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>System attribute. The frequency of the processor refclock in MHz. Provided by the MRW.</description>
    <id>FREQ_PROC_REFCLOCK</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the eRepair threshold value of X-Bus used in the field. creator: platform (generated based on MRW data) See defintion in erepair_thresholds.xml for more information.</description>
    <id>X_EREPAIR_THRESHOLD_FIELD</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the eRepair threshold value of A-Bus used in the field. creator: platform (generated based on MRW data) See defintion in erepair_thresholds.xml for more information.</description>
    <id>A_EREPAIR_THRESHOLD_FIELD</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the eRepair threshold value of DMI-Bus used in the field. creator: platform (generated based on MRW data) See defintion in erepair_thresholds.xml for more information.</description>
    <id>DMI_EREPAIR_THRESHOLD_FIELD</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the eRepair threshold value of X-Bus used by Manufacturing. creator: platform (generated based on MRW data) See defintion in erepair_thresholds.xml for more information.</description>
    <id>X_EREPAIR_THRESHOLD_MNFG</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the eRepair threshold value of A-Bus used by Manufacturing. creator: platform (generated based on MRW data) See defintion in erepair_thresholds.xml for more information.</description>
    <id>A_EREPAIR_THRESHOLD_MNFG</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute represents the eRepair threshold value of DMI-Bus used by Manufacturing. creator: platform (generated based on MRW data) See defintion in erepair_thresholds.xml for more information.</description>
    <id>DMI_EREPAIR_THRESHOLD_MNFG</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>sets the Centaur address bits used to interleave addresses between MBA01 and MBA23. valid values are 23 through 32.</description>
    <id>MSS_MBA_ADDR_INTERLEAVE_BIT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>centaur interleave mode. 1 = 256-BIT, 0 = 128-BIT.</description>
    <id>MSS_MBA_CACHELINE_INTERLEAVE_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>SYSTEM Attribute SPI Clock Frequency (binary in MHz) Consumer: proc_pm_effective Produces ATTR_PM_SPIVID_CLOCK_DIVIDER Provided by the Machine Readable Workbook.</description>
    <id>PM_SPIVID_FREQUENCY</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Frequency (binary in KHz) indicating the frequency that the cores will be moved to in the event of the loss of the OCC Heartbeat. This value needs to be the maximum of the DpoMin frequency for proper PowerBus operation and the PowerSave value for the present part. Provided by the Machine Readable Workbook after system characterization. The value is translated to the Pstate space. Producer: Machine Readable Workbook Consumers: p8_build_gpstate_table.C DYNAMIC_ATTRIBUTE: ATTR_PM_SAFE_PSTATE</description>
    <id>PM_SAFE_FREQUENCY</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>SYSTEM Attribute Frequency (binary in MHz) for the point at which clock sector buffers should be at full strength. This is to support Vmin operation. Setting cannot overlap the Low or High bands. Provided by the Machine Readable Workbook after system characterization.</description>
    <hwpfToHbAttrMap>
      <id>ATTR_PM_RESONANT_CLOCK_FULL_CLOCK_SECTOR_BUFFER_FREQUENCY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>PM_RESONANT_CLOCK_FULL_CLOCK_SECTOR_BUFFER_FREQUENCY</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>SYSTEM Attribute Frequency (binary in MHz)) for the lower end of the Low Frequency Resonant band Provided by the Machine Readable Workbook after system characterization.</description>
    <id>PM_RESONANT_CLOCK_LOW_BAND_LOWER_FREQUENCY</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>SYSTEM Attribute Frequency (binary in MHz) for the upper end of the Low Frequency Resonant band Provided by the Machine Readable Workbook after system characterization.</description>
    <id>PM_RESONANT_CLOCK_LOW_BAND_UPPER_FREQUENCY</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>SYSTEM Attribute Frequency (binary in MHz) for the lower end of the High Frequency Resonant band Provided by the Machine Readable Workbook after system characterization.</description>
    <id>PM_RESONANT_CLOCK_HIGH_BAND_LOWER_FREQUENCY</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>SYSTEM Attribute Frequency (binary in MHz)) for the upper end of the High Frequency Resonant band Provided by the Machine Readable Workbook after system characterization.</description>
    <id>PM_RESONANT_CLOCK_HIGH_BAND_UPPER_FREQUENCY</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook throttle value for denominator cfg_nm_m</description>
    <id>MRW_MEM_THROTTLE_DENOMINATOR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Version level of #M that represents the minimum for IVRM characterized parts. If this value is non-zero and the #M version level is less than this value, IVRMs are disabled. If the #M version is greater than or equal to this value, the IVRMs are allowed to be enable from a level of part perspective. Producer: MRWB Consumer: p8_build_pstate_datablock.C</description>
    <id>PM_SYSTEM_IVRM_VPD_MIN_LEVEL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>System attribute. 6 bit rx_min_eye_width value for DMI bus interfaces during system manufacturing; used for both centaur and p8 creator: platform firmware notes: Attribute value is in the Machine Readable Workbook</description>
    <id>MNFG_DMI_MIN_EYE_WIDTH</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>System attribute. 8 bit rx_min_eye_height value for DMI bus interfaces during system manufacturing; used for both centaur and p8 creator: platform firmware notes: Attribute value is in the Machine Readable Workbook</description>
    <id>MNFG_DMI_MIN_EYE_HEIGHT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>System attribute 6 bit rx_min_eye_width value for A bus interfaces during system manufacturing creator: platform firmware notes: Attribute value is in the Machine Readable Workbook</description>
    <id>MNFG_ABUS_MIN_EYE_WIDTH</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>System attribute 8 bit rx_min_eye_height value for A bus interfaces during system manufacturing creator: platform firmware notes: Attribute value is in the Machine Readable Workbook</description>
    <id>MNFG_ABUS_MIN_EYE_HEIGHT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>System attribute 6 bit rx_min_eye_width value for X bus interfaces during system manufacturing creator: platform firmware notes: Attribute value is in the Machine Readable Workbook</description>
    <id>MNFG_XBUS_MIN_EYE_WIDTH</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines where to apply Brazos rx_fifo_final_l2u_dly override settings for SW299500.</description>
    <id>BRAZOS_RX_FIFO_OVERRIDE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>At a system level, this attribute controls if interleaving is required, requested or never. The MRW.</description>
    <id>MRW_MBA_CACHELINE_INTERLEAVE_MODE_CONTROL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>PCS rx vga control register3 creator: platform consumer: p9_pcie_scominit firmware notes: The value of rx vga control register3. Array index: Configuration number index 0~3 for CONFIG0~3</description>
    <id>PROC_PCIE_PCS_RX_VGA_CONTRL_REGISTER3</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>4</array>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines system specific value of processor refclock receiver termination (FSI GP4 bits 8:9)</description>
    <hasStringConversion />
    <id>PROC_REFCLOCK_RCVR_TERM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Defines system specific value of PCI refclock receiver termination (FSI GP4 bits 10:11)</description>
    <hasStringConversion />
    <id>PCI_REFCLOCK_RCVR_TERM</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>System attribute. The max DMI units per proc available in the system.</description>
    <id>MAX_DMI_PER_PROC</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>8</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>System attribute. If all MCS chiplets are in an interleaving group (1=true, 0=false). - If true the SMP fabric is setup in normal mode and multiple MCSs are grouped (disallowing systems with memory only under 1 MCS (i.e. systems with a single C-DIMM)) - If false the SMP fabric is setup in checkerboard mode. Provided by the Machine Readable Workbook. This attribute is based on Machine-Type-Model (MTM) and is setup by the service processor.</description>
    <id>ALL_MCS_IN_INTERLEAVING_GROUP</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Select OBUS0 pll setting from one of the supported frequencies</description>
    <hwpfToHbAttrMap>
      <id>ATTR_OB0_PLL_BUCKET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>OB0_PLL_BUCKET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Select OBUS1 pll setting from one of the supported frequencies</description>
    <hwpfToHbAttrMap>
      <id>ATTR_OB1_PLL_BUCKET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>OB1_PLL_BUCKET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Select OBUS2 pll setting from one of the supported frequencies</description>
    <hwpfToHbAttrMap>
      <id>ATTR_OB2_PLL_BUCKET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>OB2_PLL_BUCKET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Select OBUS3 pll setting from one of the supported frequencies</description>
    <hwpfToHbAttrMap>
      <id>ATTR_OB3_PLL_BUCKET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <id>OB3_PLL_BUCKET</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Hardware topology for HDAT creator:MRW consumer:HDAT firmware notes: Hardware Topology 2 Bytes Byte 1: bit 0-3: Node Id bit 4-7: Socket id inside the node bit 8-11: Proc id inside socket bit 12-15:Hub Id inside proc</description>
    <id>PROC_HW_TOPOLOGY</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Attribute indicating the target's chip version</description>
    <hasStringConversion />
    <id>CHIP_VER</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <enumeration>
        <id>CHIP_VER</id>
      </enumeration>
    </simpleType>
  </attribute>
  <attribute>
    <description>Attribute indicating the target's hw version</description>
    <hasStringConversion />
    <id>HW_VER</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <enumeration>
        <id>HW_VER</id>
      </enumeration>
    </simpleType>
  </attribute>
  <attribute>
    <description>Attribute indicating the target's software version</description>
    <hasStringConversion />
    <id>SW_VER</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <enumeration>
        <id>SW_VER</id>
      </enumeration>
    </simpleType>
  </attribute>
  <attribute>
    <description>Attribute indicating the target's role</description>
    <hasStringConversion />
    <id>ROLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <enumeration>
        <id>ROLE</id>
      </enumeration>
    </simpleType>
  </attribute>
  <attribute>
    <description>PHYP system type value for habanero and barreleye (0x3015 and 0x3016 respectively). The value is updated in the system xml.</description>
    <id>PHYP_SYSTEM_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>LX keyword VPD data for HDAT module</description>
    <id>ASCII_VPD_LX_KEYWORD</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
    <writeable />
  </attribute>
  <attribute>
    <description>Power management mode the system should use. Valid values: 1 = Nominal (default), 5 = Static Power Save (percentage below nominal whose value is defined in OPEN_POWER_PM_MODE_FREQ_PERCENT), 6 = Dynamic Power Save - Favor Energy (DPS-FE), 10 = Dynamic Power Save - Favor Performance (DPS-FP), 11 = Fixed Frequency Override - (percentage above nominal whose value is defined in OPEN_POWER_PM_MODE_FREQ_PERCENT)</description>
    <id>OPEN_POWER_PM_MODE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Percentage from nominal that the processors should run at when OPEN_POWER_PM_MODE is set to Static Power Save or Fixed Frequency Override (ignored on all other modes). Unit is in tenths of a percent (150 = 15.0%). Static Power Save (5): percentage to decrease frequency, Fixed Frequency Override (11): percentage to increase frequency</description>
    <id>OPEN_POWER_PM_MODE_FREQ_PERCENT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Indicates if Idle Power Save is enabled. This is independent of the OPEN_POWER_PM_MODE (DPS and IPS can be enabled at the same time). Valid Values: 0 = Disabled (default), 1 = Enabled. See IPS_ENTER / IPS_EXIT attributes for IPS configuration.</description>
    <id>IPS_ENABLE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>When IPS is enabled, this defines the delay time in seconds (between 10 and 600) to enter Idle Power Save.</description>
    <id>IPS_ENTER_TIME_SECONDS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>240</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>When IPS is enabled, this defines the utilization threshold as a percent (between 0 and 100) to enter Idle Power Save. This value should be less than IPS_EXIT_UTILIZATION_PERCENT.</description>
    <id>IPS_ENTER_UTILIZATION_PERCENT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>8</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>When IPS is enabled, this defines the delay time in seconds (between 10 and 600) to exit Idle Power Save.</description>
    <id>IPS_EXIT_TIME_SECONDS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint16_t>
        <default>10</default>
      </uint16_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>When IPS is enabled, this defines the utilization threshold as a percent (between 0 and 100) to exit Idle Power Save. This value should be greater than IPS_ENTER_UTILIZATION_PERCENT.</description>
    <id>IPS_EXIT_UTILIZATION_PERCENT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>12</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>ADC Channel function id. 16 channels.</description>
    <id>ADC_CHANNEL_FUNC_IDS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>16</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>ADC Channel IPMI sensor numbers. 16 channels.</description>
    <id>ADC_CHANNEL_SENSOR_NUMBERS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>16</array>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>ADC Channel ground. 16 channels.</description>
    <id>ADC_CHANNEL_GNDS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>16</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>ADC channel gain * 1000. 16 channels.</description>
    <id>ADC_CHANNEL_GAINS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>16</array>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>ADC channel offset * 1000. 16 channels</description>
    <id>ADC_CHANNEL_OFFSETS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>16</array>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>APSS GPIO PORT MODES</description>
    <id>APSS_GPIO_PORT_MODES</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>2</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>APSS GPIO PORT PINS Port0 pin 0-7 Port1 pin 8-15</description>
    <id>APSS_GPIO_PORT_PINS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>16</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <complexType>
      <description>Structure to define the addessing for an I2C slave device.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0</default>
        <description>Port from the I2C Master device. This is a 6-bit value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0</default>
        <description>Device address on the I2C bus. This is a 7-bit value, but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0</default>
        <description>Logical GPIO pin number used to enabled/disable VDDR</description>
        <name>vddrPin</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Information needed to address GPIO device</description>
    <id>GPIO_INFO</id>
    <persistency>non-volatile</persistency>
    <readable />
  </attribute>
  <attribute>
    <description>This attribute holds the values of the I2C Engine from the i2c device connections as defined in the MRW. It is parsed into a struct in i2c.C</description>
    <id>HDAT_I2C_ENGINE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>32</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute holds the values of the I2C Master Port from the i2c device connections as defined in the MRW. It is parsed into a struct in i2c.C</description>
    <id>HDAT_I2C_MASTER_PORT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>32</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute holds the values of the I2C device type from the i2c device connections as defined in the MRW. It is parsed into a struct in i2c.C</description>
    <id>HDAT_I2C_DEVICE_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>32</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute holds the values of the I2C address from the i2c device connections as defined in the MRW. It is parsed into a struct in i2c.C</description>
    <id>HDAT_I2C_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>32</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute holds the values of the I2C slave port from the i2c device connections as defined in the MRW. It is parsed into a struct in i2c.C</description>
    <id>HDAT_I2C_SLAVE_PORT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>32</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute holds the values of the I2C bus frequency in Hz from the i2c device connections as defined in the MRW. It is parsed into a struct in i2c.C</description>
    <id>HDAT_I2C_BUS_FREQ</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>32</array>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute holds the values of the I2C device purpose from the i2c device connections as defined in the MRW. It is parsed into a struct in i2c.C</description>
    <id>HDAT_I2C_DEVICE_PURPOSE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>32</array>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute holds the string descriptions of the I2C devices from the i2c device connections as defined in the MRW. It is parsed into a struct in i2c.C</description>
    <id>HDAT_I2C_DEVICE_LABEL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>32</array>
      <string>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
  </attribute>
  <attribute>
    <description>This attribute holds the number of elements that were found under this particular target, and how many devices are stored in the arrays.</description>
    <id>HDAT_I2C_ELEMENTS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Holds the IPMI instance number for this entity.</description>
    <id>IPMI_INSTANCE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Attribute to hold 16 pairs of sensor name, sensor number pairs. A sensor name consists of one byte of general sensor type and one byte of sub-type</description>
    <id>IPMI_SENSORS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <array>16,2</array>
      <uint16_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>DIMM temperature threshold where throttling will occur in degrees C</description>
    <id>OPEN_POWER_DIMM_THROTTLE_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>DIMM temperature where an error will be generated in degrees C</description>
    <id>OPEN_POWER_DIMM_ERROR_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Memory controller temperature threshold where throttling will occur in degrees C</description>
    <id>OPEN_POWER_MEMCTRL_THROTTLE_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Weight factor (in 1/10ths) for each core DTS to calculate a core temperature.</description>
    <id>OPEN_POWER_PROC_WEIGHT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Weight factor (in 1/10ths) for each quad (cache) DTS to calculate a core temperature.</description>
    <id>OPEN_POWER_QUAD_WEIGHT</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Processor temperature where DVFS will occur in degrees C</description>
    <id>OPEN_POWER_PROC_DVFS_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Memory controller temperature where an error will occur in degrees C</description>
    <id>OPEN_POWER_MEMCTRL_ERROR_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>N mode bulk power supply limit in Watts</description>
    <id>OPEN_POWER_N_BULK_POWER_LIMIT_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Maximum power allocated to DIMMs in Watts</description>
    <id>OPEN_POWER_N_MAX_MEM_POWER_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Memory controller read timeout in seconds</description>
    <id>OPEN_POWER_MEMCTRL_READ_TIMEOUT_SEC</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>DIMM read timeout in seconds</description>
    <id>OPEN_POWER_DIMM_READ_TIMEOUT_SEC</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Processor temperature error threshold in degrees C</description>
    <id>OPEN_POWER_PROC_ERROR_TEMP_DEG_C</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Minimum memory utilization percent (from 0-100) for memory throttling</description>
    <id>OPEN_POWER_MIN_MEM_UTILIZATION_THROTTLING</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Minimum memory utilization percent (from 0-100) for power capping</description>
    <id>OPEN_POWER_MIN_MEM_UTILIZATION_POWER_CAP</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>VRM read timeout in seconds (from 0-255) Use 0 to disable VRM OT monitoring</description>
    <id>OPEN_POWER_VRM_READ_TIMEOUT_SEC</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>Processor read timeout in seconds</description>
    <id>OPEN_POWER_PROC_READ_TIMEOUT_SEC</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Regulator efficiency factor</description>
    <id>OPEN_POWER_REGULATOR_EFFICIENCY_FACTOR</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Minimum hard power cap in Watts</description>
    <id>OPEN_POWER_MIN_POWER_CAP_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Minimum soft power cap in Watts</description>
    <id>OPEN_POWER_SOFT_MIN_PCAP_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>N+1 bulk power limit in Watts for systems running with redundant power supplies (default)</description>
    <id>OPEN_POWER_N_PLUS_ONE_BULK_POWER_LIMIT_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>N+1 bulk power limit in Watts for High Performance Computing systems running with a non-redundant power supply policy</description>
    <id>OPEN_POWER_N_PLUS_ONE_HPC_BULK_POWER_LIMIT_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t>
        <default>0</default>
      </uint64_t>
    </simpleType>
  </attribute>
  <attribute>
    <description>N+1 max memory power in Watts</description>
    <id>OPEN_POWER_N_PLUS_ONE_MAX_MEM_POWER_WATTS</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint64_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>If this system supports Turbo frequency mode. 0x00 = no 0x01 = yes</description>
    <id>OPEN_POWER_TURBO_MODE_SUPPORTED</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint8_t />
    </simpleType>
  </attribute>
  <attribute>
    <description>Specifies the compatible model name for Opal to key off of. This is sourced from the MRW and should be of the format 'vendor,model', e.g. 'tyan,palmetto'.</description>
    <id>OPAL_MODEL</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <string>
        <default>ibm,miscopenpower</default>
        <sizeInclNull>32</sizeInclNull>
      </string>
    </simpleType>
  </attribute>
  <attribute>
    <description>The manufacturer of the BMC</description>
    <id>BMC_MANUFACTURER</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <string>
        <default>ibm</default>
        <sizeInclNull>32</sizeInclNull>
      </string>
    </simpleType>
  </attribute>
  <attribute>
    <description>The type of hardware of the BMC</description>
    <id>BMC_HW_CHIP_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <string>
        <default>ast2500</default>
        <sizeInclNull>32</sizeInclNull>
      </string>
    </simpleType>
  </attribute>
  <attribute>
    <description>The software type of the BMC</description>
    <id>BMC_SW_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <string>
        <default>openbmc</default>
        <sizeInclNull>32</sizeInclNull>
      </string>
    </simpleType>
  </attribute>
  <attribute>
    <description>Machine Readable Workbook safe mode throttle value for numerator cfg_nm_n_per_chip</description>
    <id>MRW_SAFEMODE_MEM_THROTTLE_NUMERATOR_PER_CHIP</id>
    <persistency>non-volatile</persistency>
    <readable />
    <simpleType>
      <uint32_t />
    </simpleType>
  </attribute>
  <enumerationType>
    <description>Specify the system policy to enforce synchronous mode between memory and nest. This drives the value of ATTR_MEM_IN_SYNCH_MODE. UNDETERMINED : Run synchronously if the dimm and nest freq matches ALWAYS : Require matching frequencies and deconfigure memory that does not match the nest NEVER : Do not run synchronously, even if the frequencies match</description>
    <enumerator>
      <name>UNDETERMINED</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ALWAYS</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>NEVER</name>
      <value>2</value>
    </enumerator>
    <id>REQUIRED_SYNCH_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Machine Readable Workbook Refresh Rate Desired refresh interval used in refresh register 0, MBAREF0Q_CFG_REFRESH_INTERVAL 7.8 us (SINGLE) 3.9 us (DOUBLE) 7.02 us (SINGLE_10_PERCENT_FASTER) 3.51 us (DOUBLE_10_PERCENT_FASTER)</description>
    <enumerator>
      <name>DOUBLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>SINGLE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SINGLE_10_PERCENT_FASTER</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>DOUBLE_10_PERCENT_FASTER</name>
      <value>3</value>
    </enumerator>
    <id>MSS_MRW_REFRESH_RATE_REQUEST</id>
  </enumerationType>
  <enumerationType>
    <description>Machine Readable Workbook enablement of the HWP code to adjust the VMEM regulator power limit based on number of installed DIMMs.</description>
    <enumerator>
      <name>FALSE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Used for to determine whether to apply an offset to AVDD. Supplied by MRW.</description>
    <enumerator>
      <name>DISABLE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>0</value>
    </enumerator>
    <id>MSS_MRW_AVDD_OFFSET_DISABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Used for to determine whether to apply an offset to VDD. Supplied by MRW.</description>
    <enumerator>
      <name>DISABLE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>0</value>
    </enumerator>
    <id>MSS_MRW_VDD_OFFSET_DISABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Used for to determine whether to apply an offset to VCS. Supplied by MRW.</description>
    <enumerator>
      <name>DISABLE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>0</value>
    </enumerator>
    <id>MSS_MRW_VCS_OFFSET_DISABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Used for to determine whether to apply an offset to VCS. Supplied by MRW.</description>
    <enumerator>
      <name>DISABLE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>0</value>
    </enumerator>
    <id>MSS_MRW_VPP_OFFSET_DISABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Used for to determine whether to apply an offset to VDDR. Supplied by MRW.</description>
    <enumerator>
      <name>DISABLE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>0</value>
    </enumerator>
    <id>MSS_MRW_VDDR_OFFSET_DISABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Fine refresh mode. Sets DDR4 MRS3. ZZ uses normal mode. From JEDEC DDR4 Spec 1716.78C from 07-2016 Page 47 Table 4.9.1</description>
    <enumerator>
      <name>NORMAL</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>FIXED_2X</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>FIXED_4X</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>FLY_2X</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>FLY_4X</name>
      <value>6</value>
    </enumerator>
    <id>MSS_MRW_FINE_REFRESH_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Temperature refresh range. Sets DDR4 MRS4. Should be defaulted to extended range. NORMAL for running at 85 degrees C or less, EXTENDED for 95 or less degrees C Used for calculating periodic refresh intervals JEDEC DDR4 spec 1716.78C from 07-2016 page 46 4.8.1</description>
    <enumerator>
      <name>NORMAL</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>EXTEND</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_TEMP_REFRESH_RANGE</id>
  </enumerationType>
  <enumerationType>
    <description>For resetting the phy delay values at the beginning of calling mss_draminit_training. YES means the vaules will be reset.</description>
    <enumerator>
      <name>YES</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>NO</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_RESET_DELAY_BEFORE_CAL</id>
  </enumerationType>
  <enumerationType>
    <description>Value of on or off. Determines if prefetching enabled or not.</description>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <id>MSS_MRW_PREFETCH_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Value of on or off. Determines if the cleaner of the L4 cache (write modified entries to memory on idle cycles) enabled or not. See chapter 7 of the Centaur Workbook.</description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_CLEANER_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Allows user to manually turn on and off 2N Mode. AUTO indicates to use Signal Integrity generated setting (from VPD).</description>
    <enumerator>
      <name>AUTO</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>FORCE_TO_1N_MODE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>FORCE_TO_2N_MODE</name>
      <value>2</value>
    </enumerator>
    <id>MSS_MRW_DRAM_2N_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>List of memory frequencies supported by the current system.</description>
    <enumerator>
      <name>MT1866</name>
      <value>1866</value>
    </enumerator>
    <enumerator>
      <name>MT2133</name>
      <value>2133</value>
    </enumerator>
    <enumerator>
      <name>MT2400</name>
      <value>2400</value>
    </enumerator>
    <enumerator>
      <name>MT2666</name>
      <value>2666</value>
    </enumerator>
    <id>MSS_MRW_SUPPORTED_FREQ</id>
  </enumerationType>
  <enumerationType>
    <description>Enables DRAM Write CRC</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_DRAM_WRITE_CRC</id>
  </enumerationType>
  <enumerationType>
    <description>The frequency of a processor's nest mesh clock, in MHz. This is the same for all chips in the system. Provided by the MRW.</description>
    <enumerator>
      <name>1600</name>
      <value>1600</value>
    </enumerator>
    <enumerator>
      <name>1866</name>
      <value>1866</value>
    </enumerator>
    <enumerator>
      <name>2000</name>
      <value>2000</value>
    </enumerator>
    <enumerator>
      <name>2133</name>
      <value>2133</value>
    </enumerator>
    <enumerator>
      <name>2400</name>
      <value>2400</value>
    </enumerator>
    <id>FREQ_PB_MHZ</id>
  </enumerationType>
  <enumerationType>
    <description>MRW control to permit Normal (100 MHz) or Slow (94 MHz) operation of PCIE reference clock. On Nimbus DD1 HW, Slow operation is required to achieve Gen4 operation. Provided by the MRW.</description>
    <enumerator>
      <name>NORMAL</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>SLOW</name>
      <value>0x01</value>
    </enumerator>
    <id>DD1_SLOW_PCI_REF_CLOCK</id>
  </enumerationType>
  <enumerationType>
    <description>Processor SMP topology configuration. 0 = default = 1 or 2 hop topology (PHYP image spans system) Provided by the MRW.</description>
    <enumerator>
      <name>OFF</name>
      <value>0x0</value>
    </enumerator>
    <id>PROC_FABRIC_CCSM_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Per-link optics configuration 0 = default = SMP 1 = CAPI 2.0 2 = NV 2.0 3 = OPENCAPI Provided by the MRW.</description>
    <enumerator>
      <name>SMP</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>CAPI</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>NV</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>OCAPI</name>
      <value>0x3</value>
    </enumerator>
    <id>OPTICS_CONFIG_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Define context for current phase of system IPL.</description>
    <enumerator>
      <name>HB_IPL</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>HB_RUNTIME</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>CACHE_CONTAINED</name>
      <value>0x4</value>
    </enumerator>
    <enumerator>
      <name>CHIP_CONTAINED</name>
      <value>0x8</value>
    </enumerator>
    <enumerator>
      <name>NONHB_IPL</name>
      <value>0x10</value>
    </enumerator>
    <id>SYSTEM_IPL_PHASE</id>
  </enumerationType>
  <enumerationType>
    <description>Indicates if current IPL is memory-preserving</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x1</value>
    </enumerator>
    <id>IS_MPIPL</id>
  </enumerationType>
  <enumerationType>
    <description>Define placement policy/scheme for non-mirrored/mirrored memory layout NORMAL = non-mirrored start: 0, mirrored start: 1024TB FLIPPED = mirrored start: 0, non-mirrored start: 512TB Set by platform. Used by mss_eff_grouping.</description>
    <enumerator>
      <name>NORMAL</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>FLIPPED</name>
      <value>0x1</value>
    </enumerator>
    <id>MEM_MIRROR_PLACEMENT_POLICY</id>
  </enumerationType>
  <enumerationType>
    <description>Determines the stride covered by each granule in an interleaving group. The default stride -- 128B -- is the only value intended for production FW use. All other combinations are for experimental performance evaluation. Regardless of this attribute value, groups of size 1, 3, and 6 will be forced to 128B stride based on the logic capabilities.</description>
    <enumerator>
      <name>128_B</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>256_B</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>512_B</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>1_KB</name>
      <value>0x03</value>
    </enumerator>
    <enumerator>
      <name>2_KB</name>
      <value>0x04</value>
    </enumerator>
    <enumerator>
      <name>4_KB</name>
      <value>0x05</value>
    </enumerator>
    <enumerator>
      <name>8_KB</name>
      <value>0x06</value>
    </enumerator>
    <enumerator>
      <name>16_KB</name>
      <value>0x07</value>
    </enumerator>
    <enumerator>
      <name>32_KB</name>
      <value>0x08</value>
    </enumerator>
    <id>MSS_INTERLEAVE_GRANULARITY</id>
  </enumerationType>
  <enumerationType>
    <description>TRUE : HW mirroring is enabled. FALSE : HW mirroring is disabled. Provided by the MRW.</description>
    <enumerator>
      <name>FALSE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>1</value>
    </enumerator>
    <id>MRW_HW_MIRRORING_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Source: MRW: Downstream MSB Swap and Upstream MSB Swap Usage: TX_MSBSWAP initfile setting for DMI and X buses This attribute represents whether or not a single clock group bus such as DMI and X bus was wired by the board designer using a feature called MSB Swap where lane 0 of the TX chip wires to lane n-1 on the RX chip where 'n' is the width of the bus. A basic description of this capability is that the board designer can save layers on the board wiring by crossing the wiring between the two chips in a prescribed manner. In a non-MSB Swapped bus Lane 0 on the TX chip wires to lane 0 on the RX chip, lane 1 to lane 1 and so on. If a bus is MSB Swapped then lane 0 of the TX chip wires to lane 'n-1' of the RX chip, lane 1 to lane 'n-2', etc. Random or arbitrary wiring of TX to RX lanes on different chips is NOT ALLOWED. The Master Chip of two connected chips is defined as the chip with the smaller value of (100*Node + Pos). The Slave Chip of two connected chips is defined as the chip with the larger value of (100*Node + Pos). The Downstream direction is defined as the direction from the Master chip to the Slave chip. The Upstream direction is defined as the direction from the Slave chip to the Master chip. The Downstream TX_MSBSWAP from the MRW is a uint8 value. 0x01 means the Downstream bus is wired msb to lsb etc. and 0x00 means the bus is wired normally, msb to msb, lsb to lsb (lane0 to lane0). The Upstream TX_MSBSWAP from the MRW is a uint8 value. 0x01 means the Upstream bus is wired msb to lsb etc. and 0x00 means the bus is wired normally, msb to msb, lsb to lsb (lane0 to lane0). It is up to the platform code to set up each ATTR_EI_BUS_TX_MSBSWAP value for the correct target endpoints.</description>
    <enumerator>
      <name>NO_SWAP</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ALL_SWAP</name>
      <value>0xFF</value>
    </enumerator>
    <enumerator>
      <name>GROUP_0_SWAP</name>
      <value>0x80</value>
    </enumerator>
    <enumerator>
      <name>GROUP_1_SWAP</name>
      <value>0x40</value>
    </enumerator>
    <id>EI_BUS_TX_MSBSWAP</id>
  </enumerationType>
  <enumerationType>
    <description>Summarizes the fused status of cores. This is same for all P9 chips in the system. If a core is in a fused state, attribute should read 1 else zero. It needs to be populated during ipl but before istep 15.</description>
    <enumerator>
      <name>CORE_UNFUSED</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>CORE_FUSED</name>
      <value>0x1</value>
    </enumerator>
    <id>FUSED_CORE_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Indicate if debug data should be taken pre / post linktraining.</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x1</value>
    </enumerator>
    <id>IO_O_DEBUG</id>
  </enumerationType>
  <enumerationType>
    <description>Indicate if manufcaturing tests should be taken pre / post linktraining.</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x1</value>
    </enumerator>
    <id>IO_O_MFG_CHK</id>
  </enumerationType>
  <enumerationType>
    <description>Indicate if debug data should be taken pre / post linktraining.</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x1</value>
    </enumerator>
    <id>IO_X_DEBUG</id>
  </enumerationType>
  <enumerationType>
    <description>Indicate if manufacturing tests should be taken pre / post linktraining.</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x1</value>
    </enumerator>
    <id>IO_X_MFG_CHK</id>
  </enumerationType>
  <enumerationType>
    <description>PCIE MMIO BAR enable creator: platform consumer: p9_pcie_config firmware notes: Array index: BAR number (0:2) index 0~1 for MMIO BAR0/1 index 2 for PHB register space</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_PCIE_BAR_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>PCIE MMIO BAR size values creator: platform consumer: p9_pcie_config firmware notes: Array index: BAR number (0:2) NOTE: supported MMIO BAR0/1 sizes are from 64KB-32PB NOTE: only supported PHB register size is 16KB</description>
    <enumerator>
      <name>32_PB</name>
      <value>0x8000000000000000</value>
    </enumerator>
    <enumerator>
      <name>16_PB</name>
      <value>0xC000000000000000</value>
    </enumerator>
    <enumerator>
      <name>8_PB</name>
      <value>0xE000000000000000</value>
    </enumerator>
    <enumerator>
      <name>4_PB</name>
      <value>0xF000000000000000</value>
    </enumerator>
    <enumerator>
      <name>2_PB</name>
      <value>0xF800000000000000</value>
    </enumerator>
    <enumerator>
      <name>1_PB</name>
      <value>0xFC00000000000000</value>
    </enumerator>
    <enumerator>
      <name>512_TB</name>
      <value>0xFE00000000000000</value>
    </enumerator>
    <enumerator>
      <name>256_TB</name>
      <value>0xFF00000000000000</value>
    </enumerator>
    <enumerator>
      <name>128_TB</name>
      <value>0xFF80000000000000</value>
    </enumerator>
    <enumerator>
      <name>64_TB</name>
      <value>0xFFC0000000000000</value>
    </enumerator>
    <enumerator>
      <name>32_TB</name>
      <value>0xFFE0000000000000</value>
    </enumerator>
    <enumerator>
      <name>16_TB</name>
      <value>0xFFF0000000000000</value>
    </enumerator>
    <enumerator>
      <name>8_TB</name>
      <value>0xFFF8000000000000</value>
    </enumerator>
    <enumerator>
      <name>4_TB</name>
      <value>0xFFFC000000000000</value>
    </enumerator>
    <enumerator>
      <name>2_TB</name>
      <value>0xFFFE000000000000</value>
    </enumerator>
    <enumerator>
      <name>1_TB</name>
      <value>0xFFFF000000000000</value>
    </enumerator>
    <enumerator>
      <name>512_GB</name>
      <value>0xFFFF800000000000</value>
    </enumerator>
    <enumerator>
      <name>256_GB</name>
      <value>0xFFFFC00000000000</value>
    </enumerator>
    <enumerator>
      <name>128_GB</name>
      <value>0xFFFFE00000000000</value>
    </enumerator>
    <enumerator>
      <name>64_GB</name>
      <value>0xFFFFF00000000000</value>
    </enumerator>
    <enumerator>
      <name>32_GB</name>
      <value>0xFFFFF80000000000</value>
    </enumerator>
    <enumerator>
      <name>16_GB</name>
      <value>0xFFFFFC0000000000</value>
    </enumerator>
    <enumerator>
      <name>8_GB</name>
      <value>0xFFFFFE0000000000</value>
    </enumerator>
    <enumerator>
      <name>4_GB</name>
      <value>0xFFFFFF0000000000</value>
    </enumerator>
    <enumerator>
      <name>2_GB</name>
      <value>0xFFFFFF8000000000</value>
    </enumerator>
    <enumerator>
      <name>1_GB</name>
      <value>0xFFFFFFC000000000</value>
    </enumerator>
    <enumerator>
      <name>512_MB</name>
      <value>0xFFFFFFE000000000</value>
    </enumerator>
    <enumerator>
      <name>256_MB</name>
      <value>0xFFFFFFF000000000</value>
    </enumerator>
    <enumerator>
      <name>128_MB</name>
      <value>0xFFFFFFF800000000</value>
    </enumerator>
    <enumerator>
      <name>64_MB</name>
      <value>0xFFFFFFFC00000000</value>
    </enumerator>
    <enumerator>
      <name>32_MB</name>
      <value>0xFFFFFFFE00000000</value>
    </enumerator>
    <enumerator>
      <name>16_MB</name>
      <value>0xFFFFFFFF00000000</value>
    </enumerator>
    <enumerator>
      <name>8_MB</name>
      <value>0xFFFFFFFF80000000</value>
    </enumerator>
    <enumerator>
      <name>4_MB</name>
      <value>0xFFFFFFFFC0000000</value>
    </enumerator>
    <enumerator>
      <name>2_MB</name>
      <value>0xFFFFFFFFE0000000</value>
    </enumerator>
    <enumerator>
      <name>1_MB</name>
      <value>0xFFFFFFFFF0000000</value>
    </enumerator>
    <enumerator>
      <name>512_KB</name>
      <value>0xFFFFFFFFF8000000</value>
    </enumerator>
    <enumerator>
      <name>256_KB</name>
      <value>0xFFFFFFFFFC000000</value>
    </enumerator>
    <enumerator>
      <name>128_KB</name>
      <value>0xFFFFFFFFFE000000</value>
    </enumerator>
    <enumerator>
      <name>64_KB</name>
      <value>0xFFFFFFFFFF000000</value>
    </enumerator>
    <enumerator>
      <name>16_KB</name>
      <value>0xFFFFFFFFFFFFFFFF</value>
    </enumerator>
    <id>PROC_PCIE_BAR_SIZE</id>
  </enumerationType>
  <enumerationType>
    <description>FSP BAR enable creator: platform consumer: p9_setup_bars firmware notes: none</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_FSP_BAR_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>FSP BAR size value creator: platform consumer: p9_setup_bars firmware notes: none</description>
    <enumerator>
      <name>4_GB</name>
      <value>0xFFFFFC00FFFFFFFF</value>
    </enumerator>
    <enumerator>
      <name>2_GB</name>
      <value>0xFFFFFC007FFFFFFF</value>
    </enumerator>
    <enumerator>
      <name>1_GB</name>
      <value>0xFFFFFC003FFFFFFF</value>
    </enumerator>
    <enumerator>
      <name>512_MB</name>
      <value>0xFFFFFC001FFFFFFF</value>
    </enumerator>
    <enumerator>
      <name>256_MB</name>
      <value>0xFFFFFC000FFFFFFF</value>
    </enumerator>
    <enumerator>
      <name>128_MB</name>
      <value>0xFFFFFC0007FFFFFF</value>
    </enumerator>
    <enumerator>
      <name>64_MB</name>
      <value>0xFFFFFC0003FFFFFF</value>
    </enumerator>
    <enumerator>
      <name>32_MB</name>
      <value>0xFFFFFC0001FFFFFF</value>
    </enumerator>
    <enumerator>
      <name>16_MB</name>
      <value>0xFFFFFC0000FFFFFF</value>
    </enumerator>
    <enumerator>
      <name>8_MB</name>
      <value>0xFFFFFC00007FFFFF</value>
    </enumerator>
    <enumerator>
      <name>4_MB</name>
      <value>0xFFFFFC00003FFFFF</value>
    </enumerator>
    <enumerator>
      <name>2_MB</name>
      <value>0xFFFFFC00001FFFFF</value>
    </enumerator>
    <enumerator>
      <name>1_MB</name>
      <value>0xFFFFFC00000FFFFF</value>
    </enumerator>
    <id>PROC_FSP_BAR_SIZE</id>
  </enumerationType>
  <enumerationType>
    <description>FSP MMIO mask size value creator: platform consumer: p9_setup_bars firmware notes: AND mask applied to RA 32:35 when transmitting address to FSP NOTE: RA 8:31 are always replaced with zero</description>
    <enumerator>
      <name>4_GB</name>
      <value>0x00F0000000000000</value>
    </enumerator>
    <enumerator>
      <name>2_GB</name>
      <value>0x0070000000000000</value>
    </enumerator>
    <enumerator>
      <name>1_GB</name>
      <value>0x0030000000000000</value>
    </enumerator>
    <enumerator>
      <name>512_MB</name>
      <value>0x0010000000000000</value>
    </enumerator>
    <enumerator>
      <name>256_MB</name>
      <value>0x0000000000000000</value>
    </enumerator>
    <id>PROC_FSP_MMIO_MASK_SIZE</id>
  </enumerationType>
  <enumerationType>
    <description>NPU PHY0 (stack0) BAR enable creator: platform consumer: p9_setup_bars firmware notes: none</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_NPU_PHY0_BAR_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>NPU PHY1 (stack1) BAR enable creator: platform consumer: p9_setup_bars firmware notes: none</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_NPU_PHY1_BAR_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>NPU MMIO (stack2) BAR enable creator: platform consumer: p9_setup_bars firmware notes: none</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_NPU_MMIO_BAR_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>PSI Bridge BAR enable creator: platform consumer: p9_setup_bars firmware notes: none</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_PSI_BRIDGE_BAR_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>NX RNG BAR enable creator: platform consumer: p9_rng_init_phase2 firmware notes: none</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_NX_RNG_BAR_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Enable optional post of interrupt when both NX RNG noise sources have failed creator: platform consumer: p9_rng_init_phase2 firmware notes: none</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_NX_RNG_FAILED_INT_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>INT CQ PC BAR enable creator: platform consumer: p9_setup_bars firmware notes: none</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_INT_CQ_PC_BAR_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>INT CQ VC BAR enable creator: platform consumer: p9_setup_bars firmware notes: none</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_INT_CQ_VC_BAR_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>INT CQ TM1 BAR enable creator: platform consumer: p9_setup_bars firmware notes: none</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_INT_CQ_TM1_BAR_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>INT CQ TM1 BAR page size creator: platform consumer: p9_setup_bars firmware notes: none</description>
    <enumerator>
      <name>4K</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>64K</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_INT_CQ_TM1_BAR_PAGE_SIZE</id>
  </enumerationType>
  <enumerationType>
    <description>INT CQ IC BAR enable creator: platform consumer: p9_setup_bars firmware notes: none</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_INT_CQ_IC_BAR_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>INT CQ IC (Interrupt Controller) BAR page size creator: platform consumer: p9_setup_bars firmware notes: none</description>
    <enumerator>
      <name>4K</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>64K</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_INT_CQ_IC_BAR_PAGE_SIZE</id>
  </enumerationType>
  <enumerationType>
    <description>Indicates istep IPL</description>
    <enumerator>
      <name>NON_IPL</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>IPL</name>
      <value>0x1</value>
    </enumerator>
    <id>ISTEP_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Indicates that SBE should go directly to runtime functionality</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x1</value>
    </enumerator>
    <id>SBE_RUNTIME_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Indicates whether we are connected to FSP or not</description>
    <enumerator>
      <name>FSP_LESS</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>FSP</name>
      <value>0x1</value>
    </enumerator>
    <id>IS_SP_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Indicates whether SBE should collect FFDC</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x1</value>
    </enumerator>
    <id>SBE_FFDC_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Indicates that the SBE should send back internal FFDC on any chipOp failure response</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x1</value>
    </enumerator>
    <id>SBE_INTERNAL_FFDC_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>HWP/Init "risk level" enabled. Used by HB to pass to HB driven HWPs</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x1</value>
    </enumerator>
    <id>RISK_LEVEL</id>
  </enumerationType>
  <enumerationType>
    <description>BootLoader HWP flag to not place 12K exception vectors. This flag is only applicable when security is disabled.</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x1</value>
    </enumerator>
    <id>DISABLE_HBBL_VECTORS</id>
  </enumerationType>
  <enumerationType>
    <description>Indicates if SBE on this chip is serving as hosboot drawer master</description>
    <enumerator>
      <name>FALSE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_SBE_MASTER_CHIP</id>
  </enumerationType>
  <enumerationType>
    <description>Defines system specific value of processor refclock receiver termination</description>
    <enumerator>
      <name>NONE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>FIFTY_OHM</name>
      <value>1</value>
    </enumerator>
    <id>CP_REFCLOCK_RCVR_TERM</id>
  </enumerationType>
  <enumerationType>
    <description>Defines system specific value of PCI refclock receiver termination</description>
    <enumerator>
      <name>NONE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>FIFTY_OHM</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ONE_HUNDRED_OHM</name>
      <value>3</value>
    </enumerator>
    <id>IO_REFCLOCK_RCVR_TERM</id>
  </enumerationType>
  <enumerationType>
    <description>Control CME response to execution of PowerPC STOP instruction if OFF, treat STOP4 as STOP4 if ON, treat STOP4 as STOP2 Producer: Work-around tools Consumer: p9_hcode_image_build.C Platform default: OFF</description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <id>STOP4_DISABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Control CME response to execution of PowerPC STOP instruction if OFF, treat STOP5 as STOP5 if ON, treat STOP5 as STOP4 Producer: ??? Consumer: p9_hcode_image_build.C Platform default: ON</description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <id>STOP5_DISABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Control CME response to execution of PowerPC STOP instruction if OFF, treat STOP8 as STOP8 if ON, treat STOP8 as STOP4 Producer: Work-around tools Consumer: p9_hcode_image_build.C Platform default: OFF</description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <id>STOP8_DISABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Control CME response to execution of PowerPC STOP instruction if OFF, treat STOP11 as STOP11 if ON, treat STOP11 as STOP8 Producer: Work-around tools Consumer: p9_hcode_image_build.C Platform default: OFF</description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <id>STOP11_DISABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Disables Work Load Optimized Frequency (WOF) algorithms to modify frequency based on active core count and other inputs. OFF: Will enable WOF given all validity check pass. If validity checks fail, WOF will be disabled for the present IPL. ON: Will disable WOF OFF_SKIP_DD: Same as OFF but skips any validity checking of the chip design level (lab use only). Producer: Override Consumers: p9_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB) for PGPE/OCC</description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>OFF_SKIP_DD</name>
      <value>2</value>
    </enumerator>
    <id>SYSTEM_WOF_DISABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Disables IVRM enablement in the system Producer: Override Consumers: p9_build_pstate_datablock -&gt; Pstate Parameter Block (PSPB) for PGPE/OCC CME Quad Pstate Region (CQPR) for CM Quad Manager</description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <id>SYSTEM_IVRM_DISABLE</id>
  </enumerationType>
  <enumerationType>
    <description>If wof_enabled, defines the Frequency Ratio calculation performed. (THIS IS NOT SUPPORTED IN P9 GA1!).</description>
    <enumerator>
      <name>FIXED</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>STEPPED</name>
      <value>1</value>
    </enumerator>
    <id>WOF_ENABLE_FRATIO</id>
  </enumerationType>
  <enumerationType>
    <description>If wof_enabled, defines the Voltage Ratio calculation performed. THIS IS NOT SUPPORTED AT PRESENT. GA1 SUPPORT IS TBD).</description>
    <enumerator>
      <name>FIXED</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>STEPPED</name>
      <value>1</value>
    </enumerator>
    <id>WOF_ENABLE_VRATIO</id>
  </enumerationType>
  <enumerationType>
    <description>If wof_enabled AND ATTR_WOF_ENABLE_VRATIO = CALCULATED, this attribute selects the Vratio calculation type. ACTIVE_CORES: Vratio is the number of active cores to the number of good cores FULL: Vratio is Vaverage to Vclip(Fclip) where Vclip(Fclip) is the normal interpolated regulator voltage (including load line uplife @ RDP current) derated with presently measured Idd current (from the AVSBus) and the loadline.</description>
    <enumerator>
      <name>ACTIVE_CORES</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>FULL</name>
      <value>1</value>
    </enumerator>
    <id>WOF_VRATIO_SELECT</id>
  </enumerationType>
  <enumerationType>
    <description>Voltage Droop Monitor (VDM) Small Threshold Select Value per VPD point The enum indicates a negative value below the VDM setting that will trigger a small droop event. Array of 5 entries: 0 = PowerSave, 1 = Nominal; 2 = Turbo; 3 = UltraTurbo; 4 = Enable If index 4 is non-zero, the other entries are considered valid. Producer: Override</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>8mV</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>16mV</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>24mV</name>
      <value>0x03</value>
    </enumerator>
    <enumerator>
      <name>32mV</name>
      <value>0x04</value>
    </enumerator>
    <enumerator>
      <name>40mV</name>
      <value>0x05</value>
    </enumerator>
    <enumerator>
      <name>48mV</name>
      <value>0x06</value>
    </enumerator>
    <enumerator>
      <name>56mV</name>
      <value>0x07</value>
    </enumerator>
    <enumerator>
      <name>64mV</name>
      <value>0x08</value>
    </enumerator>
    <enumerator>
      <name>72mV</name>
      <value>0x09</value>
    </enumerator>
    <enumerator>
      <name>80mV</name>
      <value>0x0A</value>
    </enumerator>
    <enumerator>
      <name>88mV</name>
      <value>0x0B</value>
    </enumerator>
    <enumerator>
      <name>92mV</name>
      <value>0x0C</value>
    </enumerator>
    <enumerator>
      <name>96mV</name>
      <value>0x0D</value>
    </enumerator>
    <id>VDM_DROOP_SMALL_OVERRIDE</id>
  </enumerationType>
  <enumerationType>
    <description>Voltage Droop Monitor (VDM) Large Threshold Select Value per VPD point The enum indicates a negative value below the VDM setting that will trigger a large droop event. Array of 5 entries: 0 = PowerSave, 1 = Nominal; 2 = Turbo; 3 = UltraTurbo; 4 = Enable If index 4 is non-zero, the other entries are considered valid. Producer: Override</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>8mV</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>16mV</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>24mV</name>
      <value>0x03</value>
    </enumerator>
    <enumerator>
      <name>32mV</name>
      <value>0x04</value>
    </enumerator>
    <enumerator>
      <name>40mV</name>
      <value>0x05</value>
    </enumerator>
    <enumerator>
      <name>48mV</name>
      <value>0x06</value>
    </enumerator>
    <enumerator>
      <name>56mV</name>
      <value>0x07</value>
    </enumerator>
    <enumerator>
      <name>64mV</name>
      <value>0x08</value>
    </enumerator>
    <enumerator>
      <name>72mV</name>
      <value>0x09</value>
    </enumerator>
    <enumerator>
      <name>80mV</name>
      <value>0x0A</value>
    </enumerator>
    <enumerator>
      <name>88mV</name>
      <value>0x0B</value>
    </enumerator>
    <enumerator>
      <name>92mV</name>
      <value>0x0C</value>
    </enumerator>
    <enumerator>
      <name>96mV</name>
      <value>0x0D</value>
    </enumerator>
    <id>VDM_DROOP_LARGE_OVERRIDE</id>
  </enumerationType>
  <enumerationType>
    <description>Voltage Droop Monitor (VDM) Extreme Threshold Select Value per VPD point. The enum indicates a negative value below the VDM setting that will trigger an extreme droop event. Array of 5 entries: 0 = PowerSave, 1 = Nominal; 2 = Turbo; 3 = UltraTurbo; 4 = Enable If index 4 is non-zero, the other entries are considered valid. Producer: Override</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>8mV</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>16mV</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>24mV</name>
      <value>0x03</value>
    </enumerator>
    <enumerator>
      <name>32mV</name>
      <value>0x04</value>
    </enumerator>
    <enumerator>
      <name>40mV</name>
      <value>0x05</value>
    </enumerator>
    <enumerator>
      <name>48mV</name>
      <value>0x06</value>
    </enumerator>
    <enumerator>
      <name>56mV</name>
      <value>0x07</value>
    </enumerator>
    <enumerator>
      <name>64mV</name>
      <value>0x08</value>
    </enumerator>
    <enumerator>
      <name>72mV</name>
      <value>0x09</value>
    </enumerator>
    <enumerator>
      <name>80mV</name>
      <value>0x0A</value>
    </enumerator>
    <enumerator>
      <name>88mV</name>
      <value>0x0B</value>
    </enumerator>
    <enumerator>
      <name>92mV</name>
      <value>0x0C</value>
    </enumerator>
    <enumerator>
      <name>96mV</name>
      <value>0x0D</value>
    </enumerator>
    <id>VDM_DROOP_EXTREME_OVERRIDE</id>
  </enumerationType>
  <enumerationType>
    <description>Voltage Droop Monitor (VDM) OverVoltage Threshold Select Value per VPD point. The enum indicates a positive value above the VDM setting that will indicate an overvolt droop condition. Array of 5 entries: 0 = PowerSave, 1 = Nominal; 2 = Turbo; 3 = UltraTurbo; 4 = Enable If index 4 is non-zero, the other entries are considered valid. Producer: Override</description>
    <enumerator>
      <name>FORCE</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>8mV</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>16mV</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>24mV</name>
      <value>0x03</value>
    </enumerator>
    <enumerator>
      <name>32mV</name>
      <value>0x04</value>
    </enumerator>
    <enumerator>
      <name>40mV</name>
      <value>0x05</value>
    </enumerator>
    <enumerator>
      <name>48mV</name>
      <value>0x06</value>
    </enumerator>
    <enumerator>
      <name>56mV</name>
      <value>0x07</value>
    </enumerator>
    <enumerator>
      <name>64mV</name>
      <value>0x08</value>
    </enumerator>
    <id>VDM_OVERVOLT_OVERRIDE</id>
  </enumerationType>
  <enumerationType>
    <description>Controls the enablement of Voltage Droop Monitors (VDM) to throttle the core upon an extreme droop event. Producer: Machine Readable Workbook Consumers: p9_hcode_image_build to set flag for CME QuadManager Hcode reaction</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <id>VDM_EXTREME_THOTTLE_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Indicates the response of the DPLL frequency upon VDM events if ATTR_SYSTEM_VDM_DISABLE is not ON. NONE -&gt; DPLL Mode 2 DROOP_PROTECT -&gt; DPLL Mode 3 DROOP_PROTECT_OVERVOLT -&gt; DPLL Mode 3.5 DYNAMIC -&gt; DPLL Mode 4 DYNAMIC_PROTECT -&gt; DPLL Mode 5 Producer: MRWB.</description>
    <enumerator>
      <name>DROOP_PROTECT</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>DROOP_PROTECT_OVERVOLT</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>DYNAMIC</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>DYNAMIC_PROTECT</name>
      <value>0x03</value>
    </enumerator>
    <enumerator>
      <name>NONE</name>
      <value>0x04</value>
    </enumerator>
    <id>DPLL_VDM_RESPONSE</id>
  </enumerationType>
  <enumerationType>
    <description>Disables the enablement of resonant clocking in the system. Producer: Override Consumers: p9_pstate_parameter_block to clear the flag for CME QuadManager Hcode reaction</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <id>SYSTEM_RESCLK_DISABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Debug modes supported for CME/SGPE Scan layout in HOMER.</description>
    <enumerator>
      <name>SCAN_RING_NO_DEBUG</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>SCAN_RING_TRACE_DEBUG</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>SCAN_RING_DEEP_DEBUG</name>
      <value>0x02</value>
    </enumerator>
    <id>SYSTEM_RING_DBG_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Enables the SGPE Hcode to enable the CME instruction traces into the L3 Trace array for debug. Note: all configured CMEs will be put into this mode if this attribute is ON. Consumer: p9_hcode_image_build.c -&gt; SGPE Header field Platform default: OFF</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <id>CME_INSTRUCTION_TRACE_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Enables the SGPE Hcode to enable the CME instruction traces into the CHTM for debug. Note: all configured CMEs will be put into this mode if this attribute is ON. Consumer: p9_hcode_image_build.c -&gt; SGPE Header field Platform default: OFF</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <id>CME_CHTM_TRACE_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Enables the PGPE Hcode to physically perform frequency and voltage operations based on constructed parameters (eg #V VPD, system parameters, biases, WPF VFRTs. etc). If OFF, the PGPE provides an immedicate good response to all Pstate/WOF IPC operations from the OCC for firmware integration testing purposes. Consumer: p9_hcode_image_build.c -&gt; PGPE Header field Platform default: ON</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <id>PGPE_HCODE_FUNCTION_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Enables pstate parameter block code to use the static #W data Consumer: p9_pstate_parameter_block.C -&gt; Platform default: OFF</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <id>POUND_W_STATIC_DATA_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Enables pstate parameter block code to use the static system vfrt data Consumer: p9_pstate_parameter_block.C -&gt; Platform default: OFF</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <id>SYS_VFRT_STATIC_DATA_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Controls the mode of Pstate Protocol for testing. ON: Boots the PGPE in "OCC Pstate Mode" but does NOT start the Pstate protocol OFF: Does NOT boot the PGPE AUTO: Boots the PGPE and automatically starts the Pstate protocol. PMCR operations to move Pstates are honored Producer: Override Consumers: p9_pstate_parameter_block and p9_pm_pstate_gpe_init</description>
    <enumerator>
      <name>ON</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>OFF</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>AUTO</name>
      <value>0x02</value>
    </enumerator>
    <id>SYSTEM_PSTATES_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Product name of a chip target. Provided by the MRW.</description>
    <enumerator>
      <name>NONE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>CENTAUR</name>
      <value>0x3</value>
    </enumerator>
    <enumerator>
      <name>NIMBUS</name>
      <value>0x5</value>
    </enumerator>
    <enumerator>
      <name>CUMULUS</name>
      <value>0x6</value>
    </enumerator>
    <id>NAME</id>
  </enumerationType>
  <enumerationType>
    <description>1 if the target is functional, else 0. Set by the platform.</description>
    <enumerator>
      <name>NON_FUNCTIONAL</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>FUNCTIONAL</name>
      <value>0x1</value>
    </enumerator>
    <id>FUNCTIONAL</id>
  </enumerationType>
  <enumerationType>
    <description>Which execution platform the HW Procedure is running on Some HWPs (e.g. special wakeup) use different registers for different platforms to avoid arbitration problems when multiple platforms do the same thing concurrently</description>
    <enumerator>
      <name>HOST</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>FSP</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>OCC</name>
      <value>0x03</value>
    </enumerator>
    <id>EXECUTION_PLATFORM</id>
  </enumerationType>
  <enumerationType>
    <description>The manufacturing flags. This is a bitfield. Each bit is a flag and multiple flags can be set</description>
    <enumerator>
      <name>MNFG_NO_FLAG</name>
      <value>0x0000000000000000</value>
    </enumerator>
    <enumerator>
      <name>MNFG_THRESHOLDS</name>
      <value>0x0000000000000001</value>
    </enumerator>
    <enumerator>
      <name>MNFG_DISABLE_DRAM_REPAIRS</name>
      <value>0x0000000000000080</value>
    </enumerator>
    <enumerator>
      <name>MNFG_ENABLE_STANDARD_PATTERN_TEST</name>
      <value>0x0000000000000200</value>
    </enumerator>
    <id>MNFG_FLAGS</id>
  </enumerationType>
  <enumerationType>
    <description>Spare DRAM availability for all DIMMs connected to the target MBA. For each rank on a DIMM, there are 8 DQ lines to spare DRAMs. - NO_SPARE: No spare DRAMs - LOW_NIBBLE: x4 DRAMs in use, one spare DRAM connected to SP_DQ0-3 - HIGH_NIBBLE: x4 DRAMs in use, one spare DRAM connected to SP_DQ4-7 - FULL_BYTE: Either 1/ x4 DRAMs in use, two spare DRAMs connected to SP_DQ0-7 2/ x8 DRAMs in use, one spare DRAM connected to SP_DQ0-7 For C-DIMMs, this is in a VPD field : Record:VSPD, Keyword:AM</description>
    <enumerator>
      <name>NO_SPARE</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>LOW_NIBBLE</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>HIGH_NIBBLE</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>FULL_BYTE</name>
      <value>0x03</value>
    </enumerator>
    <id>CEN_VPD_DIMM_SPARE</id>
  </enumerationType>
  <enumerationType>
    <description>RCD Timing. Supplied by VPD, used by mss_eff_config.C. Each dimm will have a value. consumer: mss_eff_config</description>
    <enumerator>
      <name>1T</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>3T</name>
      <value>0x03</value>
    </enumerator>
    <id>CEN_VPD_DIMM_RCD_OUTPUT_TIMING</id>
  </enumerationType>
  <enumerationType>
    <description>The VPD Version of this DIMM. The version number can be an indication of when different DIMM keywords are valid and is loaded from the platform. The version represented here represents one of three distinct vintages of parts : unknown/error, early build CDIMMs with VZ less than 10, everything else. In other words, this attribute does NOT equate to the VZ keyword.</description>
    <enumerator>
      <name>UNKNOWN</name>
      <value>0x3030</value>
    </enumerator>
    <enumerator>
      <name>OLD_CDIMM</name>
      <value>0x3031</value>
    </enumerator>
    <enumerator>
      <name>CURRENT</name>
      <value>0x3230</value>
    </enumerator>
    <id>CEN_VPD_VERSION</id>
  </enumerationType>
  <enumerationType>
    <description>The C-DIMM ranks that have address mirroring. This data is in the Record:VSPD, Keyword:AM field in C-DIMM VPD. This attribute is only valid for C-DIMMs, an error should be returned if queried from IS-DIMMs. Note: Muliple ranks can be mirrored.</description>
    <enumerator>
      <name>RANK0_MIRRORED</name>
      <value>0x08</value>
    </enumerator>
    <enumerator>
      <name>RANK1_MIRRORED</name>
      <value>0x04</value>
    </enumerator>
    <enumerator>
      <name>RANK2_MIRRORED</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>RANK3_MIRRORED</name>
      <value>0x01</value>
    </enumerator>
    <id>CEN_VPD_DRAM_ADDRESS_MIRRORING</id>
  </enumerationType>
  <enumerationType>
    <description>DRAM Ron. Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. OHM48 is for DDR4. creator: VPD(MT)/mss_eff_cnfg_termination consumer: various.C files (no initfile) firmware notes: none This Attribute is to be interpreted as an Integer</description>
    <enumerator>
      <name>INVALID</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>OHM34</name>
      <value>34</value>
    </enumerator>
    <enumerator>
      <name>OHM40</name>
      <value>40</value>
    </enumerator>
    <enumerator>
      <name>OHM48</name>
      <value>48</value>
    </enumerator>
    <id>CEN_VPD_DRAM_RON</id>
  </enumerationType>
  <enumerationType>
    <description>DRAM Rtt_Nom. Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT),mss_eff_cnfg_termination consumer: various.C files (no initfiles) firmware notes: none This Attribute is to be interpreted as an Integer</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>OHM20</name>
      <value>20</value>
    </enumerator>
    <enumerator>
      <name>OHM30</name>
      <value>30</value>
    </enumerator>
    <enumerator>
      <name>OHM34</name>
      <value>34</value>
    </enumerator>
    <enumerator>
      <name>OHM40</name>
      <value>40</value>
    </enumerator>
    <enumerator>
      <name>OHM48</name>
      <value>48</value>
    </enumerator>
    <enumerator>
      <name>OHM60</name>
      <value>60</value>
    </enumerator>
    <enumerator>
      <name>OHM80</name>
      <value>80</value>
    </enumerator>
    <enumerator>
      <name>OHM120</name>
      <value>120</value>
    </enumerator>
    <enumerator>
      <name>OHM240</name>
      <value>240</value>
    </enumerator>
    <id>CEN_VPD_DRAM_RTT_NOM</id>
  </enumerationType>
  <enumerationType>
    <description>DRAM Rtt_WR. Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Creator: VPD(MT), mss_eff_cnfg_termination consumer: various.C files (no initfiles) firmware notes: none This Attribute is to be interpreted as an Integer</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>OHM60</name>
      <value>60</value>
    </enumerator>
    <enumerator>
      <name>OHM120</name>
      <value>120</value>
    </enumerator>
    <enumerator>
      <name>OHM240</name>
      <value>240</value>
    </enumerator>
    <enumerator>
      <name>HIGHZ</name>
      <value>1</value>
    </enumerator>
    <id>CEN_VPD_DRAM_RTT_WR</id>
  </enumerationType>
  <enumerationType>
    <description>DRAM Rtt_PARK. Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. RTT_Park value. This is for DDR4 MRS5.Each memory channel will have a value. Creator: VPD(MT), mss_eff_cnfg_termination consumer: various.C files (no initfiles) firmware notes: none This Attribute is to be interpreted as an Integer</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>60OHM</name>
      <value>60</value>
    </enumerator>
    <enumerator>
      <name>120OHM</name>
      <value>120</value>
    </enumerator>
    <enumerator>
      <name>40OHM</name>
      <value>40</value>
    </enumerator>
    <enumerator>
      <name>240OHM</name>
      <value>240</value>
    </enumerator>
    <enumerator>
      <name>48OHM</name>
      <value>48</value>
    </enumerator>
    <enumerator>
      <name>80OHM</name>
      <value>80</value>
    </enumerator>
    <enumerator>
      <name>34OHM</name>
      <value>34</value>
    </enumerator>
    <id>CEN_VPD_DRAM_RTT_PARK</id>
  </enumerationType>
  <enumerationType>
    <description>DRAM Write Vref. Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT) or mss_eff_cnfg_termination consumer: various.C and initfile firmware notes: none This is the nominal value This is for DDR3 This Attribute is to be interpreted as an Integer</description>
    <enumerator>
      <name>VDD420</name>
      <value>420</value>
    </enumerator>
    <enumerator>
      <name>VDD425</name>
      <value>425</value>
    </enumerator>
    <enumerator>
      <name>VDD430</name>
      <value>430</value>
    </enumerator>
    <enumerator>
      <name>VDD435</name>
      <value>435</value>
    </enumerator>
    <enumerator>
      <name>VDD440</name>
      <value>440</value>
    </enumerator>
    <enumerator>
      <name>VDD445</name>
      <value>445</value>
    </enumerator>
    <enumerator>
      <name>VDD450</name>
      <value>450</value>
    </enumerator>
    <enumerator>
      <name>VDD455</name>
      <value>455</value>
    </enumerator>
    <enumerator>
      <name>VDD460</name>
      <value>460</value>
    </enumerator>
    <enumerator>
      <name>VDD465</name>
      <value>465</value>
    </enumerator>
    <enumerator>
      <name>VDD470</name>
      <value>470</value>
    </enumerator>
    <enumerator>
      <name>VDD475</name>
      <value>475</value>
    </enumerator>
    <enumerator>
      <name>VDD480</name>
      <value>480</value>
    </enumerator>
    <enumerator>
      <name>VDD485</name>
      <value>485</value>
    </enumerator>
    <enumerator>
      <name>VDD490</name>
      <value>490</value>
    </enumerator>
    <enumerator>
      <name>VDD495</name>
      <value>495</value>
    </enumerator>
    <enumerator>
      <name>VDD500</name>
      <value>500</value>
    </enumerator>
    <enumerator>
      <name>VDD505</name>
      <value>505</value>
    </enumerator>
    <enumerator>
      <name>VDD510</name>
      <value>510</value>
    </enumerator>
    <enumerator>
      <name>VDD515</name>
      <value>515</value>
    </enumerator>
    <enumerator>
      <name>VDD520</name>
      <value>520</value>
    </enumerator>
    <enumerator>
      <name>VDD525</name>
      <value>525</value>
    </enumerator>
    <enumerator>
      <name>VDD530</name>
      <value>530</value>
    </enumerator>
    <enumerator>
      <name>VDD535</name>
      <value>535</value>
    </enumerator>
    <enumerator>
      <name>VDD540</name>
      <value>540</value>
    </enumerator>
    <enumerator>
      <name>VDD545</name>
      <value>545</value>
    </enumerator>
    <enumerator>
      <name>VDD550</name>
      <value>550</value>
    </enumerator>
    <enumerator>
      <name>VDD555</name>
      <value>555</value>
    </enumerator>
    <enumerator>
      <name>VDD560</name>
      <value>560</value>
    </enumerator>
    <enumerator>
      <name>VDD565</name>
      <value>565</value>
    </enumerator>
    <enumerator>
      <name>VDD570</name>
      <value>570</value>
    </enumerator>
    <enumerator>
      <name>VDD575</name>
      <value>575</value>
    </enumerator>
    <id>CEN_VPD_DRAM_WR_VREF</id>
  </enumerationType>
  <enumerationType>
    <description>Centaur DQ and DQS Drive Impedance Used in various locations and comes from the MT Keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT)/mss_eff_cnfg_termination consumer: initfile,various.C files firmware notes: none This is the nominal value This Attribute is to be interpreted as an Integer</description>
    <enumerator>
      <name>OHM24_FFE0</name>
      <value>0x0A</value>
    </enumerator>
    <enumerator>
      <name>OHM30_FFE0</name>
      <value>0x08</value>
    </enumerator>
    <enumerator>
      <name>OHM30_FFE480</name>
      <value>0x48</value>
    </enumerator>
    <enumerator>
      <name>OHM30_FFE240</name>
      <value>0x38</value>
    </enumerator>
    <enumerator>
      <name>OHM30_FFE160</name>
      <value>0x28</value>
    </enumerator>
    <enumerator>
      <name>OHM30_FFE120</name>
      <value>0x18</value>
    </enumerator>
    <enumerator>
      <name>OHM34_FFE0</name>
      <value>0x07</value>
    </enumerator>
    <enumerator>
      <name>OHM34_FFE480</name>
      <value>0x47</value>
    </enumerator>
    <enumerator>
      <name>OHM34_FFE240</name>
      <value>0x37</value>
    </enumerator>
    <enumerator>
      <name>OHM34_FFE160</name>
      <value>0x27</value>
    </enumerator>
    <enumerator>
      <name>OHM34_FFE120</name>
      <value>0x17</value>
    </enumerator>
    <enumerator>
      <name>OHM40_FFE0</name>
      <value>0x06</value>
    </enumerator>
    <enumerator>
      <name>OHM40_FFE480</name>
      <value>0x46</value>
    </enumerator>
    <enumerator>
      <name>OHM40_FFE240</name>
      <value>0x36</value>
    </enumerator>
    <enumerator>
      <name>OHM40_FFE160</name>
      <value>0x26</value>
    </enumerator>
    <enumerator>
      <name>OHM40_FFE120</name>
      <value>0x16</value>
    </enumerator>
    <id>CEN_VPD_DRV_IMP_DQ_DQS</id>
  </enumerationType>
  <enumerationType>
    <description>Centaur Address Drive Impedance Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: mss_eff_cnfg_termination consumer: initfile and various.C firmware notes: none This is the nominal value This Attribute is to be interpreted as an Integer</description>
    <enumerator>
      <name>OHM15</name>
      <value>15</value>
    </enumerator>
    <enumerator>
      <name>OHM20</name>
      <value>20</value>
    </enumerator>
    <enumerator>
      <name>OHM30</name>
      <value>30</value>
    </enumerator>
    <enumerator>
      <name>OHM40</name>
      <value>40</value>
    </enumerator>
    <id>CEN_VPD_DRV_IMP_ADDR</id>
  </enumerationType>
  <enumerationType>
    <description>Centaur Control Drive Impedance Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT)/mss_eff_cnfg_termination consumer: initfile,various .C firmware notes: none This is the nominal value This Attribute is to be interpreted as an Integer</description>
    <enumerator>
      <name>OHM15</name>
      <value>15</value>
    </enumerator>
    <enumerator>
      <name>OHM20</name>
      <value>20</value>
    </enumerator>
    <enumerator>
      <name>OHM30</name>
      <value>30</value>
    </enumerator>
    <enumerator>
      <name>OHM40</name>
      <value>40</value>
    </enumerator>
    <id>CEN_VPD_DRV_IMP_CNTL</id>
  </enumerationType>
  <enumerationType>
    <description>Centaur Clock Drive Impedance Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT),mss_eff_cnfg_termination consumer: initfiles,various firmware notes: none This is the nominal value This Attribute is to be interpreted as an Integer</description>
    <enumerator>
      <name>OHM15</name>
      <value>15</value>
    </enumerator>
    <enumerator>
      <name>OHM20</name>
      <value>20</value>
    </enumerator>
    <enumerator>
      <name>OHM30</name>
      <value>30</value>
    </enumerator>
    <enumerator>
      <name>OHM40</name>
      <value>40</value>
    </enumerator>
    <id>CEN_VPD_DRV_IMP_CLK</id>
  </enumerationType>
  <enumerationType>
    <description>Centaur Spare Clock Drive Impedance Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT) , mss_eff_cnfg_termination consumer: initfiles, various.C firmware notes: none This is the nominal value This Attribute is to be interpreted as an Integer</description>
    <enumerator>
      <name>OHM15</name>
      <value>15</value>
    </enumerator>
    <enumerator>
      <name>OHM20</name>
      <value>20</value>
    </enumerator>
    <enumerator>
      <name>OHM30</name>
      <value>30</value>
    </enumerator>
    <enumerator>
      <name>OHM40</name>
      <value>40</value>
    </enumerator>
    <id>CEN_VPD_DRV_IMP_SPCKE</id>
  </enumerationType>
  <enumerationType>
    <description>Centaur DQ and DQS Receiver Impedance Used in various locations and it comes from the VPD MT keyword for custom DIMMs or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD, mss_eff_cnfg_termination Consumer: initfile + C code firmware notes: none This is the nominal value This Attribute is to be interpreted as an Integer</description>
    <enumerator>
      <name>OHM15</name>
      <value>15</value>
    </enumerator>
    <enumerator>
      <name>OHM20</name>
      <value>20</value>
    </enumerator>
    <enumerator>
      <name>OHM30</name>
      <value>30</value>
    </enumerator>
    <enumerator>
      <name>OHM40</name>
      <value>40</value>
    </enumerator>
    <enumerator>
      <name>OHM48</name>
      <value>48</value>
    </enumerator>
    <enumerator>
      <name>OHM60</name>
      <value>60</value>
    </enumerator>
    <enumerator>
      <name>OHM80</name>
      <value>80</value>
    </enumerator>
    <enumerator>
      <name>OHM120</name>
      <value>120</value>
    </enumerator>
    <enumerator>
      <name>OHM160</name>
      <value>160</value>
    </enumerator>
    <enumerator>
      <name>OHM240</name>
      <value>240</value>
    </enumerator>
    <id>CEN_VPD_RCV_IMP_DQ_DQS</id>
  </enumerationType>
  <enumerationType>
    <description>Centaur DQ and DQS Slew Rate Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Slowest slew rate is 0, incrementing by one. The lower the number the slower the slew rate the higher the faster. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT), mss_eff_cnfg_termination consumer: initfiles,various.C firmware notes: none This is the nominal value This Attribute is to be interpreted as an Integer except MAX</description>
    <enumerator>
      <name>SLEW_3V_NS</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>SLEW_4V_NS</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>SLEW_5V_NS</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>SLEW_6V_NS</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>SLEW_MAXV_NS</name>
      <value>7</value>
    </enumerator>
    <id>CEN_VPD_SLEW_RATE_DQ_DQS</id>
  </enumerationType>
  <enumerationType>
    <description>Centaur Address Slew Rate Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Slowest slew rate is 0, incrementing by one. The lower the number the slower the slew rate the higher the faster. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT),mss_eff_cnfg_termination consumer: initfile,various .C files firmware notes: none This is the nominal value This Attribute is to be interpreted as an Integer except Max</description>
    <enumerator>
      <name>SLEW_3V_NS</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>SLEW_4V_NS</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>SLEW_5V_NS</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>SLEW_6V_NS</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>SLEW_MAXV_NS</name>
      <value>7</value>
    </enumerator>
    <id>CEN_VPD_SLEW_RATE_ADDR</id>
  </enumerationType>
  <enumerationType>
    <description>Centaur Clock Slew Rate Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Slowest slew rate is 0, incrementing by one. The lower the number the slower the slew rate the higher the faster. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT)mss_eff_cnfg_termination consumer: initfile,various.C files firmware notes: none This is the nominal value This Attribute is to be interpreted as an Integer except max</description>
    <enumerator>
      <name>SLEW_3V_NS</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>SLEW_4V_NS</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>SLEW_5V_NS</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>SLEW_6V_NS</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>SLEW_MAXV_NS</name>
      <value>7</value>
    </enumerator>
    <id>CEN_VPD_SLEW_RATE_CLK</id>
  </enumerationType>
  <enumerationType>
    <description>Centaur Spare Clock Slew Rate Used in various locations and comes from the MT keyword or is computed in mss_eff_cnfg_termination. Slowest slew rate is 0, incrementing by one. The lower the number the slower the slew rate the higher the faster. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT) or mss_eff_cnfg_termination consumer: initfile,various.C firmware notes: none This is the nominal value This Attribute is to be interpreted as an Integer except max</description>
    <enumerator>
      <name>SLEW_3V_NS</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>SLEW_4V_NS</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>SLEW_5V_NS</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>SLEW_6V_NS</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>SLEW_MAXV_NS</name>
      <value>7</value>
    </enumerator>
    <id>CEN_VPD_SLEW_RATE_SPCKE</id>
  </enumerationType>
  <enumerationType>
    <description>Centaur Control Slew Rate Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Slowest slew rate is 0, incrementing by one. The lower the number the slower the slew rate the higher the faster. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT),mss_eff_cnfg_termination consumer:initfile, various .C files firmware notes: none This is the nominal value This Attribute is to be interpreted as an Integer except for max</description>
    <enumerator>
      <name>SLEW_3V_NS</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>SLEW_4V_NS</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>SLEW_5V_NS</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>SLEW_6V_NS</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>SLEW_MAXV_NS</name>
      <value>7</value>
    </enumerator>
    <id>CEN_VPD_SLEW_RATE_CNTL</id>
  </enumerationType>
  <enumerationType>
    <description>Centaur Read Vref. Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Creator: VPD(MT) or mss_eff_cnfg_termination consumer: various.C and initfiles firmware notes: none This is the nominal value This Attribute is to be interpreted as an Integer</description>
    <enumerator>
      <name>VDD40375</name>
      <value>40375</value>
    </enumerator>
    <enumerator>
      <name>VDD41750</name>
      <value>41750</value>
    </enumerator>
    <enumerator>
      <name>VDD43125</name>
      <value>43125</value>
    </enumerator>
    <enumerator>
      <name>VDD44500</name>
      <value>44500</value>
    </enumerator>
    <enumerator>
      <name>VDD45875</name>
      <value>45875</value>
    </enumerator>
    <enumerator>
      <name>VDD47250</name>
      <value>47250</value>
    </enumerator>
    <enumerator>
      <name>VDD48625</name>
      <value>48625</value>
    </enumerator>
    <enumerator>
      <name>VDD50000</name>
      <value>50000</value>
    </enumerator>
    <enumerator>
      <name>VDD51375</name>
      <value>51375</value>
    </enumerator>
    <enumerator>
      <name>VDD52750</name>
      <value>52750</value>
    </enumerator>
    <enumerator>
      <name>VDD54125</name>
      <value>54125</value>
    </enumerator>
    <enumerator>
      <name>VDD55500</name>
      <value>55500</value>
    </enumerator>
    <enumerator>
      <name>VDD56875</name>
      <value>56875</value>
    </enumerator>
    <enumerator>
      <name>VDD58250</name>
      <value>58250</value>
    </enumerator>
    <enumerator>
      <name>VDD59625</name>
      <value>59625</value>
    </enumerator>
    <enumerator>
      <name>VDD61000</name>
      <value>61000</value>
    </enumerator>
    <enumerator>
      <name>VDD60375</name>
      <value>60375</value>
    </enumerator>
    <enumerator>
      <name>VDD61750</name>
      <value>61750</value>
    </enumerator>
    <enumerator>
      <name>VDD63125</name>
      <value>63125</value>
    </enumerator>
    <enumerator>
      <name>VDD64500</name>
      <value>64500</value>
    </enumerator>
    <enumerator>
      <name>VDD65875</name>
      <value>65875</value>
    </enumerator>
    <enumerator>
      <name>VDD67250</name>
      <value>67250</value>
    </enumerator>
    <enumerator>
      <name>VDD68625</name>
      <value>68625</value>
    </enumerator>
    <enumerator>
      <name>VDD70000</name>
      <value>70000</value>
    </enumerator>
    <enumerator>
      <name>VDD71375</name>
      <value>71375</value>
    </enumerator>
    <enumerator>
      <name>VDD72750</name>
      <value>72750</value>
    </enumerator>
    <enumerator>
      <name>VDD74125</name>
      <value>74125</value>
    </enumerator>
    <enumerator>
      <name>VDD75500</name>
      <value>75500</value>
    </enumerator>
    <enumerator>
      <name>VDD76875</name>
      <value>76875</value>
    </enumerator>
    <enumerator>
      <name>VDD78250</name>
      <value>78250</value>
    </enumerator>
    <enumerator>
      <name>VDD79625</name>
      <value>79625</value>
    </enumerator>
    <enumerator>
      <name>VDD81000</name>
      <value>81000</value>
    </enumerator>
    <id>CEN_VPD_RD_VREF</id>
  </enumerationType>
  <enumerationType>
    <description>Describes if this MBA is in 2N address mode. The DIMM attributes associated with this MBA describes if this mode is needed for SI. Come from the VPD and consumed in the mba_def.initfile.</description>
    <enumerator>
      <name>FALSE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>1</value>
    </enumerator>
    <id>CEN_VPD_DRAM_2N_MODE_ENABLED</id>
  </enumerationType>
  <enumerationType>
    <description>Capable power control settings.</description>
    <enumerator>
      <name>NONE</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>SLOWEXIT_CAPABLE</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>FASTEXIT_CAPABLE</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>FASTSLOW_CAPABLE</name>
      <value>0x03</value>
    </enumerator>
    <id>CEN_VPD_POWER_CONTROL_CAPABLE</id>
  </enumerationType>
  <enumerationType>
    <description>FOR LAB USE ONLY: Frequency override of this memory channel in MHz, comprising of up to three DIMMs. Set by config file or an attribute writing program. Consumed by mss_freq. The default of AUTO means mss_freq will find the best frequencies given the DIMMs plugged in and other rules. Otherwise, this is the system frequency. firmware notes: Platforms should initialize this attribute to AUTO (0)</description>
    <enumerator>
      <name>AUTO</name>
      <value>0</value>
    </enumerator>
    <id>CEN_MSS_FREQ_OVERRIDE</id>
  </enumerationType>
  <enumerationType>
    <description>DRAM Write Vref. Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT) or mss_eff_cnfg_termination consumer: various.C and initfile firmware notes: none This is the nominal value This is for DDR3</description>
    <enumerator>
      <name>VDD420</name>
      <value>420</value>
    </enumerator>
    <enumerator>
      <name>VDD425</name>
      <value>425</value>
    </enumerator>
    <enumerator>
      <name>VDD430</name>
      <value>430</value>
    </enumerator>
    <enumerator>
      <name>VDD435</name>
      <value>435</value>
    </enumerator>
    <enumerator>
      <name>VDD440</name>
      <value>440</value>
    </enumerator>
    <enumerator>
      <name>VDD445</name>
      <value>445</value>
    </enumerator>
    <enumerator>
      <name>VDD450</name>
      <value>450</value>
    </enumerator>
    <enumerator>
      <name>VDD455</name>
      <value>455</value>
    </enumerator>
    <enumerator>
      <name>VDD460</name>
      <value>460</value>
    </enumerator>
    <enumerator>
      <name>VDD465</name>
      <value>465</value>
    </enumerator>
    <enumerator>
      <name>VDD470</name>
      <value>470</value>
    </enumerator>
    <enumerator>
      <name>VDD475</name>
      <value>475</value>
    </enumerator>
    <enumerator>
      <name>VDD480</name>
      <value>480</value>
    </enumerator>
    <enumerator>
      <name>VDD485</name>
      <value>485</value>
    </enumerator>
    <enumerator>
      <name>VDD490</name>
      <value>490</value>
    </enumerator>
    <enumerator>
      <name>VDD495</name>
      <value>495</value>
    </enumerator>
    <enumerator>
      <name>VDD500</name>
      <value>500</value>
    </enumerator>
    <enumerator>
      <name>VDD505</name>
      <value>505</value>
    </enumerator>
    <enumerator>
      <name>VDD510</name>
      <value>510</value>
    </enumerator>
    <enumerator>
      <name>VDD515</name>
      <value>515</value>
    </enumerator>
    <enumerator>
      <name>VDD520</name>
      <value>520</value>
    </enumerator>
    <enumerator>
      <name>VDD525</name>
      <value>525</value>
    </enumerator>
    <enumerator>
      <name>VDD530</name>
      <value>530</value>
    </enumerator>
    <enumerator>
      <name>VDD535</name>
      <value>535</value>
    </enumerator>
    <enumerator>
      <name>VDD540</name>
      <value>540</value>
    </enumerator>
    <enumerator>
      <name>VDD545</name>
      <value>545</value>
    </enumerator>
    <enumerator>
      <name>VDD550</name>
      <value>550</value>
    </enumerator>
    <enumerator>
      <name>VDD555</name>
      <value>555</value>
    </enumerator>
    <enumerator>
      <name>VDD560</name>
      <value>560</value>
    </enumerator>
    <enumerator>
      <name>VDD565</name>
      <value>565</value>
    </enumerator>
    <enumerator>
      <name>VDD570</name>
      <value>570</value>
    </enumerator>
    <enumerator>
      <name>VDD575</name>
      <value>575</value>
    </enumerator>
    <id>CEN_EFF_DRAM_WR_VREF</id>
  </enumerationType>
  <enumerationType>
    <description>Centaur DQ and DQS Drive Impedance Used in various locations and comes from the MT Keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT)/mss_eff_cnfg_termination consumer: initfile,various.C files firmware notes: none This is the nominal value</description>
    <enumerator>
      <name>OHM24_FFE0</name>
      <value>0x0A</value>
    </enumerator>
    <enumerator>
      <name>OHM30_FFE0</name>
      <value>0x08</value>
    </enumerator>
    <enumerator>
      <name>OHM30_FFE480</name>
      <value>0x48</value>
    </enumerator>
    <enumerator>
      <name>OHM30_FFE240</name>
      <value>0x38</value>
    </enumerator>
    <enumerator>
      <name>OHM30_FFE160</name>
      <value>0x28</value>
    </enumerator>
    <enumerator>
      <name>OHM30_FFE120</name>
      <value>0x18</value>
    </enumerator>
    <enumerator>
      <name>OHM34_FFE0</name>
      <value>0x07</value>
    </enumerator>
    <enumerator>
      <name>OHM34_FFE480</name>
      <value>0x47</value>
    </enumerator>
    <enumerator>
      <name>OHM34_FFE240</name>
      <value>0x37</value>
    </enumerator>
    <enumerator>
      <name>OHM34_FFE160</name>
      <value>0x27</value>
    </enumerator>
    <enumerator>
      <name>OHM34_FFE120</name>
      <value>0x17</value>
    </enumerator>
    <enumerator>
      <name>OHM40_FFE0</name>
      <value>0x06</value>
    </enumerator>
    <enumerator>
      <name>OHM40_FFE480</name>
      <value>0x46</value>
    </enumerator>
    <enumerator>
      <name>OHM40_FFE240</name>
      <value>0x36</value>
    </enumerator>
    <enumerator>
      <name>OHM40_FFE160</name>
      <value>0x26</value>
    </enumerator>
    <enumerator>
      <name>OHM40_FFE120</name>
      <value>0x16</value>
    </enumerator>
    <id>CEN_EFF_CEN_DRV_IMP_DQ_DQS</id>
  </enumerationType>
  <enumerationType>
    <description>Centaur DQ and DQS Receiver Impedance Used in various locations and it comes from the VPD MT keyword for custom DIMMs or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD, mss_eff_cnfg_termination Consumer: initfile + C code firmware notes: none This is the nominal value</description>
    <enumerator>
      <name>OHM15</name>
      <value>15</value>
    </enumerator>
    <enumerator>
      <name>OHM20</name>
      <value>20</value>
    </enumerator>
    <enumerator>
      <name>OHM30</name>
      <value>30</value>
    </enumerator>
    <enumerator>
      <name>OHM40</name>
      <value>40</value>
    </enumerator>
    <enumerator>
      <name>OHM48</name>
      <value>48</value>
    </enumerator>
    <enumerator>
      <name>OHM60</name>
      <value>60</value>
    </enumerator>
    <enumerator>
      <name>OHM80</name>
      <value>80</value>
    </enumerator>
    <enumerator>
      <name>OHM120</name>
      <value>120</value>
    </enumerator>
    <enumerator>
      <name>OHM160</name>
      <value>160</value>
    </enumerator>
    <enumerator>
      <name>OHM240</name>
      <value>240</value>
    </enumerator>
    <id>CEN_EFF_CEN_RCV_IMP_DQ_DQS</id>
  </enumerationType>
  <enumerationType>
    <description>Centaur DQ and DQS Slew Rate Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Slowest slew rate is 0, incrementing by one. The lower the number the slower the slew rate the higher the faster. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT), mss_eff_cnfg_termination consumer: initfiles,various.C firmware notes: none This is the nominal value</description>
    <enumerator>
      <name>SLEW_3V_NS</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>SLEW_4V_NS</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>SLEW_5V_NS</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>SLEW_6V_NS</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>SLEW_MAXV_NS</name>
      <value>7</value>
    </enumerator>
    <id>CEN_EFF_CEN_SLEW_RATE_DQ_DQS</id>
  </enumerationType>
  <enumerationType>
    <description>Centaur Read Vref. Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Creator: VPD(MT) or mss_eff_cnfg_termination consumer: various.C and initfiles firmware notes: none This is the nominal value</description>
    <enumerator>
      <name>VDD40375</name>
      <value>40375</value>
    </enumerator>
    <enumerator>
      <name>VDD41750</name>
      <value>41750</value>
    </enumerator>
    <enumerator>
      <name>VDD43125</name>
      <value>43125</value>
    </enumerator>
    <enumerator>
      <name>VDD44500</name>
      <value>44500</value>
    </enumerator>
    <enumerator>
      <name>VDD45875</name>
      <value>45875</value>
    </enumerator>
    <enumerator>
      <name>VDD47250</name>
      <value>47250</value>
    </enumerator>
    <enumerator>
      <name>VDD48625</name>
      <value>48625</value>
    </enumerator>
    <enumerator>
      <name>VDD50000</name>
      <value>50000</value>
    </enumerator>
    <enumerator>
      <name>VDD51375</name>
      <value>51375</value>
    </enumerator>
    <enumerator>
      <name>VDD52750</name>
      <value>52750</value>
    </enumerator>
    <enumerator>
      <name>VDD54125</name>
      <value>54125</value>
    </enumerator>
    <enumerator>
      <name>VDD55500</name>
      <value>55500</value>
    </enumerator>
    <enumerator>
      <name>VDD56875</name>
      <value>56875</value>
    </enumerator>
    <enumerator>
      <name>VDD58250</name>
      <value>58250</value>
    </enumerator>
    <enumerator>
      <name>VDD59625</name>
      <value>59625</value>
    </enumerator>
    <enumerator>
      <name>VDD61000</name>
      <value>61000</value>
    </enumerator>
    <enumerator>
      <name>VDD60375</name>
      <value>60375</value>
    </enumerator>
    <enumerator>
      <name>VDD61750</name>
      <value>61750</value>
    </enumerator>
    <enumerator>
      <name>VDD63125</name>
      <value>63125</value>
    </enumerator>
    <enumerator>
      <name>VDD64500</name>
      <value>64500</value>
    </enumerator>
    <enumerator>
      <name>VDD65875</name>
      <value>65875</value>
    </enumerator>
    <enumerator>
      <name>VDD67250</name>
      <value>67250</value>
    </enumerator>
    <enumerator>
      <name>VDD68625</name>
      <value>68625</value>
    </enumerator>
    <enumerator>
      <name>VDD70000</name>
      <value>70000</value>
    </enumerator>
    <enumerator>
      <name>VDD71375</name>
      <value>71375</value>
    </enumerator>
    <enumerator>
      <name>VDD72750</name>
      <value>72750</value>
    </enumerator>
    <enumerator>
      <name>VDD74125</name>
      <value>74125</value>
    </enumerator>
    <enumerator>
      <name>VDD75500</name>
      <value>75500</value>
    </enumerator>
    <enumerator>
      <name>VDD76875</name>
      <value>76875</value>
    </enumerator>
    <enumerator>
      <name>VDD78250</name>
      <value>78250</value>
    </enumerator>
    <enumerator>
      <name>VDD79625</name>
      <value>79625</value>
    </enumerator>
    <enumerator>
      <name>VDD81000</name>
      <value>81000</value>
    </enumerator>
    <id>CEN_EFF_RD_VREF</id>
  </enumerationType>
  <enumerationType>
    <description>At a system level, this attribute controls if interleaving is required, requested or never. The MRW.</description>
    <enumerator>
      <name>NEVER</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>REQUIRED</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>REQUESTED</name>
      <value>2</value>
    </enumerator>
    <id>CEN_MRW_MBA_CACHELINE_INTERLEAVE_MODE_CONTROL</id>
  </enumerationType>
  <enumerationType>
    <description>Reflects the functionality of the L4 Cache. Determines if the L4 is enabled or not. See chapter 6 of the Centaur Workbook. On means the full cache is enabled. HALF_A (EVEN) means only A is enabled and HALF_B (ODD) means only B is enabled. For DD1X, the values of UNK_OFF, UNK_ON, UNK_HALF_A and UNK_HALFB were added because early parts did not have the fuses blown correctly, so the cache repairs may not have worked. This value is set by the platform which can get the chips value by running the mss_cen_get_ecid function. Note: Cronus and Firmware plus our initfiles do not really support any of the UNK values. It is the responsibility of the platform to map the UNK values to the appropriate value of OFF/ON/HALF_A/HALF_B</description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>HALF_A</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>HALF_B</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>UNK_OFF</name>
      <value>8</value>
    </enumerator>
    <enumerator>
      <name>UNK_ON</name>
      <value>9</value>
    </enumerator>
    <enumerator>
      <name>UNK_HALF_A</name>
      <value>0xB</value>
    </enumerator>
    <enumerator>
      <name>UNK_HALF_B</name>
      <value>0xD</value>
    </enumerator>
    <id>CEN_MSS_CACHE_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Value of on or off. Determines if prefetching enabled or not. See chapter 7 of the Centaur Workbook.</description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <id>CEN_MSS_PREFETCH_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Value of on or off. Determines if the cleaner of the L4 cache (write modified entries to memory on idle cycles) enabled or not. See chapter 7 of the Centaur Workbook.</description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <id>CEN_MSS_CLEANER_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>A disable switch for resetting the phy delay values at the beginning of calling mss_draminit_training.</description>
    <enumerator>
      <name>DISABLE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>0</value>
    </enumerator>
    <id>CEN_MSS_DRAMINIT_RESET_DISABLE</id>
  </enumerationType>
  <enumerationType>
    <description>When this value is true, then mss_eff config will allow a single port to have one dimm and will allow ports to have different sizes. Used in eff_config</description>
    <enumerator>
      <name>FALSE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>1</value>
    </enumerator>
    <id>CEN_MSS_ALLOW_SINGLE_PORT</id>
  </enumerationType>
  <enumerationType>
    <description>DQS Swizzle type is set by the platform to describe what kind of DQS connection is being used for register acceses. Type 0 is normal, type 1 is for systems with wiring like glacier 1, type 2 is for Pallmeto. Additional types maybe defined if new boards have even different DQS swizzle features</description>
    <enumerator>
      <name>NORMAL_TYPE_0</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>GLACIER_TYPE_1</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ISDIMM_TYPE_2</name>
      <value>2</value>
    </enumerator>
    <id>CEN_MSS_DQS_SWIZZLE_TYPE</id>
  </enumerationType>
  <enumerationType>
    <description>The MRW for a system should set this to TRUE for systems that must obey plug rules. Lab environments should default this to off and allow the user to override using normal methods to test.</description>
    <enumerator>
      <name>FALSE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>1</value>
    </enumerator>
    <id>CEN_MRW_STRICT_MBA_PLUG_RULE_CHECKING</id>
  </enumerationType>
  <enumerationType>
    <description>Used for Custom DIMMs to not enable the reading of the dimm temperature sensor on the master i2c bus</description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <id>CEN_MRW_CDIMM_MASTER_I2C_TEMP_SENSOR_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Used for Custom DIMMs to not enable the reading of the dimm temperature sensor on the spare i2c bus</description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>1</value>
    </enumerator>
    <id>CEN_MRW_CDIMM_SPARE_I2C_TEMP_SENSOR_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Possible DRAM voltage override.</description>
    <enumerator>
      <name>NONE</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>VOLT_135</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>VOLT_120</name>
      <value>0x02</value>
    </enumerator>
    <id>CEN_MSS_VOLT_OVERRIDE</id>
  </enumerationType>
  <enumerationType>
    <description>List of Voltages that are compliant with the system. DIMMs that do not have voltages listed in their SPD as supported are errored out. Procedure defined is currently 1.2V and 1.35V only.</description>
    <enumerator>
      <name>PROCEDURE_DEFINED</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ALL_VOLTAGES</name>
      <value>0x01</value>
    </enumerator>
    <id>CEN_MSS_VOLT_COMPLIANT_DIMMS</id>
  </enumerationType>
  <enumerationType>
    <description>Capable power control settings. In MRW.</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>SLOWEXIT</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>FASTEXIT</name>
      <value>0x02</value>
    </enumerator>
    <id>CEN_MRW_POWER_CONTROL_REQUESTED</id>
  </enumerationType>
  <enumerationType>
    <description>Machine Readable Workbook enablement of the HWP code to adjust the VMEM regulator power limit based on number of installed DIMMs.</description>
    <enumerator>
      <name>FALSE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TRUE</name>
      <value>1</value>
    </enumerator>
    <id>CEN_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <default>NA</default>
    <description>Enumeration indicating the target's class</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>CARD</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ENC</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>CHIP</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>UNIT</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>DEV</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>SYS</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>LOGICAL_CARD</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>BATTERY</name>
      <value>8</value>
    </enumerator>
    <enumerator>
      <name>LED</name>
      <value>9</value>
    </enumerator>
    <enumerator>
      <name>SP</name>
      <value>10</value>
    </enumerator>
    <enumerator>
      <name>MAX</name>
      <value>11</value>
    </enumerator>
    <id>CLASS</id>
  </enumerationType>
  <enumerationType>
    <default>NA</default>
    <description>Enumeration indicating the target's type</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>SYS</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>NODE</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>DIMM</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>MEMBUF</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>PROC</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>EX</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>CORE</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>L2</name>
      <value>8</value>
    </enumerator>
    <enumerator>
      <name>L3</name>
      <value>9</value>
    </enumerator>
    <enumerator>
      <name>L4</name>
      <value>10</value>
    </enumerator>
    <enumerator>
      <name>MCS</name>
      <value>11</value>
    </enumerator>
    <enumerator>
      <name>MBA</name>
      <value>13</value>
    </enumerator>
    <enumerator>
      <name>XBUS</name>
      <value>14</value>
    </enumerator>
    <enumerator>
      <name>ABUS</name>
      <value>15</value>
    </enumerator>
    <enumerator>
      <name>PCI</name>
      <value>16</value>
    </enumerator>
    <enumerator>
      <name>DPSS</name>
      <value>17</value>
    </enumerator>
    <enumerator>
      <name>APSS</name>
      <value>18</value>
    </enumerator>
    <enumerator>
      <name>OCC</name>
      <value>19</value>
    </enumerator>
    <enumerator>
      <name>PSI</name>
      <value>20</value>
    </enumerator>
    <enumerator>
      <name>FSP</name>
      <value>21</value>
    </enumerator>
    <enumerator>
      <name>PNOR</name>
      <value>22</value>
    </enumerator>
    <enumerator>
      <name>OSC</name>
      <value>23</value>
    </enumerator>
    <enumerator>
      <name>TODCLK</name>
      <value>24</value>
    </enumerator>
    <enumerator>
      <name>CONTROL_NODE</name>
      <value>25</value>
    </enumerator>
    <enumerator>
      <name>OSCREFCLK</name>
      <value>26</value>
    </enumerator>
    <enumerator>
      <name>OSCPCICLK</name>
      <value>27</value>
    </enumerator>
    <enumerator>
      <name>REFCLKENDPT</name>
      <value>28</value>
    </enumerator>
    <enumerator>
      <name>PCICLKENDPT</name>
      <value>29</value>
    </enumerator>
    <enumerator>
      <name>NX</name>
      <value>30</value>
    </enumerator>
    <enumerator>
      <name>PORE</name>
      <value>31</value>
    </enumerator>
    <enumerator>
      <name>PCIESWITCH</name>
      <value>32</value>
    </enumerator>
    <enumerator>
      <name>CAPP</name>
      <value>33</value>
    </enumerator>
    <enumerator>
      <name>FSI</name>
      <value>34</value>
    </enumerator>
    <enumerator>
      <name>EQ</name>
      <value>35</value>
    </enumerator>
    <enumerator>
      <name>MCA</name>
      <value>36</value>
    </enumerator>
    <enumerator>
      <name>MCBIST</name>
      <value>37</value>
    </enumerator>
    <enumerator>
      <name>MI</name>
      <value>38</value>
    </enumerator>
    <enumerator>
      <name>DMI</name>
      <value>39</value>
    </enumerator>
    <enumerator>
      <name>OBUS</name>
      <value>40</value>
    </enumerator>
    <enumerator>
      <name>NV</name>
      <value>41</value>
    </enumerator>
    <enumerator>
      <name>SBE</name>
      <value>42</value>
    </enumerator>
    <enumerator>
      <name>PPE</name>
      <value>43</value>
    </enumerator>
    <enumerator>
      <name>PERV</name>
      <value>44</value>
    </enumerator>
    <enumerator>
      <name>PEC</name>
      <value>45</value>
    </enumerator>
    <enumerator>
      <name>PHB</name>
      <value>46</value>
    </enumerator>
    <enumerator>
      <name>SYSREFCLKENDPT</name>
      <value>47</value>
    </enumerator>
    <enumerator>
      <name>MFREFCLKENDPT</name>
      <value>48</value>
    </enumerator>
    <enumerator>
      <name>TPM</name>
      <value>49</value>
    </enumerator>
    <enumerator>
      <name>SP</name>
      <value>50</value>
    </enumerator>
    <enumerator>
      <name>UART</name>
      <value>51</value>
    </enumerator>
    <enumerator>
      <name>PS</name>
      <value>52</value>
    </enumerator>
    <enumerator>
      <name>FAN</name>
      <value>53</value>
    </enumerator>
    <enumerator>
      <name>VRM</name>
      <value>54</value>
    </enumerator>
    <enumerator>
      <name>USB</name>
      <value>55</value>
    </enumerator>
    <enumerator>
      <name>ETH</name>
      <value>56</value>
    </enumerator>
    <enumerator>
      <name>PANEL</name>
      <value>57</value>
    </enumerator>
    <enumerator>
      <name>BMC</name>
      <value>58</value>
    </enumerator>
    <enumerator>
      <name>FLASH</name>
      <value>59</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM</name>
      <value>60</value>
    </enumerator>
    <enumerator>
      <name>TMP</name>
      <value>61</value>
    </enumerator>
    <enumerator>
      <name>GPIO_EXPANDER</name>
      <value>62</value>
    </enumerator>
    <enumerator>
      <name>POWER_SEQUENCER</name>
      <value>63</value>
    </enumerator>
    <enumerator>
      <name>RTC</name>
      <value>64</value>
    </enumerator>
    <enumerator>
      <name>FANCTLR</name>
      <value>65</value>
    </enumerator>
    <enumerator>
      <name>OBUS_BRICK</name>
      <value>66</value>
    </enumerator>
    <enumerator>
      <name>NPU</name>
      <value>67</value>
    </enumerator>
    <enumerator>
      <name>MC</name>
      <value>68</value>
    </enumerator>
    <enumerator>
      <name>TEST_FAIL</name>
      <value>69</value>
    </enumerator>
    <enumerator>
      <name>MFREFCLK</name>
      <value>70</value>
    </enumerator>
    <enumerator>
      <name>LAST_IN_RANGE</name>
      <value>71</value>
    </enumerator>
    <id>TYPE</id>
  </enumerationType>
  <enumerationType>
    <default>NA</default>
    <description>Enumeration indicating the target's model</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>RESERVED</name>
      <value>16</value>
    </enumerator>
    <enumerator>
      <name>VENICE</name>
    </enumerator>
    <enumerator>
      <name>MURANO</name>
    </enumerator>
    <enumerator>
      <name>NAPLES</name>
    </enumerator>
    <enumerator>
      <name>NIMBUS</name>
    </enumerator>
    <enumerator>
      <name>CUMULUS</name>
    </enumerator>
    <enumerator>
      <name>CENTAUR</name>
      <value>48</value>
    </enumerator>
    <enumerator>
      <name>JEDEC</name>
      <value>80</value>
    </enumerator>
    <enumerator>
      <name>CDIMM</name>
    </enumerator>
    <enumerator>
      <name>POWER8</name>
      <value>112</value>
    </enumerator>
    <enumerator>
      <name>POWER9</name>
      <value>144</value>
    </enumerator>
    <enumerator>
      <name>CECTPM</name>
    </enumerator>
    <enumerator>
      <name>BMC</name>
    </enumerator>
    <enumerator>
      <name>AST2500</name>
    </enumerator>
    <id>MODEL</id>
  </enumerationType>
  <enumerationType>
    <default>NA</default>
    <description>Enumeration indicating the target's engine type</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ENGINE_IIC</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ENGINE_SCOM</name>
      <value>2</value>
    </enumerator>
    <id>ENGINE_TYPE</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration indicating the services that are concerned with target changes (ie, via HCDB change). The values can be combined using a bitwise 'OR'.</description>
    <enumerator>
      <name>GARD</name>
      <value>0x00000001</value>
    </enumerator>
    <enumerator>
      <name>MEMDIAG</name>
      <value>0x00000002</value>
    </enumerator>
    <enumerator>
      <name>PSIDIAG</name>
      <value>0x00000004</value>
    </enumerator>
    <enumerator>
      <name>DIAG_MASK</name>
      <value>0x00000006</value>
    </enumerator>
    <enumerator>
      <name>HOSTSVC_HBEL</name>
      <value>0x00000008</value>
    </enumerator>
    <id>HWAS_CHANGED_BIT</id>
  </enumerationType>
  <enumerationType>
    <description>Processor epsilon table type. Used to calculate the processor nest epsilon register values. Provided by the MRW.</description>
    <enumerator>
      <name>EPS_TYPE_LE</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>EPS_TYPE_HE</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>EPS_TYPE_HE_F8</name>
      <value>0x03</value>
    </enumerator>
    <id>PROC_EPS_TABLE_TYPE</id>
  </enumerationType>
  <enumerationType>
    <description>Processor SMP Fabric broadcast scope configuration. CHIP_IS_NODE = MODE1 = default CHIP_IS_GROUP = MODE2 Provided by the MRW.</description>
    <enumerator>
      <name>CHIP_IS_NODE</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>CHIP_IS_GROUP</name>
      <value>0x02</value>
    </enumerator>
    <id>PROC_FABRIC_PUMP_MODE</id>
  </enumerationType>
  <enumerationType>
    <default>UNKNOWN</default>
    <description>Enumeration indicating what kind of payload is to be started</description>
    <enumerator>
      <name>UNKNOWN</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>PHYP</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SAPPHIRE</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>NONE</name>
      <value>3</value>
    </enumerator>
    <id>PAYLOAD_KIND</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration indicating the mnfg flags that are set by the user. The values can be combined using a bitwise 'OR'. The values will need to be kept in sync with the FAPI enumerator values. Also the enumeration type is used by the ATTR_MNFG_FLAGS attribute. Should note that the MNFG_FLAG values are of type uint32_t</description>
    <enumerator>
      <name>THRESHOLDS</name>
      <value>0x00000001</value>
    </enumerator>
    <enumerator>
      <name>AVP_ENABLE</name>
      <value>0x00000002</value>
    </enumerator>
    <enumerator>
      <name>HDAT_AVP_ENABLE</name>
      <value>0x00000004</value>
    </enumerator>
    <enumerator>
      <name>SRC_TERM</name>
      <value>0x00000008</value>
    </enumerator>
    <enumerator>
      <name>IPL_MEMORY_CE_CHECKING</name>
      <value>0x00000010</value>
    </enumerator>
    <enumerator>
      <name>FAST_BACKGROUND_SCRUB</name>
      <value>0x00000020</value>
    </enumerator>
    <enumerator>
      <name>TEST_DRAM_REPAIRS</name>
      <value>0x00000040</value>
    </enumerator>
    <enumerator>
      <name>DISABLE_DRAM_REPAIRS</name>
      <value>0x00000080</value>
    </enumerator>
    <enumerator>
      <name>ENABLE_EXHAUSTIVE_PATTERN_TEST</name>
      <value>0x00000100</value>
    </enumerator>
    <enumerator>
      <name>ENABLE_STANDARD_PATTERN_TEST</name>
      <value>0x00000200</value>
    </enumerator>
    <enumerator>
      <name>ENABLE_MINIMUM_PATTERN_TEST</name>
      <value>0x00000400</value>
    </enumerator>
    <enumerator>
      <name>DISABLE_FABRIC_eREPAIR</name>
      <value>0x00000800</value>
    </enumerator>
    <enumerator>
      <name>DISABLE_MEMORY_eREPAIR</name>
      <value>0x00001000</value>
    </enumerator>
    <enumerator>
      <name>FABRIC_DEPLOY_LANE_SPARES</name>
      <value>0x00002000</value>
    </enumerator>
    <enumerator>
      <name>DMI_DEPLOY_LANE_SPARES</name>
      <value>0x00004000</value>
    </enumerator>
    <enumerator>
      <name>PSI_DIAGNOSTIC</name>
      <value>0x00008000</value>
    </enumerator>
    <enumerator>
      <name>BRAZOS_WRAP_CONFIG</name>
      <value>0x00010000</value>
    </enumerator>
    <enumerator>
      <name>FSP_UPDATE_SBE_IMAGE</name>
      <value>0x00020000</value>
    </enumerator>
    <enumerator>
      <name>UPDATE_BOTH_SIDES_OF_SBE</name>
      <value>0x00040000</value>
    </enumerator>
    <id>MNFG_FLAG</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration indicating the BAR size used with ATTR_PROC_NPU_MMIO_BAR_SIZE</description>
    <enumerator>
      <name>2_MB</name>
      <value>0x0000000000200000</value>
    </enumerator>
    <enumerator>
      <name>1_MB</name>
      <value>0x0000000000100000</value>
    </enumerator>
    <enumerator>
      <name>512_KB</name>
      <value>0x0000000000080000</value>
    </enumerator>
    <enumerator>
      <name>256_KB</name>
      <value>0x0000000000040000</value>
    </enumerator>
    <enumerator>
      <name>128_KB</name>
      <value>0x0000000000020000</value>
    </enumerator>
    <enumerator>
      <name>64_KB</name>
      <value>0x0000000000010000</value>
    </enumerator>
    <id>NPU_MMIO_BAR_SIZE</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration indicating which chip should be used as the PROC_SELECT_BOOT_MASTER</description>
    <enumerator>
      <name>PRIMARY</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SECONDARY</name>
      <value>2</value>
    </enumerator>
    <id>PROC_SELECT_BOOT_MASTER</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration indicating which _PBIEX_ASYNC_SEL should be use</description>
    <enumerator>
      <name>SEL0</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>SEL1</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SEL2</name>
      <value>2</value>
    </enumerator>
    <id>PROC_PBIEX_ASYNC_SEL</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration of CDM_POLICIES flags</description>
    <enumerator>
      <description>MFG_Guard policy: Used in MFG only to prevent and disable the following: . Storing or creation of new Guard records from Diagno`stic or other faults through error logs. This is all domains, CEC processor/memory, VPD, FSP, etc. . Storing or creation of Manual Guard record from user. NOTE: this does not stop FCO. . Using an already stored System or Manual Guard record from deconfiguring resources. This is all domains, CEC processor/memory, VPD, FSP, etc.</description>
      <name>MANUFACTURING_DISABLED</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <description>Predictive_Guard policy: Used in Field or development to prevent and disable the following: . Storing or creation of new Guard records from diagnostics or other faults through error logs with the error_type of Predictive. . Using an already stored System Guard record with error_type of Predictive from deconfiguring resources.</description>
      <name>PREDICTIVE_DISABLED</name>
      <value>0x02</value>
    </enumerator>
    <id>CDM_POLICIES</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration indicating the multi scome buffer size. The values can be combined using a bitwise 'OR'. The values will need to be kept in sync with the FAPI enumerator values. Also the enumeration type is used by the ATTR_MULTI_SCOM_BUFFER_MAX_SIZE. Should note that the MULTI_SCOM_BUFFER_MAX_SIZE values are of type uint32_t</description>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_1KB</name>
      <value>0x00000400</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_2KB</name>
      <value>0x00000800</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_4KB</name>
      <value>0x00001000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_8KB</name>
      <value>0x00002000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_16KB</name>
      <value>0x00004000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_32KB</name>
      <value>0x00008000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_64KB</name>
      <value>0x00010000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_128KB</name>
      <value>0x00020000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_256KB</name>
      <value>0x00040000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_512KB</name>
      <value>0x00080000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_1MB</name>
      <value>0x00100000</value>
    </enumerator>
    <id>MULTI_SCOM_BUFFER_MAX_SIZE_BIT</id>
  </enumerationType>
  <enumerationType>
    <default>OFF</default>
    <description>Memory power control settings programmed during IPL Used by OCC when exiting idle power-save mode</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>POWER_DOWN</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>PD_AND_STR</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>PD_AND_STR_CLK_STOP</name>
      <value>0x03</value>
    </enumerator>
    <id>MSS_MRW_POWER_CONTROL_REQUESTED</id>
  </enumerationType>
  <enumerationType>
    <default>NONE</default>
    <description>Memory power control settings for IDLE powersave mode Used by OCC when entering idle power-save mode</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>POWER_DOWN</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>PD_AND_STR</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>PD_AND_STR_CLK_STOP</name>
      <value>0x03</value>
    </enumerator>
    <id>MSS_MRW_IDLE_POWER_CONTROL_REQUESTED</id>
  </enumerationType>
  <enumerationType>
    <default>NONE</default>
    <description>Enumeration specifying a target's CEC degraded mode domain</description>
    <enumerator>
      <name>NONE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>CPU</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>DIMM</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>FABRIC</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>MEM</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>IO</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>NODE</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>CLOCK</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>PSI</name>
      <value>8</value>
    </enumerator>
    <enumerator>
      <name>FSP</name>
      <value>9</value>
    </enumerator>
    <enumerator>
      <name>ALL</name>
      <value>10</value>
    </enumerator>
    <id>CDM_DOMAIN</id>
  </enumerationType>
  <enumerationType>
    <default>NA</default>
    <description>Enumeration indication which Hot Plug Controllers are supported by the current system.</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>MAX5961</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>PCA9551</name>
      <value>0x02</value>
    </enumerator>
    <id>SUPPORTED_HOT_PLUG</id>
  </enumerationType>
  <enumerationType>
    <description>Defines which of the PSS chip selects (0 or 1) that the APSS is connected Provided by the Machine Readable Workbook. Consumer: p9_pm_pss_init</description>
    <enumerator>
      <name>NONE</name>
      <value>0xFF</value>
    </enumerator>
    <enumerator>
      <name>CS0</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>CS1</name>
      <value>0x01</value>
    </enumerator>
    <id>PM_APSS_CHIP_SELECT</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration to select WOF Power Limit</description>
    <enumerator>
      <name>NOMINAL</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TURBO</name>
      <value>1</value>
    </enumerator>
    <id>WOF_POWER_LIMIT</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration indicating the OFF setting for the core and cache chiplet DD PFET controllers</description>
    <enumerator>
      <name>NOOFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT1TO7OFF</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT2TO7OFF</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT3TO7OFF</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT4TO7OFF</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT5TO7OFF</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT6TO7OFF</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT7TO7OFF</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>ALLOFF</name>
      <value>8</value>
    </enumerator>
    <id>PFET_VDD_VOFF_SEL</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration indicating the OFF setting for the core and cache chiplet VCS PFET controllers</description>
    <enumerator>
      <name>NOOFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT1TO7OFF</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT2TO7OFF</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT3TO7OFF</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT4TO7OFF</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT5TO7OFF</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT6TO7OFF</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT7TO7OFF</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>ALLOFF</name>
      <value>8</value>
    </enumerator>
    <id>PFET_VCS_VOFF_SEL</id>
  </enumerationType>
  <enumerationType>
    <description>Processor SMP A bus width. Provided by the MRW.</description>
    <enumerator>
      <name>2_BYTE</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>4_BYTE</name>
      <value>0x02</value>
    </enumerator>
    <id>PROC_FABRIC_A_BUS_WIDTH</id>
  </enumerationType>
  <enumerationType>
    <description>Processor SMP X bus width. Provided by the MRW.</description>
    <enumerator>
      <name>2_BYTE</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>4_BYTE</name>
      <value>0x02</value>
    </enumerator>
    <id>PROC_FABRIC_X_BUS_WIDTH</id>
  </enumerationType>
  <enumerationType>
    <description>Processor SMP optics mode. 0 = default = Optics_is_X_bus 1 = Optics_is_A_bus Provided by the MRW.</description>
    <enumerator>
      <name>OPTICS_IS_X_BUS</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>OPTICS_IS_A_BUS</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_FABRIC_SMP_OPTICS_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Processor CAPI attachement protocol mode. 0 = default = no: SMPA CAPI attachement 1 = yes: SMPA CAPI attachement Provided by the MRW.</description>
    <enumerator>
      <name>OFF</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_FABRIC_CAPI_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration for Voltage Drop Monitor enable</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <id>VDM_ENABLE</id>
  </enumerationType>
  <enumerationType>
    <description>Used in MR4 A3 Temperature refresh mode Should be defaulted to disable</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_TEMP_REFRESH_MODE</id>
  </enumerationType>
  <enumerationType>
    <description>Pulled from the MRW, this describes the device type to the HDAT. This is for I2C devices only.</description>
    <enumerator>
      <name>9551</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>955x</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel28c128</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>NUVOTON_TPM</name>
      <value>0x3</value>
    </enumerator>
    <enumerator>
      <name>MEX_FPGA</name>
      <value>0x4</value>
    </enumerator>
    <enumerator>
      <name>UCX90XX</name>
      <value>0x5</value>
    </enumerator>
    <enumerator>
      <name>NVLINK</name>
      <value>0x6</value>
    </enumerator>
    <enumerator>
      <name>9552</name>
      <value>0x6</value>
    </enumerator>
    <enumerator>
      <name>9553</name>
      <value>0x7</value>
    </enumerator>
    <enumerator>
      <name>9554</name>
      <value>0x8</value>
    </enumerator>
    <enumerator>
      <name>9555</name>
      <value>0x9</value>
    </enumerator>
    <enumerator>
      <name>SMP_or_OpenCAPI_Cable</name>
      <value>0xA</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel28c256</name>
      <value>0xB</value>
    </enumerator>
    <enumerator>
      <name>UNKNOWN</name>
      <value>0xFF</value>
    </enumerator>
    <id>HDAT_I2C_DEVICE_TYPE</id>
  </enumerationType>
  <enumerationType>
    <description>Pulled from the MRW, this describes the device purpose to the HDAT. This is for I2C devices only.</description>
    <enumerator>
      <name>CABLE_CARD_PRES</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>PCI_HOTPLUG_PGOOD</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>PCI_HOTPLUG_CONTROL</name>
      <value>0x3</value>
    </enumerator>
    <enumerator>
      <name>TPM</name>
      <value>0x4</value>
    </enumerator>
    <enumerator>
      <name>MODULE_VPD</name>
      <value>0x5</value>
    </enumerator>
    <enumerator>
      <name>DIMM_SPD</name>
      <value>0x6</value>
    </enumerator>
    <enumerator>
      <name>PROC_MODULE_VPD</name>
      <value>0x7</value>
    </enumerator>
    <enumerator>
      <name>SBE_SEEPROM</name>
      <value>0x8</value>
    </enumerator>
    <enumerator>
      <name>PLANAR_VPD</name>
      <value>0x9</value>
    </enumerator>
    <enumerator>
      <name>NVLINK_CABLE_TOPOLOGY_VERIFICATION</name>
      <value>0xA</value>
    </enumerator>
    <enumerator>
      <name>NVLINK</name>
      <value>0xB</value>
    </enumerator>
    <enumerator>
      <name>NVLINK_CABLE_MICRO_RESET</name>
      <value>0xB</value>
    </enumerator>
    <enumerator>
      <name>I2C_ASSOC_WITH_NVLINK_CABLE</name>
      <value>0xC</value>
    </enumerator>
    <enumerator>
      <name>WINDOW_OPEN</name>
      <value>0xD</value>
    </enumerator>
    <enumerator>
      <name>PHYSICAL_PRESENCE</name>
      <value>0xE</value>
    </enumerator>
    <enumerator>
      <name>MEX_FPGA</name>
      <value>0xF</value>
    </enumerator>
    <enumerator>
      <name>UNKNOWN</name>
      <value>0xFF</value>
    </enumerator>
    <id>HDAT_I2C_DEVICE_PURPOSE</id>
  </enumerationType>
  <enumerationType>
    <description>Enum for FUSED_CORE_MODE_HB</description>
    <enumerator>
      <name>SMT4_DEFAULT</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>SMT4_ONLY</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SMT8_ONLY</name>
      <value>2</value>
    </enumerator>
    <id>FUSED_CORE_MODE_HB</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration defining the offsets into the IPMI_SENSORS array.</description>
    <enumerator>
      <name>NAME_OFFSET</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>NUMBER_OFFSET</name>
      <value>0x01</value>
    </enumerator>
    <id>IPMI_SENSOR_ARRAY</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration indicating the IPMI sensor name, which will be used by hostboot when determining the sensor number to return. The sensor name consists of one byte of sensor type plus one byte of sub-type, to differentiate similar sensors under the same target. Our implementaion uses the IPMI defined entity ID as the sub-type.</description>
    <enumerator>
      <name>PROC_TEMP</name>
      <value>0x0103</value>
    </enumerator>
    <enumerator>
      <name>DIMM_TEMP</name>
      <value>0x0120</value>
    </enumerator>
    <enumerator>
      <name>CORE_TEMP</name>
      <value>0x01D0</value>
    </enumerator>
    <enumerator>
      <name>STATE</name>
      <value>0x0500</value>
    </enumerator>
    <enumerator>
      <name>MEMBUF_TEMP</name>
      <value>0x01D1</value>
    </enumerator>
    <enumerator>
      <name>PROC_STATE</name>
      <value>0x0703</value>
    </enumerator>
    <enumerator>
      <name>CORE_STATE</name>
      <value>0x07D0</value>
    </enumerator>
    <enumerator>
      <name>DIMM_STATE</name>
      <value>0x0C20</value>
    </enumerator>
    <enumerator>
      <name>MEMBUF_STATE</name>
      <value>0x0CD1</value>
    </enumerator>
    <enumerator>
      <name>FW_BOOT_PROGRESS</name>
      <value>0x0F22</value>
    </enumerator>
    <enumerator>
      <name>SYSTEM_EVENT</name>
      <value>0x1201</value>
    </enumerator>
    <enumerator>
      <name>OS_BOOT</name>
      <value>0x1F23</value>
    </enumerator>
    <enumerator>
      <name>HOST_STATUS</name>
      <value>0x2223</value>
    </enumerator>
    <enumerator>
      <name>OCC_ACTIVE</name>
      <value>0x07D2</value>
    </enumerator>
    <enumerator>
      <name>CORE_FREQ</name>
      <value>0xC1D0</value>
    </enumerator>
    <enumerator>
      <name>APSS_CHANNEL</name>
      <value>0xC2D7</value>
    </enumerator>
    <enumerator>
      <name>PCI_ACTIVE</name>
      <value>0xC423</value>
    </enumerator>
    <enumerator>
      <name>REBOOT_COUNT</name>
      <value>0xC322</value>
    </enumerator>
    <enumerator>
      <name>FAULT</name>
      <value>0xC700</value>
    </enumerator>
    <enumerator>
      <name>BACKPLANE_FAULT</name>
      <value>0xC707</value>
    </enumerator>
    <enumerator>
      <name>REF_CLOCK_FAULT</name>
      <value>0xC7D4</value>
    </enumerator>
    <enumerator>
      <name>PCI_CLOCK_FAULT</name>
      <value>0xC7D5</value>
    </enumerator>
    <enumerator>
      <name>TOD_CLOCK_FAULT</name>
      <value>0xC7D6</value>
    </enumerator>
    <enumerator>
      <name>APSS_FAULT</name>
      <value>0xC7D7</value>
    </enumerator>
    <enumerator>
      <name>DERATING_FACTOR</name>
      <value>0xC815</value>
    </enumerator>
    <enumerator>
      <name>REDUNDANT_PS_POLICY</name>
      <value>0xCA22</value>
    </enumerator>
    <enumerator>
      <name>TPM_REQUIRED</name>
      <value>0xCC03</value>
    </enumerator>
    <id>SENSOR_NAME</id>
  </enumerationType>
  <enumerationType>
    <default>DD10</default>
    <description>Enumeration indicating the chip version</description>
    <enumerator>
      <name>DD10</name>
      <value>0x10</value>
    </enumerator>
    <enumerator>
      <name>DD11</name>
      <value>0x11</value>
    </enumerator>
    <enumerator>
      <name>DD20</name>
      <value>0x20</value>
    </enumerator>
    <enumerator>
      <name>DD21</name>
      <value>0x21</value>
    </enumerator>
    <id>CHIP_VER</id>
  </enumerationType>
  <enumerationType>
    <default>BMC_HW_VER</default>
    <description>Enumeration indicating the chip HW version</description>
    <enumerator>
      <name>FSP_HW_VER</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>BMC_HW_VER</name>
      <value>0x3</value>
    </enumerator>
    <id>HW_VER</id>
  </enumerationType>
  <enumerationType>
    <default>BMC_SW_VER</default>
    <description>Enumeration indicating the SW version</description>
    <enumerator>
      <name>FSP_SW_VER</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>BMC_SW_VER</name>
      <value>0x2</value>
    </enumerator>
    <id>SW_VER</id>
  </enumerationType>
  <enumerationType>
    <default>PRIMARY</default>
    <description>Enumeration indicating the master's FSI type</description>
    <enumerator>
      <name>PRIMARY</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>BACKUP</name>
      <value>0</value>
    </enumerator>
    <id>ROLE</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration indicating the IPMI entity ID, these values are defined in the IPMI specification. These values will be used in place of target type when events are sent to the BMC.</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>OTHER</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>PROCESSOR</name>
      <value>0x03</value>
    </enumerator>
    <enumerator>
      <name>SYSTEM_BOARD</name>
      <value>0x07</value>
    </enumerator>
    <enumerator>
      <name>POWER_MGMT</name>
      <value>0x15</value>
    </enumerator>
    <enumerator>
      <name>CHASSIS</name>
      <value>0x17</value>
    </enumerator>
    <enumerator>
      <name>MEMORY_DEVICE</name>
      <value>0x20</value>
    </enumerator>
    <enumerator>
      <name>BIOS</name>
      <value>0x22</value>
    </enumerator>
    <enumerator>
      <name>OS</name>
      <value>0x23</value>
    </enumerator>
    <enumerator>
      <name>CORE</name>
      <value>0xD0</value>
    </enumerator>
    <enumerator>
      <name>MEMBUF</name>
      <value>0xD1</value>
    </enumerator>
    <enumerator>
      <name>OCC</name>
      <value>0xD2</value>
    </enumerator>
    <enumerator>
      <name>REF_CLOCK</name>
      <value>0xD4</value>
    </enumerator>
    <enumerator>
      <name>PCI_CLOCK</name>
      <value>0xD5</value>
    </enumerator>
    <enumerator>
      <name>TOD_CLOCK</name>
      <value>0xD6</value>
    </enumerator>
    <enumerator>
      <name>APSS</name>
      <value>0xD7</value>
    </enumerator>
    <id>ENTITY_ID</id>
  </enumerationType>
  <enumerationType>
    <description>Enumeration indicating the IPMI sensor type, these values are defined in the IPMI specification. These values will be used when sending sensor reading events to the BMC.</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TEMPERATURE</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>PROCESSOR</name>
      <value>0x07</value>
    </enumerator>
    <enumerator>
      <name>MEMORY</name>
      <value>0x0c</value>
    </enumerator>
    <enumerator>
      <name>SYS_FW_PROGRESS</name>
      <value>0x0F</value>
    </enumerator>
    <enumerator>
      <name>SYS_EVENT</name>
      <value>0x12</value>
    </enumerator>
    <enumerator>
      <name>OS_BOOT</name>
      <value>0x1F</value>
    </enumerator>
    <enumerator>
      <name>APCI_POWER_STATE</name>
      <value>0x22</value>
    </enumerator>
    <enumerator>
      <name>FREQ</name>
      <value>0xC1</value>
    </enumerator>
    <enumerator>
      <name>POWER</name>
      <value>0xC2</value>
    </enumerator>
    <enumerator>
      <name>BOOT_COUNT</name>
      <value>0xC3</value>
    </enumerator>
    <enumerator>
      <name>PCI_LINK_PRES</name>
      <value>0xC4</value>
    </enumerator>
    <enumerator>
      <name>PWR_LIMIT_ACTIVE</name>
      <value>0xC4</value>
    </enumerator>
    <enumerator>
      <name>FAULT</name>
      <value>0xC7</value>
    </enumerator>
    <id>SENSOR_TYPE</id>
  </enumerationType>
</attributes>
